<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2017-05-22T19:29:26+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux - 常用基本命令]]></title>
    <link href="http://www.citynight.cn/Blog/14954518367171.html"/>
    <updated>2017-05-22T19:17:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954518367171.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.命令使用方法</h2>

<p>Linux命令格式:</p>

<pre><code>    command  [-options]  [parameter1]  …
</code></pre>

<p>说明：</p>

<ul>
<li>command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，<code>[]代表可选</code> parameter1 …：传给命令的参数：可以是零个一个或多个</li>
</ul>

<p>例：</p>

<p><img src="media/14954518367171/14954519660499.jpg" alt=""/></p>

<h2 id="toc_1">2.查看帮助文档</h2>

<h3 id="toc_2"><1> &ndash;help</h3>

<p>一般是linux命令自带的帮助信息</p>

<p>如：ls &ndash;help</p>

<h3 id="toc_3"><2> man(有问题找男人，manual)</h3>

<p>man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明</p>

<p>该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>

<p>例：man ls ; man 2 printf</p>

<p>man中各个section意义如下：</p>

<ol>
<li>Standard commands（标准命令）</li>
<li>System calls（系统调用，如open,write）</li>
<li>Library functions（库函数，如printf,fopen）</li>
<li>Special devices（设备文件的说明，/dev下各种设备）</li>
<li>File formats（文件格式，如passwd）</li>
<li>Games and toys（游戏和娱乐）</li>
<li>Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</li>
<li>Administrative Commands（管理员命令，如ifconfig）</li>
</ol>

<p>man是按照手册的章节号的顺序进行搜索的。</p>

<p>man设置了如下的功能键：</p>

<table>
<thead>
<tr>
<th style="text-align: center">功能键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td style="text-align: center">Enter键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td style="text-align: center">f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td style="text-align: center">q</td>
<td>退出man命令</td>
</tr>
<tr>
<td style="text-align: center">h</td>
<td>列出所有功能键</td>
</tr>
<tr>
<td style="text-align: center">/word</td>
<td>搜索word字符串</td>
</tr>
</tbody>
</table>

<p><img src="media/14954518367171/14954525011190.jpg" alt=""/></p>

<p>注意：实际上，我们不用指定第几个章节也用查看，如，man ls</p>

<h2 id="toc_4">3.自动补全：</h2>

<p>在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>

<h2 id="toc_5">4.历史命令：</h2>

<p>当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 文件和目录]]></title>
    <link href="http://www.citynight.cn/Blog/14954377078014.html"/>
    <updated>2017-05-22T15:21:47+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954377078014.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类Unix系统目录结构</h2>

<p>ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面</p>

<p><img src="media/14954377078014/14954378312055.jpg" alt=""/></p>

<h2 id="toc_1">Linux 目录</h2>

<ul>
<li>/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</li>
<li>/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。</li>
<li>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</li>
<li>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</li>
<li>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。</li>
<li>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</li>
<li>/opt：给主机额外安装软件所摆放的目录。</li>
<li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</li>
<li>/root：系统管理员root的家目录。</li>
<li>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li>
<li>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</li>
<li>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。</li>
<li>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。</li>
</ul>

<h2 id="toc_2">用户目录</h2>

<p>位于/home/user，称之为用户工作目录或家目录,表示方式：</p>

<pre><code>/home/user
~

</code></pre>

<h3 id="toc_3">相对路径和绝对路径</h3>

<h4 id="toc_4">绝对路径</h4>

<p>从/目录开始描述的路径为绝对路径，如：</p>

<pre><code>cd /home
ls /usr

</code></pre>

<h4 id="toc_5">相对路径</h4>

<p>从当前位置开始描述的路径为相对路径，如：</p>

<pre><code>cd ../../
ls abc/def

</code></pre>

<h4 id="toc_6">.和..</h4>

<p>每个目录下都有.和..</p>

<p>. 表示当前目录</p>

<p>.. 表示上一级目录，即父目录</p>

<p>根目录下的.和..都表示当前目录</p>

<h2 id="toc_7">文件权限</h2>

<p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p>

<p>Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>

<p>在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>

<h3 id="toc_8">访问用户</h3>

<p>通过设定权限可以从以下三种访问方式限制访问权限：</p>

<ul>
<li><p>只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。</p></li>
<li><p>允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。</p></li>
<li><p>允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类</p></li>
</ul>

<p>这有点类似于 QQ 空间的访问权限：<br/>
<img src="media/14954377078014/14954384555256.jpg" alt=""/></p>

<ul>
<li>这个 QQ 空间是属于我的，我相当于管理者（也就是“所有者”），我想怎么访问就怎么访问。</li>
<li>同时，我可以设置允许 QQ 好友访问，而这些 QQ 好友则类似于“用户组”。</li>
<li>当然，我可以允许所有人访问，这里的所有人则类似于“其他用户”。</li>
</ul>

<h3 id="toc_9">访问权限</h3>

<p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p>

<ul>
<li>读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</li>
<li>写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</li>
</ul>

<p>注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>

<h3 id="toc_10">示例说明</h3>

<p><img src="media/14954377078014/14954394260837.jpg" alt=""/><br/>
(图中  用户改为 用户组)</p>

<p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。</p>

<p>每一个用户都有它自身的读、写和执行权限。</p>

<ul>
<li>第一组权限控制访问自己的文件权限，即所有者权限。</li>
<li>第二组权限控制用户组访问其中一个用户的文件的权限。</li>
<li>第三组权限控制其他所有用户访问一个用户的文件的权限。</li>
</ul>

<p>这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目优化记录]]></title>
    <link href="http://www.citynight.cn/Blog/14919624884376.html"/>
    <updated>2017-04-12T10:01:28+08:00</updated>
    <id>http://www.citynight.cn/Blog/14919624884376.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">首页显示</h2>

<p>重点: 数据处理放在获取数据的时候,尽管这样数据不会实时更新,但是保证了数据显示的速度.<br/>
关于Cache, 目前使用数据库.关于异步访问要用 <code>safeAsync</code></p>

<pre><code>extension DispatchQueue {
    // This method will dispatch the `block` to self.
    // If `self` is the main queue, and current thread is main thread, the block
    // will be invoked immediately instead of being dispatched.
    func safeAsync(_ block: @escaping ()-&gt;()) {
        if self === DispatchQueue.main &amp;&amp; Thread.isMainThread {
            block()
        } else {
            async { block() }
        }
    }
}
</code></pre>

<h2 id="toc_1">Topbar 移除</h2>

<p>这个原有的导航对项目入侵太深,已经忍无可忍了&hellip;这周终于下决心移除它用原生的导航栏和自定义视图代替她..进展非常顺利.写了一天自定义控件,然后让大家各自把自己的控制过滤一遍.总耗时,我自己一天,其他同事不到1个小时.还是非常顺利的.用比较少的时间完成了项目中的毒瘤.</p>

<h2 id="toc_2">下拉刷新封装</h2>

<p>老版本使用的是<code>MJRefresh</code> 但是需要定制, 在老项目中我是通过继承完成的功能修改,这样做的原因是老项目是OC和Swift混编的,而且都是把第三方库源文件拖到项目中的方式进行的. 在重构的时候我把第三方库放到了公司的git上,然后更改源码.再打包成成库调用.</p>

<h2 id="toc_3">关于时间比较</h2>

<p>新项目中存在一个功能比如 <code>10:00:00</code> 到 <code>11:59:59</code> 算早市,需要判断当前时间是否是早市. 一种更方便的处理方式:</p>

<p>时间格式 <code>HH:mm:ss</code> 一共6位数字,我们可以去掉中间的<code>:</code>,这样时间就是一个整数了,然后三个整数之间进行比较比 先比小时再比分钟最后比秒数要方便很多.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 关于信号量]]></title>
    <link href="http://www.citynight.cn/Blog/14916349354566.html"/>
    <updated>2017-04-08T15:02:15+08:00</updated>
    <id>http://www.citynight.cn/Blog/14916349354566.html</id>
    <content type="html"><![CDATA[
<p>信号量的使用</p>

<p><img src="media/14916349354566/%E4%BF%A1%E5%8F%B7%E9%87%8F.gif" alt="信号量"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 读书笔记]]></title>
    <link href="http://www.citynight.cn/Blog/14907835920803.html"/>
    <updated>2017-03-29T18:33:12+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907835920803.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">单一职责原则(Single Responsibility Principe 简称SRP)</h2>

<blockquote>
<p>定义: 应该有且仅有一个原因引起类的变更.. </p>
</blockquote>

<h3 id="toc_1">对职责的定义,什么是类的职责,以及怎么划分类的职责.</h3>

<p>图书中 &lt;图1-1用户信息IUserInfo位图类图&gt; 中设计的有问题:<br/>
用户的属性和用户的行为没有分开,这是一个严重的错误.. 应该把用户的信息抽取成一个BO(Bussiness Object,业务对象),把行为抽取成一个Biz(Bussiness Logic,业务逻辑)</p>

<p>重新拆封成两个接口. IUserBO 负责用户的属性,简单的说就是收集和反馈用户的属性信息.IUserBiz负责用户的行为,完成用户信息的维护和变更.</p>

<h3 id="toc_2">好处</h3>

<ol>
<li>类的复杂性降低.实现什么职责都有清晰明确的定义了;</li>
<li>可读性提高.复杂性降低,当然可读性提高了;</li>
<li>可维护性提高.可读性提高,那当然更容易维护了;</li>
<li>变更引起的风险降低,变更时必不可少的.如果接口的单一职责做的好,一个接口的修改只对相应的实现类有影响,对其他的接口无影响,这对系统的扩展性和维护性都有非常大的帮助.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac zsh 使用命令打开sublime]]></title>
    <link href="http://www.citynight.cn/Blog/14907559721950.html"/>
    <updated>2017-03-29T10:52:52+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907559721950.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1/添加</h2>

<p><code>vim .zshrc</code></p>

<p>添加 <br/>
 <code>alias subl=&quot;open -a Sublime\ Text&quot;</code>（如果你是Sublime Text ）<br/>
  或者<br/>
<code>alias subl=&quot;open -a Sublime\ Text\ 2&quot;</code> （如果你是Sublime Text 2）</p>

<h2 id="toc_1">2/生效</h2>

<p><code>source ~/.zshrc</code></p>

<h2 id="toc_2">3/测试</h2>

<p>在命令行输入：<br/>
    <code>subl</code>     就可以打开sublime</p>

<p>输入：<br/>
    <code>subl test.txt</code> 就可以打开文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 最近遇到的问题(3.8)]]></title>
    <link href="http://www.citynight.cn/Blog/14888974267202.html"/>
    <updated>2017-03-07T22:37:06+08:00</updated>
    <id>http://www.citynight.cn/Blog/14888974267202.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">把函数名当参数传递不释放</h2>

<p>控制器A 有一个函数 func  有一个视图 View ,如果控制器A 把函数 func 传递给 View 那么 控制器不释放</p>

<h2 id="toc_1">*** Assertion failure in -[UITableView dequeueReusableCellWithIdentifier:forIndexPath:]</h2>

<p>产生原因: 同一个控制器,里面有一个代码添加的tableView,然后这个控制器又添加了一个xib视图,xib视图中有tableView,并且设置tableView的数据源和代理方法为filesowner,导致崩溃.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组传递]]></title>
    <link href="http://www.citynight.cn/Blog/14878335740172.html"/>
    <updated>2017-02-23T15:06:14+08:00</updated>
    <id>http://www.citynight.cn/Blog/14878335740172.html</id>
    <content type="html"><![CDATA[
<p>把A控制器中的数组 传递给 B  ,然后 B 再把数据传递给 C <br/>
这时如果 A中数组进行了修改,那么 C 中数据也会修改</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[synchronized(object)]]></title>
    <link href="http://www.citynight.cn/Blog/14877545165696.html"/>
    <updated>2017-02-22T17:08:36+08:00</updated>
    <id>http://www.citynight.cn/Blog/14877545165696.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>synchronized关键字代表这个方法加锁,相当于不管哪一个线 程A每次运行到这个法时,都要检查有没有其它正在用这个方法的线程B（或者C D等）,有的话要等正在使用这个方法的线程B（或者C D）运行完这个方法后再运行此线程A,没有的话,直接运行 它包括两种用法：synchronized 方法和 synchronized 块。</p>
</blockquote>

<h2 id="toc_0">1. synchronized 方法：</h2>

<p>通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如： <br/>
　　<code>public synchronized void accessVal(int newVal);</code><br/>
　　synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得 该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变 量的方法均被声明为 synchronized）。 <br/>
　　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 <br/>
　　synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。 <br/>
　　</p>

<h2 id="toc_1">2. synchronized 块：</h2>

<p>通过 synchronized关键字来声明synchronized 块。语法如下： </p>

<pre><code>　　synchronized(syncObject) { 
　　//允许访问控制的代码 
　　}
</code></pre>

<p>　　<br/>
　　synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高<br/>
　　</p>

<h2 id="toc_2">对synchronized(object)的一些理解</h2>

<p>　<br/>
<strong>一、</strong>当两个并发线程访问同一个对象object中的这个synchronized(this) 同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 </p>

<p><strong>二、</strong>当一个线程访问object的一个synchronized(this)同步代码块时，其 他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>

<p><strong>三、</strong>然而，当一个线程访问object的一个synchronized(this)同步代码块 时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。 </p>

<p><strong>四、</strong>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个 synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象 所有同步代码部分的访问都被暂时阻塞。 </p>

<p><strong>五、</strong>以上规则对其它对象锁同样适用 </p>

<p>原文: <a href="http://fei263.blog.163.com/blog/static/9279372420103752814/">http://fei263.blog.163.com/blog/static/9279372420103752814/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++Primer笔记 - 初识输入输出]]></title>
    <link href="http://www.citynight.cn/Blog/14866104685305.html"/>
    <updated>2017-02-09T11:21:08+08:00</updated>
    <id>http://www.citynight.cn/Blog/14866104685305.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>使用<code>iostream</code>库.<code>iostream</code>中包含两个基础类型<code>istream</code>和<code>ostream</code>,分别表示输入流和输出流</p>

<h2 id="toc_0">标准输入输出对象</h2>

<p>标准库中定义了4个IO对象.为了处理输入,我们使用了一个名为<code>cin</code>的<code>istream</code>类型的对象.这个对象也被称为<strong>标准输入</strong>.对于输出,我们使用一个名为<code>cout</code>的<code>ostream</code>类型的对象.此对象也被称为<strong>标准输出</strong>.标准库中还定义了其他两个<code>ostream</code>对象,名为<code>cerr</code>和<code>clog</code>.我们通常用<code>cerr</code>来输出警告和错误信心,因此它也被称为<strong>标准错误</strong>,而<code>clog</code>用来输出程序运行时的一般性信息.</p>
</blockquote>

<p>系统通常将程序所运行的窗口与这些对象关联起来.因此,当我们读取cin,数据将从程序正在运行的窗口读入,当我们像cout,cerr,clog写入数据的时候,将会写到同一个窗口.</p>

<h2 id="toc_1">Demo</h2>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(int argc, char *argv[])
{
    std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;
    int v1 = 0, v2 = 0;
    std::cin &gt;&gt; v1 &gt;&gt; v2;
    std::cout &lt;&lt; &quot;The sun of &quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2 &lt;&lt; &quot;is&quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++Primer笔记 - 如何获取 `main`的返回值]]></title>
    <link href="http://www.citynight.cn/Blog/14866089688413.html"/>
    <updated>2017-02-09T10:56:08+08:00</updated>
    <id>http://www.citynight.cn/Blog/14866089688413.html</id>
    <content type="html"><![CDATA[
<p>访问<code>main</code>的返回值的方法依赖于系统.在UNIX和Windows系统中,执行完一个程序后,都可以通过echo命令获得其返回值.<br/>
在UNIX中通过<code>echo $?</code><br/>
在Windows中通过<code>echo %ERRORLEVEL%</code></p>

<p>使用方式:<br/>
在terminal中, <code>vim prog1.cc</code> ,然后在vim下输入(<code>i</code>是插入键)</p>

<pre><code> int main()
 {
     return 0;
 }
</code></pre>

<p>退出编辑器(先按<code>esc</code>,然后<code>:wq</code>)<br/>
在terminal中运行</p>

<pre><code>cc prog1.cc
./a.out
echo $?
</code></pre>

<p>最终会得到我们的返回值<code>0</code></p>

<p><strong>1.1节练习</strong><br/>
1.2: main中返回-1.返回值-1通常被当做程序错误的标识.重新编译运行我再次获取错误值为255<br/>
<img src="media/14866089688413/14866102127236.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 春节前问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14861891967085.html"/>
    <updated>2017-02-04T14:19:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14861891967085.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p><code>#selector集中起来管理</code><br/>
参考<a href="http://weibo.com/3321824014/ErQJDdL4L?type=repost#_rnd1486189248963">微博</a>中第二点<br/>
<img src="media/14861891967085/14861893764185.jpg" alt=""/></p></li>
<li><p>关于Xib的使用问题<br/>
老生常谈的问题了,看个人喜好,不过尽量让其他人看懂,遵守xib规范.<br/>
备注:<br/>
    1. <a href="http://nshipster.cn/ibinspectable-ibdesignable/">IBInspectable / IBDesignable</a><br/>
    2. <a href="http://tips.producter.io/you-ya-di-zi-ding-yi-xibview/">优雅地自定义XibView</a></p></li>
<li><p>关于什么时候提取出方法<br/>
一个函数如果行数过长不便于阅读,可以按照步骤抽取出字方法<br/>
如果一个功能有2个以上地方用到需要抽取为一个方法</p></li>
<li><p>多种样式Cell如何配置</p></li>
</ol>

<p>撕逼未完&hellip;.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - Swift Talk: Networking]]></title>
    <link href="http://www.citynight.cn/Blog/14860911508877.html"/>
    <updated>2017-02-03T11:05:50+08:00</updated>
    <id>http://www.citynight.cn/Blog/14860911508877.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Swift Talk 学习笔记,<a href="https://talk.objc.io/episodes/S01E01-networking">https://talk.objc.io/episodes/S01E01-networking</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - Swift与JavaScript交互实战[转]]]></title>
    <link href="http://www.citynight.cn/Blog/14836656405837.html"/>
    <updated>2017-01-06T09:20:40+08:00</updated>
    <id>http://www.citynight.cn/Blog/14836656405837.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原地址:<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzA4NjA5Mw==&amp;mid=214070747&amp;idx=1&amp;sn=57b45fa293d0500365d9a0a4ff74a4e1#rd">Swift与JavaScript交互实战（Swift版）</a></p>
</blockquote>

<h2 id="toc_0">前言</h2>

<p>Swift与Js交互是常见的需求，可对于新手或者所谓的高手而言，其实并不是那么简单明了。这里只介绍iOS7.0后出来的JavaScriptCore framework。</p>

<h2 id="toc_1">关于JavaScriptCore</h2>

<p>本教程中所涉及到的几种类型：</p>

<ul>
<li><strong>JSContext</strong>, JSContext是代表JS的执行环境，通过-evaluateScript:方法就可以执行一JS代码</li>
<li><strong>JSValue</strong>, JSValue封装了JS与ObjC中的对应的类型，以及调用JS的API等</li>
<li><strong>JSExport</strong>, JSExport是一个协议，遵守此协议，就可以定义我们自己的协议，在协议中声明的API都会在JS中暴露出来，才能调用</li>
</ul>

<h2 id="toc_2">Swift与JS交互方式</h2>

<p>通过JSContext，我们有两种调用JS代码的方法：</p>

<ul>
<li>1、直接调用JS代码</li>
<li>2、在Swift中通过JSContext<strong>注入模型</strong>，然后调用模型的方法</li>
</ul>

<h3 id="toc_3">直接调用JS代码</h3>

<p>我们可以不通过模型来调用方法，也可以直接调用方法</p>

<pre><code>let context = JSContext() 
context.evaluateScript(“var num = 10”)
context.evaluateScript(“function square(value) { return value * 2}”)

// 直接调用
let squareValue = context.evaluateScript(“square(num)”)
print(squareValue)

// 通过下标来获取到JS方法。
let squareFunc = context.objectForKeyedSubscript(“square”)
print(squareFunc.callWithArguments([“10”]).toString());
</code></pre>

<p>这种方式是没有注入模型到JS中的。这种方式使用起来不太合适，通常在JS中有很多全局的函数，为了防止名字重名，使用模型的方式是最好不过了。通过我们协商好的模型名称，在JS中直接通过模型来调用我们在Swift中所定义的模型所公开的API。</p>

<h2 id="toc_4">注入模型的交互</h2>

<p>首先，我们需要先定义一个协议，而且这个协议必须要遵守JSExport协议。</p>

<p>All methods that should apply in Javascript,should be in the following protocol.注意，这里必须使用@objc，因为JavaScriptCore库是ObjectiveC版本的。如果不加@objc，则调用无效果。</p>

<pre><code>@objc protocol JavaScriptSwiftDelegate: JSExport { 
 func callSystemCamera();
 func showAlert(title: String, msg: String);
 func callWithDict(dict: [String: AnyObject]);
 func jsCallObjcAndObjcCallJsWithDict(dict: [String: AnyObject]);
}
</code></pre>

<p>接下来，我们还需要定义一个模型：</p>

<pre><code>@objc classJSObjCModel: NSObject, JavaScriptSwiftDelegate { 
  weak var controller: UIViewController? 
  weak var jsContext: JSContext? 

  func callSystemCamera() {   
    print(“js call objc method: callSystemCamera”);
    let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); 
    jsFunc?.callWithArguments([]);  
  }

  func showAlert(title: String, msg: String) {     
    dispatch_async(dispatch_get_main_queue()) { () -&gt; Void in   
      let alert = UIAlertController(title: title, message: msg, preferredStyle: .Alert)   
      alert.addAction(UIAlertAction(title: “ok”, style: .Default, handler: nil))      
      self.controller?.presentViewController(alert, animated: true, completion: nil)   
    }   
  }  

  // JS调用了我们的方法   
  func callWithDict(dict: [String : AnyObject]) {   
    print(“js call objc method: callWithDict, args: %@”, dict) 
  }

  // JS调用了我们的就去  
  func jsCallObjcAndObjcCallJsWithDict(dict: [String : AnyObject]) {     
    print(“js call objc method: jsCallObjcAndObjcCallJsWithDict, args: %@”, dict) 
    let jsParamFunc = self.jsContext?.objectForKeyedSubscript(“jsParamFunc”); 
    let dict = NSDictionary(dictionary: [“age”: 18, “height”: 168, “name”: “lili”])
    jsParamFunc?.callWithArguments([dict]) 
  }
}
</code></pre>

<p>接下来，我们在controller中在webview加载完成的代理中，给JS注入模型。</p>

<pre><code>// MARK: - UIWebViewDelegate
func webViewDidFinishLoad(webView: UIWebView) {
  let context = webView.valueForKeyPath(“documentView.webView.mainFrame.javaScriptContext”) as? JSContextlet 
  model = JSObjCModel() 
  model.controller = self
  model.jsContext = context
  self.jsContext = context

  // 这一步是将OCModel这个模型注入到JS中，在JS就
  // 可以通过OCModel调用我们公暴露的方法了。
  self.jsContext?.setObject(model, forKeyedSubscript: “OCModel”)
  self.jsContext?.exceptionHandler = { (context, exception) in 
     print(“exception @”, exception) 
  }
}
</code></pre>

<p>我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。<br/>
这样就可以获取到JS的context，然后为这个context注入我们的模型对象。<br/>
我们先写两个JS方法：</p>

<pre><code>var jsFunc = function() {
  alert(‘Objective-C call js to show alert’);
}

var jsParamFunc = function(argument) {
  document.getElementById(‘jsParamFuncSpan’).innerHTML
  = argument[‘name’];
}
</code></pre>

<p>这里我们定义了两个JS方法，一个是jsFunc，不带参数。<br/>
另一个是jsParamFunc，带一个参数。<br/>
接下来，我们在html中的body中添加以下代码：</p>

<p><code>Test how to use objective-c call js</code></p>

<p>现在就可以测试代码了。</p>

<p>当我们点击第一个按钮：Call ObjC system camera时，<br/>
通过OCModel.callSystemCamera()，就可以在HTML中通过JS调用OC的方法。<br/>
在Swift代码中，我们的callSystemCamera方法体中，添加了以下两行代码，就是获取HTML中所定义的JS就去jsFunc，然后调用它。</p>

<pre><code>let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); jsFunc?.callWithArguments([]);
</code></pre>

<p>这样就可以在JS调用Siwft方法时，也让Swift反馈给JS。<br/>
注意：这里是通过objectForKeyedSubscript方法来获取变量jsFunc。<br/>
方法也是变量。看看下面传字典参数：</p>

<pre><code>(void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary )params {
    NSLog(@”jsCallObjcAndObjcCallJsWithDict was called, params is %@”, params);
    // 调用JS的方法
    JSValue jsParamFunc = self.jsContext[@”jsParamFunc”];
    [jsParamFunc callWithArguments:@[@{@”age”: @10, @”name”: @”lili”, @”height”: @158}]];
}
</code></pre>

<p>获取我们在HTML中定义的jsParamFunc方法，然后调用它并传了一个字典作为参数。<br/>
好了，就讲这么多吧，如果想要Demo源代码，请到</p>

<ul>
<li>github：<strong><a href="https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS">https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS</a></strong></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C/C++ - 回调函数中比较大小为啥0不行?]]></title>
    <link href="http://www.citynight.cn/Blog/14834570124499.html"/>
    <updated>2017-01-03T23:23:32+08:00</updated>
    <id>http://www.citynight.cn/Blog/14834570124499.html</id>
    <content type="html"><![CDATA[
<p>在C语言中我们判断真假经常使用非0为真,0为假.但是在回调函数中我设置返回非0与0代表真假的时候出现了问题:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int callBackCompare(void * pa, void * pb)
{
    return *(int *)pa &lt; *(int *)pb ? 1 : -1;
}

void selectSort(int *p, int n, int (*pf)(int a, int b))
{
    for(int i = 0; i &lt; n-1; i++)
    {
        for(int j = i+1; j&lt;n; j++)
        {
            if(pf(p[i],p[j]))
            {
                p[i] = p[i]^p[j];
                p[j] = p[i]^p[j];
                p[i] = p[i]^p[j];
            }
        }
    }
}

int main(int argc, char *argv[])
{
    int arr[10] = {1,2,3,4,5,9,8,7,6,0};

    qsort(arr,sizeof(arr)/sizeof(int),sizeof(int),callBackCompare);

    for(int i = 0; i&lt;10; i++)
    {
        printf(&quot;%d\n&quot;,arr[i]);
    }
    return 0;
}

</code></pre>

<p>callBack中这样写能够得到结果</p>

<pre><code>9
8
7
6
5
4
3
2
1
0
</code></pre>

<p>但是如果我把callback函数中的-1换成0则返回错误结果</p>

<pre><code>0
2
3
4
5
9
8
7
6
1
</code></pre>

<p>这是为什么呢?</p>

<p>&mdash;17.1.3&mdash;-<br/>
搞懂了,0不能代表升降&hellip;</p>

<blockquote>
<p>假设是对 int 排序的话，如果是升序， 那么就是如果 a 比 b 大返回一个正值，小则负值，相等返回 0; 假设是对 int 排序的话，如果是降序， 那么就是如果 a 比 b 大返回一个负值，小则正值，相等返回 0;</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 上周总结(12.30)]]></title>
    <link href="http://www.citynight.cn/Blog/14830040423390.html"/>
    <updated>2016-12-29T17:34:02+08:00</updated>
    <id>http://www.citynight.cn/Blog/14830040423390.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">规范问题</h2>

<p>关于视图该不该把控件暴露出去?<br/>
通常情况下不能,原因:为了<del>部落</del>封闭性.</p>

<p>我的理解,每个视图都是一个盒子,如果有需要我可以给外面提供一个update接口来更改数据.视图中的点击事件可以通过<code>Target-Action</code>实现,当然闭包&amp;代理同样可以.非常符合<code>Cocoa</code>提倡的<code>MVC</code>模式</p>

<p><img src="media/14830040423390/14834530948549.jpg" alt=""/></p>

<p>关于视图中空间是否暴露出去,默认都是<code>private</code>,我认为苹果<code>Cocoa Touch</code>中<code>UIKit</code>部分控件设计的不是很好,举个🌰:<br/>
<code>UIButton</code>如果设置字体的大小,需要通过<code>titleLabel?.font</code>来设置.我认为这样是不好的,通过一个方法来设置font感觉更合适.</p>

<h2 id="toc_1">更Swift</h2>

<p>毕竟大部分同学都是刚接触Swift,整个项目感觉有点像翻译,还是<code>OC</code>的味道,关于这个问题讨论了两点,一个是面向协议编程,一个是函数式编程</p>

<h3 id="toc_2">面向协议编程</h3>

<p>问题:某一个视图是其他视图所需要的一部分,现在的做法是将共有的视图抽取出来,成为一个视图,然后其他视图包含这个视图.<br/>
面向协议:公共的子视图设置为一个协议,然后给一个默认的实现.像搭积木一样做视图的拼接.</p>

<p>参考资料:<a href="https://github.com/atConf/atswift-2016-resources">atswift-2016大会</a>中<code>李洁信_Pop in Swift</code>这个section可以参考.</p>

<h3 id="toc_3">函数式编程</h3>

<p>周欣对自己代码优化的时候发现的问题:<br/>
一开始的逻辑:</p>

<pre><code>class func fetchAllDish() -&gt; [Any] {
        var mutableBigCategorys = [Any]()
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        for bigCategory in bigCategorys {
            var bigCategory = bigCategory
            var mutableSubCategorys = [Any]()
            let subCategorys = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            for subCategory in subCategorys {
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                if dishes.count &gt; 0 {
                    subCategory[&quot;dishes&quot;] = dishes
                    mutableSubCategorys.append(subCategory)
                }
            }
            if mutableSubCategorys.count &gt; 0 {
                bigCategory[&quot;subCategorys&quot;] = mutableSubCategorys
                mutableBigCategorys.append(bigCategory)
            }
        }
        return mutableBigCategorys
    }
</code></pre>

<p>优化后的:</p>

<pre><code>class func fetchAllDish() -&gt; [Any] {
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        let results = bigCategorys.map { (bigCategory) -&gt; [String: Any] in
            var bigCategory = bigCategory
            let subCategory = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            let subResults = subCategory.map({ (subCategory) -&gt; [String: Any] in
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                subCategory[&quot;dishes&quot;] = dishes
                return subCategory
            }).filter({ $0.count &gt; 0 })
            bigCategory[&quot;subCategorys&quot;] = subResults
            return bigCategory
        }.filter({ $0.count &gt; 0 })
        return results
    }
</code></pre>

<p>通过<code>map</code>与<code>filter</code>的灵活使用,使代码逻辑更清晰,同时也减少了不必要的临时变量.</p>

<h3 id="toc_4">元组</h3>

<p>这个甲冠用的比较6..代码参见<code>NeoSubDishDetailView.swift</code>简单🌰:</p>

<pre><code>    func refreshInfo(data : (UIButton,DishTypeModel)){
        dishNameLabel.text = data.1.name
        moneyLabel.text = data.1.price
        numLabel.text = String(data.1.num)
        if data.1.num &lt;= 0{
            self.cutButton.isHidden = true
            self.numLabel.isHidden = true
        }else{
            self.cutButton.isHidden = false
            self.numLabel.isHidden = false
        }
    }

</code></pre>

<p>还有好多地方使用,这个文件可以好好观摩一下,很Swift&hellip;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点菜逻辑梳理]]></title>
    <link href="http://www.citynight.cn/Blog/14829045788456.html"/>
    <updated>2016-12-28T13:56:18+08:00</updated>
    <id>http://www.citynight.cn/Blog/14829045788456.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">同步逻辑(全量上传):</h2>

<p>原定: 切台\转台 全量上传<br/>
现在: 轮询即上传(每次轮询信息都走这个接口),切台/轮询同样走这个接口</p>

<h2 id="toc_1">关于延时</h2>

<p>12.27泽祥刚跟海底捞确定逻辑和备注一致即这道菜如果半份延时了再次点这道菜不论整份半份都是延时的.</p>

<h2 id="toc_2">整份半份显示(如果新需求的话,可能还需要改变正在和泽祥确定中)</h2>

<p>需求:点菜点锅界面菜品包含整份与半份 购物车界面整份与半份是分开的.</p>

<p>目前的做法: 购物车等地方如果调用<code>-(NSArray *)getLocalDishArray</code>这个操作会把数据拆分成整份半份给调用者.但是在点菜点锅页面,我会调用<code>configLocalDishArray</code> 这个操作会把整份半份整合成一个菜给调用者</p>

<h2 id="toc_3">关于估清</h2>

<p>原有逻辑就是根据数据库中获取菜品信息进行估清操作判断的,<strong>目前</strong>的逻辑是这样的,数据库返回字段和轮询回来的估清数据中只要有一个是估清就显示估清,显示需要调用<code>-(BOOL)judgeIsSellOutWithDish:(HTDishEntity *)dish</code></p>

<h2 id="toc_4">关于已点</h2>

<p>新加菜&amp;已下单数据只要一个地方有该菜品都显示已点<code>-(BOOL)haveOrderThisDish:(NSString *)dishid</code></p>

<h2 id="toc_5">匹配菜品中整份半份数量</h2>

<p><code>-(nonnull HTDishEntity *)configNumberOfDish:(nonnull HTDishEntity *)dish</code><br/>
会计算未下单数据中所有整份半份数量</p>

<h2 id="toc_6">延时倍增拆分等操作</h2>

<p>这里需要的菜品都是通过<code>getLocalDishArray</code>来获取否则有问题,详细逻辑大伟比较清楚</p>

<h2 id="toc_7">目前问题</h2>

<p>如果某一道菜设置延时了,将来这道菜每次进行数量的加减时都要同步到服务器,这个操作会不会导致网络请求发送比较频繁<br/>
点锅后,使用最新的同步接口延时太久.吃饭前同步的数据,中午午休后发现数据回来了&hellip;点菜的数据同步很快..这个是接口用错了还是后台接口需要调整?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全屏返回手势小技巧]]></title>
    <link href="http://www.citynight.cn/Blog/14823239811290.html"/>
    <updated>2016-12-21T20:39:41+08:00</updated>
    <id>http://www.citynight.cn/Blog/14823239811290.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这片文章可以和<a href="http://www.citynight.cn/Blog/14790381443417.html">Swift - KVC 和 运行时获取属性列表</a> 一起看,当然配上<a href="http://www.citynight.cn/Blog/14793034700265.html">隐藏tabBar的小技巧</a>就更好了😀</p>
</blockquote>

<h2 id="toc_0">第一种: 通过<code>runtime</code>与<code>KVC</code>配合完成</h2>

<p>在<code>UINavigationController</code>的<code>viewDidLoad</code>方法中:</p>

<pre><code>// 获取系统的手势
let gest = self.interactivePopGestureRecognizer!
// 禁用系统的手势
interactivePopGestureRecognizer?.isEnabled = false

// 通过KVC获取target 属性是通过runtime获取的,具体方法参见`Swift - KVC 和 运行时获取属性列表`
guard let targets = gest.value(forKey: &quot;_targets&quot;) as? [AnyObject] else {
    return
}
let target = targets[0].value(forKey: &quot;_target&quot;)

// 给视图添加点击事件
let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
view.addGestureRecognizer(pan)
</code></pre>

<h2 id="toc_1">第二种: 通过原有的代理完成</h2>

<p>直接上代码:</p>

<pre><code>class BaseNavigationController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()

        // 获取系统的手势的代理
        guard let target = interactivePopGestureRecognizer?.delegate else {
            return
        }
        
        // 禁用系统的手势
        interactivePopGestureRecognizer?.isEnabled = false
        
        // 给视图添加点击事件
        let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
        pan.delegate = self
        view.addGestureRecognizer(pan)
    }
}

extension BaseNavigationController:UIGestureRecognizerDelegate {
    func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool {
        // 当是跟控制器的时候不让返回,非跟控制器可以返回
        return viewControllers.count &gt; 1
    }
}

</code></pre>

<p>第一种也应该设置代理,不设置代理的话跟控制出现手势就会有bug</p>

<p>简单比较一下,第二种更简洁.不过应用了一个小技巧,看代码:</p>

<pre><code>    let pan = UIPanGestureRecognizer(target: self, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
    pan.delegate = self
    view.addGestureRecognizer(pan)
</code></pre>

<p>可见<code>target</code>&amp;<code>delegate</code>通常都是同一个对象,当让也可以是不同的,这里应用这个小技巧让代码变得更简洁.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库复习]]></title>
    <link href="http://www.citynight.cn/Blog/14817245458052.html"/>
    <updated>2016-12-14T22:09:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14817245458052.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>项目中部分功能打算使用数据库进行数据本地存储,所以复习了下数据库语句</p>
</blockquote>

<h2 id="toc_0">DDL</h2>

<pre><code>/*
删除表,如果存在表就删除表
*/
DROP TABLE IF EXISTS &#39;t_student&#39;;

/*
创建表
*/

CREATE TABLE IF NOT EXISTS &#39;t_student&#39; (
    &#39;id&#39; INTEGER NOT NULL PRIMARY KEY  AUTOINCREMENT,
    &#39;name&#39; TEXT,
    &#39;age&#39; INTEGER
);
</code></pre>

<h2 id="toc_1">DML</h2>

<pre><code>/*
插入数据
*/
/*
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz1&#39;, 18);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz2&#39;, 19);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz3&#39;, 21);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz4&#39;, 22);
*/

/*更新*/
-- UPDATE t_student SET age = 20 WHERE name = &#39;lxz1&#39;
UPDATE t_student SET name = &#39;xxx&#39; WHERE age &gt; 20


/*删除*/
DELETE FROM t_student WHERE name = &#39;xxx&#39;
</code></pre>

<h2 id="toc_2">DQL</h2>

<pre><code>/*查询语句*/
-- SELECT * FROM t_student;

/*查询特殊的字段*/
-- SELECT name,age FROM t_student;

/*通过条件来查询语句*/
-- SELECT name, age FROM t_student WHERE age &lt; 20;

/*模糊查询*/
-- SELECT name,age FROM t_student WHERE name LIKE &#39;%l%&#39;

/*多个条件的查询
AND 并且
OR 或者
*/
-- SELECT name, age FROM t_student WHERE name LIKE &#39;%l%&#39; AND age &lt; 20;

/*计算个数*/
-- SELECT count(*) FROM t_student WHERE age &lt; 20

/*排序
升序 ASC
降序 DESC
*/
-- SELECT * FROM t_student ORDER BY age DESC

-- SELECT * FROM t_student ORDER BY age ASC, name DESC;

/*起别名*/
-- 给表起别名
SELECT s.name, s.age FROM t_student AS s;
-- 给字段起别名
SELECT name AS myName, age AS myAge FROM t_student;


/*分页查询 limt
数字1的意思是前面跳过多少条数据
数字2的意思是本次查询多少条数据
SELECT * FROM t_student LIMIT 数字1,数字2

跳过0条数据查询5条数据
SELECT * FROM t_student LIMIT 5
*/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取崩溃信息]]></title>
    <link href="http://www.citynight.cn/Blog/14816416025061.html"/>
    <updated>2016-12-13T23:06:42+08:00</updated>
    <id>http://www.citynight.cn/Blog/14816416025061.html</id>
    <content type="html"><![CDATA[
<p>日志详细信息:</p>

<pre><code>static void exceptionHandler( NSException * exception )
{
    NSString *date = [NSString stringWithFormat:@&quot;崩溃日志-%@&quot;, [[NSDate date] description]];

    NSLog(DEBUG_CRASH, @&quot;%@ app crashed %@&quot;,date,exception.description);
     abort();
}
</code></pre>

<p>Appdelegate中调用:</p>

<pre><code>NSSetUncaughtExceptionHandler( &amp;exceptionHandler );
</code></pre>

<p>当然也可以在日志信息中记录堆栈信息:</p>

<pre><code>[exception callStackSymbols]
</code></pre>

]]></content>
  </entry>
  
</feed>
