<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2018-01-15T11:35:16+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftTips - 集中处理]]></title>
    <link href="http://www.citynight.cn/Blog/15158138774013.html"/>
    <updated>2018-01-13T11:24:37+08:00</updated>
    <id>http://www.citynight.cn/Blog/15158138774013.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">集中处理@objc</h2>

<p><img src="media/15158138774013/WX20180113-112401@2x.png" alt="WX20180113-112401@2x"/></p>

<h2 id="toc_1">模拟器不能执行的代码单独处理</h2>

<p><img src="media/15158138774013/15159872783257.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企业证书需要]]></title>
    <link href="http://www.citynight.cn/Blog/15132354899270.html"/>
    <updated>2017-12-14T15:11:29+08:00</updated>
    <id>http://www.citynight.cn/Blog/15132354899270.html</id>
    <content type="html"><![CDATA[
<ol>
<li>邓白氏码  不清楚公司是否申请过,如果没有申请过可能需要半个月左右时间(最快1周)</li>
<li>申请企业证书, 现在苹果对国内企业证书申请比较严格最快1周可能需要半个月甚至更久(美国快过圣诞节和元旦了)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Runloop 遇到的问题]]></title>
    <link href="http://www.citynight.cn/Blog/15101967456310.html"/>
    <updated>2017-11-09T11:05:45+08:00</updated>
    <id>http://www.citynight.cn/Blog/15101967456310.html</id>
    <content type="html"><![CDATA[
<p>首先: <code>swift</code> 与 <code>C</code> 兼容不如 <code>OC</code> <br/>
1. 生成<code>CFRunLoopObserverContext</code>比<code>OC</code>艰难好多&hellip;</p>

<pre><code>func addRunloopObserver() {
        autoreleasepool {
            guard let runloop = CFRunLoopGetCurrent() else {return}
            let unmanaged = Unmanaged.passRetained(self)
            let uptr = unmanaged.toOpaque()
            let vptr = UnsafeMutableRawPointer(uptr)
            var content = CFRunLoopObserverContext(version: 0, info: vptr, retain: nil, release: nil, copyDescription: nil)
            guard let obserber = CFRunLoopObserverCreate(kCFAllocatorDefault, CFRunLoopActivity.beforeWaiting.rawValue, true, Int.max - 999, observerCallbackFunc(), &amp;content) else {return}
            CFRunLoopAddObserver(runloop, obserber, CFRunLoopMode.defaultMode)
        }
    }
</code></pre>

<p>注意 content ,真是比OC复杂啊</p>

<ol>
<li>强转也变了&hellip;</li>
</ol>

<pre><code>func observerCallbackFunc() -&gt; CFRunLoopObserverCallBack {
        
        return {(observer, activity, context) -&gt; Void in
            guard let context = context else {
                return
            }
            let work = Unmanaged&lt;RunLoopWorker&gt;.fromOpaque(context).takeUnretainedValue()
            
            if work.tasks.count == 0 { return }
            var result = false
            while result == false &amp;&amp; work.tasks.count &gt; 0 {
                // 取出任务
                if let unit = work.tasks.first,unit.values.count &gt; 0 {
                    result = unit.values.first!()
                    work.tasks.removeFirst()
                }
            }
        }
    }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[collectionView自定义layout]]></title>
    <link href="http://www.citynight.cn/Blog/15096779127051.html"/>
    <updated>2017-11-03T10:58:32+08:00</updated>
    <id>http://www.citynight.cn/Blog/15096779127051.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天,YouTube推荐了一个自定义layout的视频( Custom Collection View Layouts in iOS),看了一下挺简单明了的,而且基本的操作都包含了. <br/>
<strong>视频地址:</strong> <a href="https://www.youtube.com/watch?v=DIxyCh55SqQ">Pinterest Basic Layout - Custom Collection View Layouts in iOS - raywenderlich.com</a><br/>
<strong>github地址:</strong> <a href="https://github.com/AZCoder2/Pinterest">Pinterest</a></p>
</blockquote>

<p>核心代码:</p>

<pre><code>//
//  PinterestLayout.swift
//  Pinterest
//
//  Created by Tom Ranalli on 12/25/16.
//  Copyright © 2016 Razeware LLC. All rights reserved.
//

import UIKit

// MARK: - Protocols
protocol PinterestLayoutDelegate {
  
  // Request height of photo
  func collectionView(_ collectionView:UICollectionView, heightForPhotoAtIndexPath indexPath:NSIndexPath,
                      withWidth:CGFloat) -&gt; CGFloat
  
  // Request annotation for photo
  func collectionView(_ collectionView: UICollectionView,
                      heightForAnnotationAtIndexPath indexPath: NSIndexPath, withWidth width: CGFloat) -&gt; CGFloat
}

class PinterestLayoutAttributes: UICollectionViewLayoutAttributes {
  
  // This declares the photoHeight property that the cell will use to resize its image view
  var photoHeight: CGFloat = 0.0
  
  /* This overrides copy(_with:)
   
     Subclasses of UICollectionViewLayoutAttributes need to conform to the NSCopying protocol 
     because the attribute’s objects can be copied internally. You override this method to 
     guarantee that the photoHeight property is set when the object is copied.
  */
  
  override func copy(with zone: NSZone? = nil) -&gt; Any {
    let copy = super.copy(with: zone) as! PinterestLayoutAttributes
    copy.photoHeight = photoHeight
    return copy
  }
  
  /* This overrides isEqual(_:), and it’s mandatory as well.
 
     The collection view determines whether the attributes have changed by comparing the old 
     and new attribute objects using isEqual(_:). You must implement it to compare the custom
     properties of your subclass. The code compares the photoHeight of both instances, and
     if they are equal, calls super to determine if the inherited attributes are the same;
     if the photo heights are different, it returns false
  */

  override func isEqual(_ object: Any?) -&gt; Bool {
    if let attributes = object as? PinterestLayoutAttributes {
      if( attributes.photoHeight == photoHeight  ) {
        return super.isEqual(object)
      }
    }
    return false
  }
}

// MARK: - Class definition
class PinterestLayout: UICollectionViewLayout {
  
  // MARK: - Properties
  
  // Keep reference to the delegate
  var delegate: PinterestLayoutDelegate!
  
  // Configure number of columns and cell padding
  var numberOfColumns = 2
  var cellPadding: CGFloat = 6.0
  
  // This is an array to cache the calculated attributes. 
  
  /* When you call prepareLayout(), you’ll calculate the attributes for all items and add them to the cache. When the collection view later requests the layout attributes, you can be efficient and query the cache instead of recalculating them every time
  */
  
  private var cache = [PinterestLayoutAttributes]()
  
  // This declares two properties to store the content size.
  // contentHeight is incremented as photos are added
  private var contentHeight: CGFloat  = 0.0
  
  // contentWidth is calculated based on the collection view width and its content inset.
  private var contentWidth: CGFloat {
    let insets = collectionView!.contentInset
    return collectionView!.bounds.width - (insets.left + insets.right)
  }
  
  // Variable overrides
  
  /* This overrides collectionViewContentSize variable of the abstract parent class, and returns the size of the collection view’s contents. To do this, you use both contentWidth and contentHeight calculated in the previous steps.
  */
 
  override var collectionViewContentSize: CGSize {
    return CGSize(width: contentWidth, height: contentHeight)
  }
  
  /* This overrides layoutAttributesClass variable to tell the collection view to use PinterestLayoutAttributes whenever it creates layout attributes objects.
  */
  
  override class var layoutAttributesClass: AnyClass {
    return PinterestLayoutAttributes.self
  }
  
  // MARK: - Overrides
  
  override func prepare() {
    
    // Only calculate if cache is empty
    if cache.isEmpty {
      
      /*  This declares and fills the xOffset array with the x-coordinate for every column based on the column widths.
      */
      let columnWidth = contentWidth / CGFloat(numberOfColumns)
      
      var xOffset = [CGFloat]()
      
      for column in 0 ..&lt; numberOfColumns {
        xOffset.append(CGFloat(column) * columnWidth )
      }
      
      /*  The yOffset array tracks the y-position for every column. You initialize each value in yOffset to 0, since this is the offset of the first item in each column.
      */
      var column = 0
      var yOffset = [CGFloat](repeating: 0, count: numberOfColumns)
      
      // This loops through all the items in the first section, as this particular 
      // layout has only one section
      for item in 0 ..&lt; collectionView!.numberOfItems(inSection: 0) {
        
        let indexPath = NSIndexPath(item: item, section: 0)
        
        // This is where you perform the frame calculation
        // Width is the previously calculated cellWidth, with the padding between cells removed
        let width = columnWidth - cellPadding * 2
        
        // You ask the delegate for the height of the image
        let photoHeight = delegate.collectionView(collectionView!,
                                                  heightForPhotoAtIndexPath: indexPath,
                                                  withWidth:width)

        // You ask the delegate for the height of the annotation
        let annotationHeight = delegate.collectionView(collectionView!,
                                    heightForAnnotationAtIndexPath: indexPath,
                                    withWidth: width)
        
        // Calculate the frame height based on those heights and the predefined cellPadding 
        // for the top and bottom
        let height = cellPadding +  photoHeight + annotationHeight + cellPadding
        
        // Combine this with the x and y offsets of the current column to create the
        // insetFrame used by the attribute
        let frame = CGRect(x: xOffset[column], y: yOffset[column], width: columnWidth, height: height)
        let insetFrame = frame.insetBy(dx: cellPadding, dy: cellPadding)
        
        // This creates an instance of PinterestLayoutAttributes
        let attributes = PinterestLayoutAttributes(forCellWith: indexPath as IndexPath)
        attributes.photoHeight = photoHeight
        
        // Sets its frame using insetFrame
        attributes.frame = insetFrame
        
        // Append the attributes to cache
        cache.append(attributes)
        
        // This expands contentHeight to account for the frame of the newly calculated item
        contentHeight = max(contentHeight, frame.maxY)
        
        // It then advances the yOffset for the current column based on the frame
        yOffset[column] = yOffset[column] + height
        
        // Finally, it advances the column so that the next item will be placed in the next column.
        if column &gt;= numberOfColumns - 1 {
          column = 0
        } else {
          column = column + 1
        }
        
      }
    }
  }
  
  override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
    
    var layoutAttributes = [UICollectionViewLayoutAttributes]()
    
    //  Iterate through the attributes in cache and check if their frames intersect with rect
    for attributes in cache {
      if attributes.frame.intersects(rect) {
        layoutAttributes.append(attributes) // Add in any attributes for display
      }
    }
    return layoutAttributes
  }

}

</code></pre>

<p>比较有意思的一个计算高度方式:</p>

<pre><code>  // This provides the height of the photos
  
  /* It uses AVMakeRectWithAspectRatioInsideRect() from AVFoundation to calculate a height that retains the photo’s aspect ratio, restricted to the cell’s width.
   */
  
  func collectionView(_ collectionView:UICollectionView,
                      heightForPhotoAtIndexPath indexPath: NSIndexPath,
                      withWidth width: CGFloat) -&gt; CGFloat {
    
    let photo = photos[indexPath.item]
    let boundingRect =  CGRect(x: 0, y: 0, width: width, height: CGFloat(MAXFLOAT))
    let rect  = AVMakeRect(aspectRatio: photo.image.size, insideRect: boundingRect)
    
    return rect.size.height
  }
</code></pre>

<p>图片解压:</p>

<pre><code>extension UIImage {
  
  var decompressedImage: UIImage {
    UIGraphicsBeginImageContextWithOptions(size, true, 0)
    draw(at: CGPoint.zero)
    let decompressedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decompressedImage!
  }
  
}
</code></pre>

<p>一个从前没有用过的Api:</p>

<pre><code>  /* 
   This code calls the super implementation to make sure that the standard attributes are applied. Then, it casts the attributes object into an instance of PinterestLayoutAttributes to obtain the photo height and then changes the image view height by setting the imageViewHeightLayoutConstraint constant value.
  */
  
  override func apply(_ layoutAttributes: UICollectionViewLayoutAttributes) {
    super.apply(layoutAttributes)
    
    if let attributes = layoutAttributes as? PinterestLayoutAttributes {
      imageViewHeightLayoutConstraint.constant = attributes.photoHeight
    }
  }
</code></pre>

<p>===========<mark>完</mark>=========</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]浅析 iOS 应用开发中的断点续传]]></title>
    <link href="http://www.citynight.cn/Blog/15060704391596.html"/>
    <updated>2017-09-22T16:53:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/15060704391596.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原贴地址<a href="https://www.ibm.com/developerworks/cn/mobile/mo-cn-breakpoint/index.html">IBM developerWorks</a></p>
</blockquote>

<h2 id="toc_0">断点续传概述</h2>

<p>断点续传就是从文件上次中断的地方开始重新下载或上传数据，而不是从文件开头。（本文的断点续传仅涉及下载，上传不在讨论之内）当下载大文件的时候，如果没有实现断点续传功能，那么每次出现异常或者用户主动的暂停，都会去重头下载，这样很浪费时间。所以项目中要实现大文件下载，断点续传功能就必不可少了。当然，断点续传有一种特殊的情况，就是 iOS 应用被用户 kill 掉或者应用 crash，要实现应用重启之后的断点续传。这种特殊情况是本文要解决的问题。</p>

<h2 id="toc_1">断点续传原理</h2>

<p>要实现断点续传 , 服务器必须支持。目前最常见的是两种方式：FTP 和 HTTP。下面来简单介绍 HTTP 断点续传的原理。</p>

<h3 id="toc_2">HTTP</h3>

<p>通过 HTTP，可以非常方便的实现断点续传。断点续传主要依赖于 HTTP 头部定义的 Range 来完成。具体 Range 的说明参见 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>中 14.35.2 节，在请求某范围内的资源时，可以更有效地对大资源发出请求或从传输错误中恢复下载。有了 Range，应用可以通过 HTTP 请求曾经获取失败的资源的某一个返回或者是部分，来恢复下载该资源。当然并不是所有的服务器都支持 Range，但大多数服务器是可以的。Range 是以字节计算的，请求的时候不必给出结尾字节数，因为请求方并不一定知道资源的大小。Range 的定义如图 1 所示：</p>

<h5 id="toc_3">图 1. HTTP-Range</h5>

<p><img src="media/15060704391596/image001.png" alt="HTTP-Range"/></p>

<p>图 2 展示了 HTTP request 的头部信息：</p>

<h5 id="toc_4">图 2. HTTP request 例子</h5>

<p><img src="media/15060704391596/image002.png" alt="HTTP request 例子"/></p>

<p>在上面的例子中的“Range: bytes=1208765-”表示请求资源开头 1208765 字节之后的部分。</p>

<p>图 3 展示了 HTTP response 的头部信息：</p>

<h5 id="toc_5">图 3. HTTP response 例子</h5>

<p><img src="media/15060704391596/image003.png" alt="HTTP response 例子"/></p>

<p>上面例子中的”Accept-Ranges: bytes”表示服务器端接受请求资源的某一个范围，并允许对指定资源进行字节类型访问。”Content-Range: bytes 1208765-20489997/20489998”说明了返回提供了请求资源所在的原始实体内的位置，还给出了整个资源的长度。这里需要注意的是 HTTP return code 是 206 而不是 200。</p>

<h2 id="toc_6">断点续传分析 -AFHTTPRequestOperation</h2>

<p>了解了断点续传的原理之后，我们就可以动手来实现 iOS 应用中的断点续传了。由于笔者项目的资源都是部署在 HTTP 服务器上 , 所以断点续传功能也是基于 HTTP 实现的。首先来看下第三方网络框架 AFNetworking 中提供的实现。清单 1 示例代码是用来实现断点续传部分的代码：</p>

<h5 id="toc_7">清单 1. 使用 AFHTTPRequestOperation 实现断点续传的代码</h5>

<pre><code>// 1 指定下载文件地址 URLString 
// 2 获取保存的文件路径 filePath 
// 3 创建 NSURLRequest 
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:URLString]]; 
unsigned long long downloadedBytes = 0; 
 
if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) { 
// 3.1 若之前下载过 , 则在 HTTP 请求头部加入 Range 
   // 获取已下载文件的 size 
   downloadedBytes = [self fileSizeForPath:filePath]; 
        
   // 验证是否下载过文件
   if (downloadedBytes &gt; 0) { 
       // 若下载过 , 断点续传的时候修改 HTTP 头部部分的 Range 
       NSMutableURLRequest *mutableURLRequest = [request mutableCopy]; 
       NSString *requestRange = 
       [NSString stringWithFormat:@&quot;bytes=%llu-&quot;, downloadedBytes]; 
       [mutableURLRequest setValue:requestRange forHTTPHeaderField:@&quot;Range&quot;]; 
       request = mutableURLRequest; 
   } 
} 
 
// 4 创建 AFHTTPRequestOperation 
AFHTTPRequestOperation *operation 
 = [[AFHTTPRequestOperation alloc] initWithRequest:request]; 
 
// 5 设置操作输出流 , 保存在第 2 步的文件中
operation.outputStream = [NSOutputStream 
outputStreamToFileAtPath:filePath append:YES]; 
 
// 6 设置下载进度处理 block 
[operation setDownloadProgressBlock:^(NSUInteger bytesRead, 
long long totalBytesRead, long long totalBytesExpectedToRead) { 
// bytesRead 当前读取的字节数
// totalBytesRead 读取的总字节数 , 包含断点续传之前的
// totalBytesExpectedToRead 文件总大小
}]; 
 
// 7 设置 success 和 failure 处理 block 
[operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation 
*operation, id responseObject) { 
 
} failure:^(AFHTTPRequestOperation *operation, NSError *error) { 
 
}]; 
 
// 8 启动 operation 
[operation start];
</code></pre>

<p>使用以上代码 , 断点续传功能就实现了，应用重新启动或者出现异常情况下 , 都可以基于已经下载的部分开始继续下载。关键的地方就是把已经下载的数据持久化。接下来简单看下 AFHTTPRequestOperation 是怎么实现的。通过查看源码 , 我们发现 AFHTTPRequestOperation 继承自 AFURLConnectionOperation , 而 AFURLConnectionOperation 实现了 NSURLConnectionDataDelegate 协议。处理流程如图 4 所示：</p>

<h5 id="toc_8">图 4. AFURLHTTPrequestOperation 处理流程</h5>

<p><img src="media/15060704391596/image004.png" alt="AFURLHTTPrequestOperation 处理流程"/></p>

<p>这里 AFNetworking 为什么采取子线程调异步接口的方式 , 是因为直接在主线程调用异步接口 , 会有一个 Runloop 的问题。当主线程调用 [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES] 时 , 请求发出之后的监听任务会加入到主线程的 Runloop 中 ,RunloopMode 默认为 NSDefaultRunLoopMode, 这个表示只有当前线程的 Runloop 处理 NSDefaultRunLoopMode 时，这个任务才会被执行。而当用户在滚动 TableView 和 ScrollView 的时候，主线程的 Runloop 处于 NSEventTrackingRunLoop 模式下，就不会执行 NSDefaultRunLoopMode 的任务。</p>

<p>另外由于采取子线程调用接口的方式 , 所以这边的 DownloadProgressBlock,success 和 failure Block 都需要回到主线程来处理。</p>

<h2 id="toc_9">断点续传实战</h2>

<p>了解了原理和 AFHTTPRequestOperation 的例子之后 , 来看下实现断点续传的三种方式：</p>

<h3 id="toc_10">NSURLConnection</h3>

<p>基于 NSURLConnection 实现断点续传 , 关键是满足 NSURLConnectionDataDelegate 协议，主要实现了如下三个方法：</p>

<h5 id="toc_11">清单 2. NSURLConnection 的实现</h5>

<pre><code>// SWIFT 
// 请求失败处理
func connection(connection: NSURLConnection, 
didFailWithError error: NSError) { 
   self.failureHandler(error: error) 
} 
 
// 接收到服务器响应是调用
func connection(connection: NSURLConnection, 
 didReceiveResponse response: NSURLResponse) { 
   if self.totalLength != 0 { 
       return 
   } 
 
   self.writeHandle = NSFileHandle(forWritingAtPath: 
   FileManager.instance.cacheFilePath(self.fileName!)) 
 
   self.totalLength = response.expectedContentLength + self.currentLength 
} 
 
// 当服务器返回实体数据是调用
func connection(connection: NSURLConnection, didReceiveData data: NSData) { 
   let length = data.length 
    
   // move to the end of file 
   self.writeHandle.seekToEndOfFile() 
    
   // write data to sanbox 
   self.writeHandle.writeData(data) 
    
   // calculate data length 
   self.currentLength = self.currentLength + length 
    
   print(&quot;currentLength\(self.currentLength)-totalLength\(self.totalLength)&quot;) 
    
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: length, totalBytes: 
       self.currentLength, totalBytesExpected: self.totalLength) 
   } 
} 
 
// 下载完毕后调用
func connectionDidFinishLoading(connection: NSURLConnection) { 
   self.currentLength = 0 
   self.totalLength = 0 
 
   //close write handle 
   self.writeHandle.closeFile() 
   self.writeHandle = nil 
 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
        
   do { 
       try FileManager.instance.moveItemAtPath(cacheFilePath, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
    
   self.successHandler(responseObject:fileName!) 
}
</code></pre>

<p>如图 5 所示 , 说明了 NSURLConnection 的一般处理流程。（代码详见下载包）</p>

<h5 id="toc_12">图 5. NSURLConnection 流程</h5>

<p><img src="media/15060704391596/image005.png" alt="NSURLConnection 流程"/></p>

<p>根据图 5 的一般流程，在 didReceiveResponse 中初始化 fileHandler, 在 didReceiveData 中 , 将接收到的数据持久化的文件中 , 在 connectionDidFinishLoading 中，清空数据和关闭 fileHandler，并将文件保存到 Document 目录下。所以当请求出现异常或应用被用户杀掉，都可以通过持久化的中间文件来断点续传。初始化 NSURLConnection 的时候要注意设置 scheduleInRunLoop 为 NSRunLoopCommonModes，不然就会出现进度条 UI 无法更新的现象。实现效果如图 6 所示：</p>

<h5 id="toc_13">图 6. NSURLConnection 演示</h5>

<p><img src="media/15060704391596/image006.gif" alt="NSURLConnection 演示"/></p>

<h3 id="toc_14">NSURLSessionDataTask</h3>

<p>苹果在 iOS7 开始，推出了一个新的类 NSURLSession, 它具备了 NSURLConnection 所具备的方法，并且更强大。由于通过 NSURLConnection 从 2015 年开始被弃用了，所以读者推荐基于 NSURLSession 去实现续传。NSURLConnection 和 NSURLSession delegate 方法的映射关系 , 如图 7 所示。所以关键是要满足 NSURLSessionDataDelegate 和 NSURLsessionTaskDelegate。</p>

<h5 id="toc_15">图 7. 协议之间映射关系</h5>

<p><img src="media/15060704391596/image007.png" alt="协议之间映射关系"/></p>

<p>代码如清单 3 所示 , 基本和 NSURLConnection 实现的一样。</p>

<h5 id="toc_16">清单 3. NSURLSessionDataTask 的实现</h5>

<pre><code>// SWIFT 
// 接收数据
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
idReceiveData data: NSData) { 
   //. . . 
} 
// 接收服务器响应
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
didReceiveResponse response: NSURLResponse, completionHandler: 
 (NSURLSessionResponseDisposition) -&gt; Void) { 
   // . . . 
   completionHandler(.Allow) 
} 
 
// 请求完成
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
 didCompleteWithError error: NSError?) { 
   if error == nil { 
       // . . . 
       self.successHandler(responseObject:self.fileName!) 
   } else { 
       self.failureHandler(error:error!) 
   } 
}
</code></pre>

<p>区别在与 didComleteWithError, 它将 NSURLConnection 中的 connection:didFailWithError:</p>

<p>和 connectionDidFinishLoading: 整合到了一起 , 所以这边要根据 error 区分执行成功的 Block 和失败的 Block。实现效果如图 8 所示：</p>

<h5 id="toc_17">图 8. NSURLSessionDataTask 演示</h5>

<p><img src="media/15060704391596/image008.gif" alt="NSURLSessionDataTask 演示"/></p>

<h3 id="toc_18">NSURLSessionDownTask</h3>

<p>最后来看下 NSURLSession 中用来下载的类 NSURLSessionDownloadTask，对应的协议是 NSURLSessionDownloadDelegate，如图 9 所示：</p>

<h5 id="toc_19">图 9. NSURLSessionDownloadDelegate 协议</h5>

<p><img src="media/15060704391596/image009.png" alt="NSURLSessionDownloadDelegate 协议"/></p>

<p>其中在退出 didFinishDownloadingToURL 后，会自动删除 temp 目录下对应的文件。所以有关文件操作必须要在这个方法里面处理。之前笔者曾想找到这个 tmp 文件 , 基于这个文件做断点续传 , 无奈一直找不到这个文件的路径。等以后 SWIFT 公布 NSURLSession 的源码之后，兴许会有方法找到。基于 NSURLSessionDownloadTask 来实现的话 , 需要在 cancelByProducingResumeData 中保存已经下载的数据。进度通知就非常简单了，直接在 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite: 实现即可。代码如清单 4 所示：</p>

<h5 id="toc_20">清单 4. NSURLSessionDownloadTask 的实现</h5>

<pre><code>//SWIFT 
 
//UI 触发 pause 
func pause(){ 
   self.downloadTask?.cancelByProducingResumeData({data -&gt; Void in 
       if data != nil { 
data!.writeToFile(FileManager.instance.cacheFilePath(self.fileName!), 
atomically: false) 
} 
       }) 
   self.downloadTask = nil 
} 
 
// MARK: - NSURLSessionDownloadDelegate 
func URLSession(session: NSURLSession, downloadTask: 
NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, 
totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) { 
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: Int(bytesWritten), 
        totalBytes: totalBytesWritten, totalBytesExpected: totalBytesExpectedToWrite) 
   } 
} 
 
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
didCompleteWithError error: NSError?) { 
   if error != nil {//real error 
       self.failureHandler(error:error!) 
   } 
} 
 
func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, 
 didFinishDownloadingToURL location: NSURL) { 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
   do { 
       if FileManager.instance.fileExistsAtPath(cacheFilePath){ 
           try FileManager.instance.removeItemAtPath(cacheFilePath) 
       } 
       try FileManager.instance.moveItemAtPath(location.path!, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
   self.successHandler(responseObject:documenFilePath) 
}
</code></pre>

<p>实现效果如图 10 所示：</p>

<h5 id="toc_21">图 10. NSURLSessionDownloadTask 演示</h5>

<p><img src="media/15060704391596/image010.gif" alt="NSURLSessionDownloadTask 演示"/></p>

<h2 id="toc_22">总结</h2>

<p>本文从断点续传概述开始，介绍了断点续传的应用背景，通过原理的描述，相信读者对断点续传有了基本的认识和理解。接着笔者介绍了通过 AFHTTPRequestOpeartion 实现的代码，并对 AFHTTPRequestOpeartion 做了简单的分析。最后笔者结合的实际需求，基于 NSURLConnection, NSURLSeesionDataTask 和 NSURLSessionDownloadtask。其实，下载的实现远不止这些内容，本文只介绍了简单的使用。希望在进一步的学习和应用中能继续与大家分享。</p>

<h4 id="toc_23">相关主题</h4>

<ul>
<li>参考 <a href="https://www.w3.org/Protocols/rfc959/4_FileTransfer.html">RFC959</a>，了解 FTP 协议文本的说明。</li>
<li>参考 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>，了解 HTTP 的说明。</li>
<li>参考 <a href="https://github.com/AFNetworking/AFNetworking/blob/2.x/AFNetworking/AFHTTPRequestOperation.m">AFHTTPRequestOperation</a>, 了解源码。</li>
<li>参考 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091">iOSDeveloperLibrary</a>，了解 Apple 官方文档对 NSURLConnection, NSURLSeesionDownloadTask 和 NSURLSeesionDataTask 的说明。</li>
<li>访问 developerWorks <a href="http://www.ibm.com/developerworks/cn/mobile/">Mobile 专区</a>，了解关于信息管理的更多信息，获取技术文档、how-to 文章、培训、下载、产品信息以及其他资源。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优化iPad 2 总结]]></title>
    <link href="http://www.citynight.cn/Blog/15058021769287.html"/>
    <updated>2017-09-19T14:22:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/15058021769287.html</id>
    <content type="html"><![CDATA[
<p>实施反馈项目在<code>iPad 2</code>上比较卡顿,所以要对项目进行优化.</p>

<h2 id="toc_0">优化集中点为collectionView</h2>

<p>项目有两种显示效果,一种是图片模式,一种是纯文字模式. 纯文字模式滑动起来还不错,图片模式就比较卡了.经分析,项目做了部分修改,使滑动效果比较顺畅.</p>

<ol>
<li>栅格化: 目的是离屏渲染,不过还是卡顿</li>
</ol>

<pre><code>    self.layer.shouldRasterize = true
    self.layer.rasterizationScale = UIScreen.main.scale
    self.layer.drawsAsynchronously = true
</code></pre>

<p>2.Color Blended Layers 处理<br/>
<img src="media/15058021769287/15058027400968.jpg" alt=""/><br/>
发现部分UILabel存在问题,解决方案:<br/>
<img src="media/15058021769287/15058028256147.jpg" alt=""/></p>

<p>添加 <code>label.layer.masksToBounds = true</code>,效果还是不行.</p>

<ol>
<li>上面优化后效果不是很明显,最后采取了<strong>以空间换时间</strong>的方式优化图片列表页
提前用<code>Kingfisher</code>下载图片(这个过程原先就有)下载过图片也做了不再下载的处理,由于图片过多导致不会有太多列表页的图片缓存中内存中. 针对这个问题,我采用了每次进入app就把列表页的图片使用<code>NSCache&lt;NSString, UIImage&gt;</code>缓存起来,效果很明显.</li>
</ol>

<h2 id="toc_1">目前还存在问题</h2>

<p>下载图片失败率还是很高的,我设置的超时时间为60s <code>downloader.downloadTimeout = 60</code> 但是还是有很多图片下载超时,导致首次加载的时候需要下载图片滑动卡顿.<br/>
由于<code>NSCache</code>的特殊性,不能保证图片一直在内存中,正在考虑是否替换成Dictionary,然后自己处理内存警告.这个稍后验证下.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指针]]></title>
    <link href="http://www.citynight.cn/Blog/15052686192490.html"/>
    <updated>2017-09-13T10:10:19+08:00</updated>
    <id>http://www.citynight.cn/Blog/15052686192490.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. 指针是一种数据类型</h2>

<ol>
<li>指针也是一种变量,占有内存空间,用来保存内存地址  指针的大小&ndash;&gt; 32位: 4  64位: 8</li>
<li><p><code>*p</code> 操作内存</p>

<pre><code>在指针声明时,`*`号表示所声明的变量为指针
在指针使用时,`*`号表示**操作**指针所指向的内存空间中的值
`*p`相当于通过地址(p变量的值)找到一块内存,然后操作内存
`*p`放在等号左边赋值(给内存赋值)
`*p`放在等号右边取值(从内存获取值)
</code></pre></li>
<li><p>指针变量和它指向的内存块是两个不同的概念</p>

<pre><code>含义1: 给p赋值 p = 0x1111; 只会改变指针变量值,不会改变所指的内容; p = p+1
含义2: 给`*p`赋值 *p = &#39;a&#39;;不会改变指针变量的值,只会改变所指的内存块的值
保证所指向的内存空间能修改()
*就像一把钥匙,通过一个地址(&amp;a),去修改a变量的标示的内存空间
</code></pre></li>
<li><p>指针是一种数据类型,是指它指向的内存空间的数据类型</p>

<pre><code>指针步长(p++),根据所指内存空间的数据类型类确定
p++ = ---&gt; p+sizeof(a)
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3D Touch]]></title>
    <link href="http://www.citynight.cn/Blog/15038471972999.html"/>
    <updated>2017-08-27T23:19:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/15038471972999.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/6705/3d-touch/22813/3d-touch-with-swift">3D Touch with Swift</a></h2>

<p>3D touch has been introduced with iPhone 6s Plus. There are two behaviors added with this new interface layer: Peek and Pop.</p>

<p><strong>Peek and Pop in a nutshell</strong></p>

<p>Peek - Press hard</p>

<p>Pop - Press really hard</p>

<p><strong>Checking for 3D support</strong></p>

<p>You should check if the device has a 3D touch support. You can do this by checking the value of <em>forceTouchCapability</em> property of a <em>UITraitCollection</em> object. UITraitCollection describes the iOS interface environment for your app.</p>

<pre><code>if (traitCollection.forceTouchCapability == .Available) {    
    registerForPreviewingWithDelegate(self, sourceView: view)
}
</code></pre>

<p><strong>Implementing the delegate</strong></p>

<p>You need to implement the two methods of <em>UIViewControllerPreviewingDelegate</em> in your class. One of the methods is for <em>peek</em> and the other one is for <em>pop</em> behavior.</p>

<p>The method to be implemented for the <em>peek</em> is <em>previewingContext</em>.</p>

<pre><code>func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? {

    guard let indexPath = self.tableView.indexPathForRowAtPoint(location), cell = self.tableView.cellForRowAtIndexPath(indexPath) as? &lt;YourTableViewCell&gt; else {
        return nil
    }

    guard let datailVC = storyboard?.instantiateViewControllerWithIdentifier(&quot;&lt;YourViewControllerIdentifier&gt;&quot;) as? &lt;YourViewController&gt; else {
        return nil
    }

    datailVC.peekActive = true
    previewingContext.sourceRect = cell.frame

    // Do the stuff

    return datailVC

}
</code></pre>

<p>The method to be implemented for the <em>pop</em> is <em>previewingContext</em>. :)</p>

<pre><code>func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {

    let balanceViewController = viewControllerToCommit as! &lt;YourViewController&gt;

    // Do the stuff

    navigationController?.pushViewController(balanceViewController, animated: true)

}
</code></pre>

<p>As you can see they are overloaded methods. You can use 3D touch in any way implementing these methods.</p>

<p><strong>Objective-C</strong></p>

<pre><code>//Checking for 3-D Touch availability
if ([self.traitCollection respondsToSelector:@selector(forceTouchCapability)] &amp;&amp;
        (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable))
    {
        [self registerForPreviewingWithDelegate:self sourceView:self.view];
    }
//Peek
- (UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {

    NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location];
    Country *country = [self countryForIndexPath:indexPath];
    if (country) {
        CountryCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
        if (cell) {
            previewingContext.sourceRect = cell.frame;
            UINavigationController *navController = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;UYLCountryNavController&quot;];
            [self configureNavigationController:navController withCountry:country];
            return navController;
        }
    }
    return nil;
}
//Pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit {

    [self showDetailViewController:viewControllerToCommit sender:self];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAGradientLayer]]></title>
    <link href="http://www.citynight.cn/Blog/15038463059094.html"/>
    <updated>2017-08-27T23:05:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/15038463059094.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/3856/creating-a-cagradientlayer">Creating a CAGradientLayer</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.red.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellow.cgColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 1.0]

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/q26bv.png" alt="Simple CAGradientLayer."/></p>

<h2 id="toc_1"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/12652/animating-a-color-change-in-cagradientlayer">Animating a color change in CAGradientLayer.</a></h2>

<pre><code>// Get the current colors of the gradient.
let oldColors = self.gradientLayer.colors

// Define the new colors for the gradient.
let newColors = [UIColor.red.cgColor, UIColor.yellow.cgColor]

// Set the new colors of the gradient.
self.gradientLayer.colors = newColors

// Initialize new animation for changing the colors of the gradient.
let animation: CABasicAnimation = CABasicAnimation(keyPath: &quot;colors&quot;)

// Set current color value.
animation.fromValue = oldColors

// Set new color value.
animation.toValue = newColors

// Set duration of animation.
animation.duration = 0.3

// Set animation to remove once its completed.
animation.isRemovedOnCompletion = true

// Set receiver to remain visible in its final state when the animation is completed.
animation.fillMode = kCAFillModeForwards

// Set linear pacing, which causes an animation to occur evenly over its duration.
animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)

// Set delegate of animation.
animation.delegate = self

// Add the animation.
self.gradientLayer.addAnimation(animation, forKey: &quot;animateGradientColorChange&quot;)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/AquKd.gif" alt="Basic CAGradientLayer color change animation."/></p>

<h2 id="toc_2"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4229/creating-a-horizontal-cagradientlayer-with-multiple-colors">Creating a horizontal CAGradientLayer with multiple colors.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.greenColor().CGColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.blueColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.blackColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/I4OGH.png" alt="enter image description here"/></p>

<h2 id="toc_3"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4228/creating-a-horizontal-cagradientlayer">Creating a horizontal CAGradientLayer.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.redColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellowColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/7VCnW.png" alt="Horizontal CAGradientLayer."/></p>

<h2 id="toc_4"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4227/creating-a-cggradientlayer-with-multiple-colors">Creating a CGGradientLayer with multiple colors.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.blue.cgColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.yellow.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.green.cgColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 0.5, 1.0]

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/tV4OL.png" alt="Complex CAGradientLayer."/></p>

<hr/>

<h2 id="toc_5">Syntax</h2>

<pre><code>CAGradientLayer() // Returns an initialized CALayer object.
-------------------
CAGradientLayer(layer: layer) // Override to copy or initialize custom fields of the specified layer.
</code></pre>

<h2 id="toc_6">Parameters</h2>

<table>
<thead>
<tr>
<th style="text-align: left">Parameter</th>
<th style="text-align: left">Details</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">color</td>
<td style="text-align: left">An array of <code>CGColorRef</code> objects defining the color of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">locations</td>
<td style="text-align: left">An optional array of <code>NSNumber</code> objects defining the location of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">endPoint</td>
<td style="text-align: left">The end point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">startPoint</td>
<td style="text-align: left">The start point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">type</td>
<td style="text-align: left">Style of gradient drawn by the layer. Defaults to <code>kCAGradientLayerAxial</code>.</td>
</tr>
</tbody>
</table>

<h2 id="toc_7">Remarks</h2>

<ul>
<li>Use <code>startPoint</code> and <code>endPoint</code> to change the orientation of the <code>CAGradientLayer</code>.</li>
<li>Use the <code>locations</code> to affect the spread/positions of the colors.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom UIViews from XIB files]]></title>
    <link href="http://www.citynight.cn/Blog/15036540820094.html"/>
    <updated>2017-08-25T17:41:22+08:00</updated>
    <id>http://www.citynight.cn/Blog/15036540820094.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/4443/wiring-elements">Wiring elements</a></h2>

<ul>
<li><blockquote>
<p>Create a XIB file</p>
</blockquote>

<p>Xcode Menu Bar &gt; File &gt; New &gt; File.<br/>
Select iOS, User Interface and then &ldquo;View&rdquo;:</p>

<p><a href="media/15036540820094/RSkzu.png"><img src="media/15036540820094/RSkzu.png" alt="First step"/></a></p>

<p>Give your XIB a name (yes, we are doing a Pokemon example 👾).<br/>
<strong>Remember to check your target</strong> and hit &ldquo;Create&rdquo;.</p>

<p><a href="media/15036540820094/oJ1s1.png"><img src="media/15036540820094/oJ1s1.png" alt="Second step"/></a></p>

<blockquote>
<p>Design your view</p>
</blockquote>

<p>To make things easier, set:</p>

<ul>
<li>Size: Freeform</li>
<li>Status Bar: None</li>
<li>Top Bar: None</li>
<li>Bottom Bar: None</li>
</ul>

<p><a href="media/15036540820094/Gy0KD.png"><img src="media/15036540820094/Gy0KD.png" alt="Third step"/></a></p>

<p>Click on the Size Inspector and resize the view.<br/>
For this example we&rsquo;ll be using width 321 and height 256.</p>

<p><a href="media/15036540820094/PNIek.png"><img src="media/15036540820094/PNIek.png" alt="Fourth step"/></a></p>

<p>Drop some elements into your XIB file like shown below.<br/>
Here we&rsquo;ll be adding an <strong>Image View</strong> (256x256) and a <strong>Switch</strong>.</p>

<p><a href="media/15036540820094/6u3pd.png"><img src="media/15036540820094/6u3pd.png" alt="Fifth step"/></a></p>

<p>Add Auto-Layout constraints by clicking on &ldquo;Resolve Auto Layout Issues&rdquo; (bottom-right) and selecting &ldquo;Add Missing Constraints&rdquo; under &ldquo;All Views&rdquo;.</p>

<p><a href="media/15036540820094/esZhQ.png"><img src="media/15036540820094/esZhQ.png" alt="Sixth step"/></a></p>

<p>Preview the changes you made by clicking on &ldquo;Show the Assistant Editor&rdquo; (top-right), then &ldquo;Preview&rdquo;.<br/>
You can add iPhone screens by clicking on the &ldquo;Plus&rdquo; button.<br/>
The preview should look like this:</p>

<p><a href="media/15036540820094/D3rac.png"><img src="media/15036540820094/D3rac.png" alt="Seventh step"/></a></p>

<blockquote>
<p>Subclass UIView</p>
</blockquote>

<p>Create the class that is going to manage the XIB file.<br/>
Xcode Menu Bar &gt; File &gt; New &gt; File.<br/>
Select iOS / Source / Cocoa Touch Class. Hit &ldquo;Next&rdquo;.</p>

<p><a href="media/15036540820094/0EyHy.png"><img src="media/15036540820094/0EyHy.png" alt="Eighth step"/></a></p>

<p>Give the class a name, which must be the same name as the XIB file (Pokemon).<br/>
Select UIView as the subclass type, then hit &ldquo;Next&rdquo;.</p>

<p><a href="media/15036540820094/qbo3s.png"><img src="media/15036540820094/qbo3s.png" alt="Nineth step"/></a></p>

<p>On the next window, select your target and hit &ldquo;Create&rdquo;.</p>

<p><a href="media/15036540820094/Ks9Tu.png"><img src="media/15036540820094/Ks9Tu.png" alt="Tenth step"/></a></p>

<blockquote>
<p>Connect Pokemon.xib to Pokemon.swift via &ldquo;File’s Owner&rdquo; attribute</p>
</blockquote>

<p>Click on the Pokemon.xib file in Xcode.<br/>
Click on the &ldquo;File&rsquo;s Owner&rdquo; outlet.<br/>
On the &ldquo;Identity inspector&rdquo; (top-right), set the Class to our recently created Pokemon.swift file.</p>

<p><a href="media/15036540820094/4YT3i.png"><img src="media/15036540820094/4YT3i.png" alt="Eleventh step"/></a></p>

<blockquote>
<p>POKEMONS!!!</p>
</blockquote>

<p>Yes! Drag and drop some Pokemons into your project to finish up our &ldquo;infrastructure&rdquo;.<br/>
Here we are adding two PGN files, 256x256, transparent.</p>

<p><a href="media/15036540820094/ibqxZ.png"><img src="media/15036540820094/ibqxZ.png" alt="Twelfth step"/></a></p>

<blockquote>
<p>Show me code already.</p>
</blockquote>

<p>All right, all right.<br/>
Time to add some code to our Pokemon.swift class.</p>

<p>It&rsquo;s actually pretty simple:</p>

<ol>
<li>Implement required initializers</li>
<li>Load the XIB file</li>
<li>Configure the view that will display the XIB file</li>
<li>Show the above view</li>
</ol>

<p>Add the following code to the Pokemon.swift class:</p>

<pre><code>import UIKit

class Pokemon: UIView {

    // MARK: - Initializers

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setupView()
    }

    // MARK: - Private Helper Methods

    // Performs the initial setup.
    private func setupView() {
        let view = viewFromNibForClass()
        view.frame = bounds

        // Auto-layout stuff.
        view.autoresizingMask = [
            UIViewAutoresizing.flexibleWidth,
            UIViewAutoresizing.flexibleHeight
        ]

        // Show the view.
        addSubview(view)
    }

    // Loads a XIB file into a view and returns this view.
    private func viewFromNibForClass() -&gt; UIView {

        let bundle = Bundle(for: type(of: self))
        let nib = UINib(nibName: String(describing: type(of: self)), bundle: bundle)
        let view = nib.instantiate(withOwner: self, options: nil).first as! UIView

        /* Usage for swift &lt; 3.x
        let bundle = NSBundle(forClass: self.dynamicType)
        let nib = UINib(nibName: String(self.dynamicType), bundle: bundle)
        let view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView
        */

        return view
    }
}

</code></pre>

<blockquote>
<p>@IBDesignable and @IBInspectable</p>
</blockquote>

<p>By adding <code>@IBDesignable</code> to your class, you make possible for it to live-render in Interface Builder.<br/>
By adding <code>@IBInspectable</code> to the properties of your class, you can see your custom views changing in Interface Builder as soon as you modify those properties.</p>

<p>Let&rsquo;s make the <code>Image View</code> of our custom view &ldquo;Inspectable&rdquo;.</p>

<p>First, hook up the <code>Image View</code> from the Pokemon.xib file to the Pokemon.swift class.</p>

<p><a href="media/15036540820094/Dxyv2.png"><img src="media/15036540820094/Dxyv2.png" alt="Thirteenth step"/></a></p>

<p>Call the outlet <code>imageView</code> and then add the following code (notice the <code>@IBDesignable</code> before the class name):</p>

<pre><code>@IBDesignable class Pokemon: UIView {

    // MARK: - Properties

    @IBOutlet weak var imageView: UIImageView!

    @IBInspectable var image: UIImage? {
        get {
            return imageView.image
        }
        set(image) {
            imageView.image = image
        }
    }

    // MARK: - Initializers
    ...

</code></pre>

<blockquote>
<p>Using your Custom Views</p>
</blockquote>

<p>Got to your Main storyboard file, drag a UIView into it.<br/>
Resize the view to, say 200x200. Centralize.<br/>
Go to the Identity inspector (top-right) and set the Class to Pokemon.</p>

<p><a href="media/15036540820094/Iah3Y.png"><img src="media/15036540820094/Iah3Y.png" alt="Fourteenth steps"/></a></p>

<p>To select a Pokemon, go to the Attribute Inspector (top-right) and select one of the Pokemon images you previously added using the awesome <code>@IBInspectable</code> image property.</p>

<p><a href="media/15036540820094/727mm.png"><img src="media/15036540820094/727mm.png" alt="Fifteenth step"/></a></p>

<p>Now duplicate your custom Pokemon view.<br/>
Give it a different size, say 150x150.<br/>
Choose another Pokemon image, observe:</p>

<p><a href="media/15036540820094/xrTXw.png"><img src="media/15036540820094/xrTXw.png" alt="Sixteenth step"/></a></p>

<p>Now we are going to add more logic to that self-containing custom UI element.<br/>
The button will allow Pokemons to be enabled/disabled.</p>

<p>Create an <code>IBAction</code> from the Switch button to the Pokemon.swift class.<br/>
Call the action something like <code>switchTapped</code>.<br/>
Add the following code to it:</p>

<pre><code>// MARK: - Actions

@IBAction func switchTapped(sender: UISwitch) {
    imageView.alpha = sender.on ? 1.0 : 0.2
}

// MARK: - Initializers
...

</code></pre>

<p>Final result:</p>

<p><a href="media/15036540820094/DQJvO.gif"><img src="media/15036540820094/DQJvO.gif" alt="Final"/></a></p>

<p>You are done!<br/>
Now you can create complex custom views and reuse them anywhere you want.<br/>
This will increase productivity while isolating code into self-contained UI elements.</p>

<p><a href="https://github.com/singledev/custom-uiviews-from-xib">The final project can be cloned in Github.</a><br/>
(<strong>Updated to Swift 3.1</strong>)</p></li>
</ul>

<h2 id="toc_1"><a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/11599/how-to-make-custom-reusable-uiview-using-xib">How to make custom reusable UIView using XIB</a></h2>

<p>Following example shows steps involved in initializing a view from XIB.</p>

<p>This is not a complex operation but exact steps need to be followed in order to do it right way first time, avoiding exceptions.</p>

<p><a href="http://stackoverflow.com/questions/20323393/how-does-loadnibnamed-work-uiview-outlets-not-initializing-using-loadnibnamed">How does loadNibNamed Works</a></p>

<p>Main steps are:</p>

<ol>
<li>Create XIB</li>
<li>Create class .h and .m</li>
<li>Define outlets in .h</li>
<li><p>Connect outlets between .h and XIB</p>

<p>See attached screenshot:</p>

<p><a href="media/15036540820094/rSBw6.png"><img src="media/15036540820094/rSBw6.png" alt="Label Object connected to myLabel IBOutlet UILabel variable"/></a></p></li>
<li><p>Invoke loadNibNamed inside initWithCoder function of .m file. This is needed to ensure you can directly place UIView object into storyboard / Parent UIView XIB file and define it as your custom view. No other initialization code is needed once you load the storyboard / parent XIB. Your custom view can be added to other views just like other built-in Objective C view objects given in XCode.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath]]></title>
    <link href="http://www.citynight.cn/Blog/15036524793322.html"/>
    <updated>2017-08-25T17:14:39+08:00</updated>
    <id>http://www.citynight.cn/Blog/15036524793322.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>

<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/13624/designing-and-drawing-a-bezier-path">Designing and drawing a Bezier Path</a></h2>

<p>This example shows the process from designing the shape you want to drawing it on a view. A specific shap is used but the concepts you learn can be applied to any shape.</p>

<h3 id="toc_1">How to draw a <a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html">Bézier path</a> in a custom view</h3>

<p>These are the main steps:</p>

<ol>
<li>Design the outline of the shape you want.</li>
<li>Divide the outline path into segments of lines, arcs, and curves.</li>
<li>Build that path programmatically.</li>
<li>Draw the path either in <code>drawRect</code> or using a <code>CAShapeLayer</code>.</li>
</ol>

<h3 id="toc_2">Design shape outline</h3>

<p>You could do anything, but as an example I have chosen the shape below. It could be a popup key on a keyboard.</p>

<p><a href="media/15036524793322/geckR.png"><img src="media/15036524793322/geckR.png" alt="enter image description here"/></a></p>

<h3 id="toc_3">Divide the path into segments</h3>

<p>Look back at your shape design and break it down into simpler elements of lines (for straight lines), arcs (for circles and round corners), and curves (for anything else).</p>

<p>Here is what our example design would look like:</p>

<p><a href="media/15036524793322/4mkcI.png"><img src="media/15036524793322/4mkcI.png" alt="enter image description here"/></a></p>

<ul>
<li>Black are line segments</li>
<li>Light blue are arc segments</li>
<li>Red are curves</li>
<li>Orange dots are the control points for the curves</li>
<li>Green dots are the points between path segments</li>
<li>Dotted lines show the bounding rectangle</li>
<li>Dark blue numbers are the segments in the order that they will be added programmatically</li>
</ul>

<h3 id="toc_4">Build the path programmatically</h3>

<p>We&rsquo;ll arbitrarily start in the bottom left corner and work clockwise. I&rsquo;ll use the grid in the image to get the x and y values for the points. I&rsquo;ll hardcode everything here, but of course you wouldn&rsquo;t do that in a real project.</p>

<p>The basic process is:</p>

<ol>
<li>Create a new <code>UIBezierPath</code></li>
<li>Choose a starting point on the path with <code>moveToPoint</code></li>
<li><p>Add segments to the path</p></li>
</ol>

<ul>
<li>line: <code>addLineToPoint</code></li>
<li>arc: <code>addArcWithCenter</code></li>
<li><p>curve: <code>addCurveToPoint</code></p></li>
</ul>

<ol>
<li>Close the path with <code>closePath</code></li>
</ol>

<p>Here is the code to make the path in the image above.</p>

<pre><code>func createBezierPath() -&gt; UIBezierPath {

    // create a new path
    let path = UIBezierPath()

    // starting point for the path (bottom left)
    path.moveToPoint(CGPoint(x: 2, y: 26))

    // *********************
    // ***** Left side *****
    // *********************

    // segment 1: line
    path.addLineToPoint(CGPoint(x: 2, y: 15))

    // segment 2: curve
    path.addCurveToPoint(CGPoint(x: 0, y: 12), // ending point
        controlPoint1: CGPoint(x: 2, y: 14),
        controlPoint2: CGPoint(x: 0, y: 14))

    // segment 3: line
    path.addLineToPoint(CGPoint(x: 0, y: 2))

    // *********************
    // ****** Top side *****
    // *********************

    // segment 4: arc
    path.addArcWithCenter(CGPoint(x: 2, y: 2), // center point of circle
        radius: 2, // this will make it meet our path line
        startAngle: CGFloat(M_PI), // π radians = 180 degrees = straight left
        endAngle: CGFloat(3*M_PI_2), // 3π/2 radians = 270 degrees = straight up
        clockwise: true) // startAngle to endAngle goes in a clockwise direction

    // segment 5: line
    path.addLineToPoint(CGPoint(x: 8, y: 0))

    // segment 6: arc
    path.addArcWithCenter(CGPoint(x: 8, y: 2),
        radius: 2,
        startAngle: CGFloat(3*M_PI_2), // straight up
        endAngle: CGFloat(0), // 0 radians = straight right
        clockwise: true)

    // *********************
    // ***** Right side ****
    // *********************

    // segment 7: line
    path.addLineToPoint(CGPoint(x: 10, y: 12))

    // segment 8: curve
    path.addCurveToPoint(CGPoint(x: 8, y: 15), // ending point
        controlPoint1: CGPoint(x: 10, y: 14),
        controlPoint2: CGPoint(x: 8, y: 14))

    // segment 9: line
    path.addLineToPoint(CGPoint(x: 8, y: 26))

    // *********************
    // **** Bottom side ****
    // *********************

    // segment 10: line
    path.closePath() // draws the final line to close the path

    return path
}
</code></pre>

<p>Note: Some of the above code can be reduced by adding a line and an arc in a single command (since the arc has an implied starting point). See <a href="http://ronnqvi.st/thinking-like-a-bzier-path/">here</a> for more details.</p>

<h3 id="toc_5">Draw the path</h3>

<p>We can draw the path either in a layer or in <code>drawRect</code>.</p>

<p><strong>Method 1: Draw path in a layer</strong></p>

<p>Our custom class looks like this. We add our Bezier path to a new <code>CAShapeLayer</code> when the view is initialized.</p>

<pre><code>import UIKit
class MyCustomView: UIView {

    override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    func setup() {

        // Create a CAShapeLayer
        let shapeLayer = CAShapeLayer()

        // The Bezier path that we made needs to be converted to 
        // a CGPath before it can be used on a layer.
        shapeLayer.path = createBezierPath().CGPath

        // apply other properties related to the path
        shapeLayer.strokeColor = UIColor.blueColor().CGColor
        shapeLayer.fillColor = UIColor.whiteColor().CGColor
        shapeLayer.lineWidth = 1.0
        shapeLayer.position = CGPoint(x: 10, y: 10)

        // add the new layer to our custom view
        self.layer.addSublayer(shapeLayer)
    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>

<p>And creating our view in the View Controller like this</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // create a new UIView and add it to the view controller
    let myView = MyCustomView()
    myView.frame = CGRect(x: 100, y: 100, width: 50, height: 50)
    myView.backgroundColor = UIColor.yellowColor()
    view.addSubview(myView)

}
</code></pre>

<p>We get&hellip;</p>

<p><a href="media/15036524793322/oELys.png"><img src="media/15036524793322/oELys.png" alt="enter image description here"/></a></p>

<p>Hmm, that&rsquo;s a little small because I hardcoded all the numbers in. I can scale the path size up, though, like this:</p>

<pre><code>let path = createBezierPath()
let scale = CGAffineTransformMakeScale(2, 2)
path.applyTransform(scale)
shapeLayer.path = path.CGPath
</code></pre>

<p><a href="media/15036524793322/LXvPc.png"><img src="media/15036524793322/LXvPc.png" alt="enter image description here"/></a></p>

<p><strong>Method 2: Draw path in <code>drawRect</code></strong></p>

<p>Using <code>drawRect</code> is slower than drawing to the layer, so this is not the recommended method if you don&rsquo;t need it.</p>

<p>Here is the revised code for our custom view:</p>

<pre><code>import UIKit
class MyCustomView: UIView {

    override func drawRect(rect: CGRect) {

        // create path (see previous code)
        let path = createBezierPath()

        // fill
        let fillColor = UIColor.whiteColor()
        fillColor.setFill()

        // stroke
        path.lineWidth = 1.0
        let strokeColor = UIColor.blueColor()
        strokeColor.setStroke()

        // Move the path to a new location
        path.applyTransform(CGAffineTransformMakeTranslation(10, 10))

        // fill and stroke the path (always do these last)
        path.fill()
        path.stroke()

    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>

<p>which gives us the same result&hellip;</p>

<p><a href="media/15036524793322/2hqMa.png"><img src="media/15036524793322/2hqMa.png" alt="enter image description here"/></a></p>

<h3 id="toc_6">Further study</h3>

<p>Excellent articles for understanding Bezier paths.</p>

<ul>
<li><a href="http://ronnqvi.st/thinking-like-a-bzier-path/">Thinking like a Bézier path</a> (Everything I&rsquo;ve ever read from this author is good and the inspiration for my example above came from here.)</li>
<li><a href="https://www.youtube.com/watch?v=dXECQRlmIaE">Coding Math: Episode 19 - Bezier Curves</a> (entertaining and good visual illustrations)</li>
<li><a href="https://www.youtube.com/watch?v=Qu-QK3uoMdY">Bezier Curves</a> (how they are used in graphics applications)</li>
<li><a href="https://www.youtube.com/watch?v=2HvH9cmHbG4">Bezier Curves</a> (good description of how the mathematical formulas are derived)</li>
</ul>

<h3 id="toc_7">Notes</h3>

<ul>
<li>This example originally comes from <a href="http://stackoverflow.com/a/34659468/3681880">this Stack Overflow answer</a>.</li>
<li>In your actual projects you probably shouldn&rsquo;t use hard coded numbers, but rather get the sizes from your view&rsquo;s bounds.</li>
</ul>

<hr/>

<h2 id="toc_8"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10890/how-to-apply-corner-radius-to-rectangles-drawn-by-uibezierpath">How to apply corner radius to rectangles drawn by UIBezierPath</a></h2>

<p><em>Corner radius for all 4 edges:</em></p>

<p><a href="media/15036524793322/O8qTg.png"><img src="media/15036524793322/O8qTg.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) cornerRadius: 11];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>Corner radius for top-left edge:</em></p>

<p><a href="media/15036524793322/OEOJa.png"><img src="media/15036524793322/OEOJa.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>Corner radius for top-right edge:</em></p>

<p><a href="media/15036524793322/1xhp8.png"><img src="media/15036524793322/1xhp8.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom-left edge:</em></p>

<p><a href="media/15036524793322/yqd87.png"><img src="media/15036524793322/yqd87.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom-right edge:</em></p>

<p><a href="media/15036524793322/AIgP0.png"><img src="media/15036524793322/AIgP0.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom edges:</em></p>

<p><a href="media/15036524793322/4BrrS.png"><img src="media/15036524793322/4BrrS.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for top edges:</em></p>

<p><a href="media/15036524793322/lecWo.png"><img src="media/15036524793322/lecWo.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<hr/>

<h2 id="toc_9"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10893/how-to-apply-shadows-to-uibezierpath">How to apply shadows to UIBezierPath</a></h2>

<p>Consider a simple rectangle that is drawn by the bezier path.</p>

<p><a href="media/15036524793322/imDTW.png"><img src="media/15036524793322/imDTW.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
 [UIColor.grayColor setFill];
 [rectanglePath fill];
</code></pre>

<p><em>Basic Outer-fill shadow:</em></p>

<p><a href="media/15036524793322/mqiIV.png"><img src="media/15036524793322/mqiIV.png" alt="enter image description here"/></a></p>

<pre><code>CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(7.1, 5.1)];
[shadow setShadowBlurRadius: 5];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
CGContextSaveGState(context);
CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [shadow.shadowColor CGColor]);
[UIColor.grayColor setFill];
[rectanglePath fill];
CGContextRestoreGState(context);
</code></pre>

<p><em>Basic Inner fill shadow:</em></p>

<p><a href="media/15036524793322/C1rZk.png"><img src="media/15036524793322/C1rZk.png" alt="enter image description here"/></a></p>

<pre><code>CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(9.1, -7.1)];
[shadow setShadowBlurRadius: 6];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
[UIColor.grayColor setFill];
[rectanglePath fill];

CGContextSaveGState(context);
UIRectClip(rectanglePath.bounds);
CGContextSetShadowWithColor(context, CGSizeZero, 0, NULL);

CGContextSetAlpha(context, CGColorGetAlpha([shadow.shadowColor CGColor]));
CGContextBeginTransparencyLayer(context, NULL);
{
    UIColor* opaqueShadow = [shadow.shadowColor colorWithAlphaComponent: 1];
    CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [opaqueShadow CGColor]);
    CGContextSetBlendMode(context, kCGBlendModeSourceOut);
    CGContextBeginTransparencyLayer(context, NULL);

    [opaqueShadow setFill];
    [rectanglePath fill];

    CGContextEndTransparencyLayer(context);
}
CGContextEndTransparencyLayer(context);
CGContextRestoreGState(context);
</code></pre>

<h2 id="toc_10"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10891/how-to-create-a-simple-shapes-using-uibezierpath">How to create a simple shapes using UIBezierPath</a></h2>

<p><em>For a simple circle:</em></p>

<p><a href="media/15036524793322/ymoay.png"><img src="media/15036524793322/ymoay.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let ovalPath = UIBezierPath(ovalInRect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>

<p><em>For a simple Rectangle:</em></p>

<p><a href="media/15036524793322/C1GFH.png"><img src="media/15036524793322/C1GFH.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
rectanglePath.fill()
</code></pre>

<p><em>For a simple Line:</em></p>

<p><a href="media/15036524793322/KIAOK.png"><img src="media/15036524793322/KIAOK.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* bezierPath = [UIBezierPath bezierPath];
[bezierPath moveToPoint: CGPointMake(x1,y1)];
[bezierPath addLineToPoint: CGPointMake(x2,y2)];
[UIColor.blackColor setStroke];
bezierPath.lineWidth = 1;
[bezierPath stroke];
</code></pre>

<p>Swift:</p>

<pre><code>let bezierPath = UIBezierPath()
bezierPath.moveToPoint(CGPoint(x: x1, y: y1))
bezierPath.addLineToPoint(CGPoint(x: x2, y: y2))
UIColor.blackColor().setStroke()
bezierPath.lineWidth = 1
bezierPath.stroke()
</code></pre>

<p><em>For a half circle:</em></p>

<p><a href="media/15036524793322/3Nywj.png"><img src="media/15036524793322/3Nywj.png" alt="enter image description here"/></a></p>

<pre><code> CGRect ovalRect = CGRectMake(x,y,width,height);
UIBezierPath* ovalPath = [UIBezierPath bezierPath];
[ovalPath addArcWithCenter: CGPointMake(0, 0) radius: CGRectGetWidth(ovalRect) / 2 startAngle: 180 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
[ovalPath addLineToPoint: CGPointMake(0, 0)];
[ovalPath closePath];

CGAffineTransform ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect));
ovalTransform = CGAffineTransformScale(ovalTransform, 1, CGRectGetHeight(ovalRect) / CGRectGetWidth(ovalRect));
[ovalPath applyTransform: ovalTransform];

[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let ovalRect = CGRect(x: 0, y: 0, width: 50, height: 50)
let ovalPath = UIBezierPath()
ovalPath.addArcWithCenter(CGPoint.zero, radius: ovalRect.width / 2, startAngle: 180 * CGFloat(M_PI)/180, endAngle: 0 * CGFloat(M_PI)/180, clockwise: true)
ovalPath.addLineToPoint(CGPoint.zero)
ovalPath.closePath()

var ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect))
ovalTransform = CGAffineTransformScale(ovalTransform, 1, ovalRect.height / ovalRect.width)
ovalPath.applyTransform(ovalTransform)

UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>

<p><em>For a simple triangle:</em></p>

<p><a href="media/15036524793322/5r6IE.png"><img src="media/15036524793322/5r6IE.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* polygonPath = [UIBezierPath bezierPath];
[polygonPath moveToPoint: CGPointMake(x1, y1)];
[polygonPath addLineToPoint: CGPointMake(x2, y2)];
[polygonPath addLineToPoint: CGPointMake(x3, y2)];
[polygonPath closePath];
[UIColor.grayColor setFill];
[polygonPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let polygonPath = UIBezierPath()
polygonPath.moveToPoint(CGPoint(x: x1, y: y1))
polygonPath.addLineToPoint(CGPoint(x: x2, y: y2))
polygonPath.addLineToPoint(CGPoint(x: x3, y: y3))
polygonPath.closePath()
UIColor.grayColor().setFill()
polygonPath.fill()
</code></pre>

<hr/>

<h2 id="toc_11"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/18109/pie-view-column-view-with-uibezierpath">pie view &amp; column view with UIBezierPath</a></h2>

<ul>
<li>pie view
<img src="media/15036524793322/oh0DL.png" alt="pie view"/></li>
</ul>

<pre><code>- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@30, @15, @5, @17, @3, @10, @20];

    // 1\. context
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    CGPoint center = CGPointMake(150, 150);
    CGFloat radius = 150;
    __block CGFloat startAngle = 0;
    [data enumerateObjectsUsingBlock:^(NSNumber * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {

        // 2\. create path
        CGFloat endAngle = obj.floatValue / 100 * M_PI * 2 + startAngle;
        UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
        [circlePath addLineToPoint:center];

        // 3\. add path
        CGContextAddPath(cxtRef, circlePath.CGPath);

        // set color
        [[UIColor colorWithRed:((float)arc4random_uniform(256) / 255.0) green:((float)arc4random_uniform(256) / 255.0) blue:((float)arc4random_uniform(256) / 255.0) alpha:1.0] setFill];

        // 4\. render
        CGContextDrawPath(cxtRef, kCGPathFill);

        // reset angle
        startAngle = endAngle;
    }];
}


override func draw(_ rect: CGRect) {
    // define data to create pie chart
    let data: [Int] = [30, 15, 5, 17, 3, 10, 20]

    // 1\. find center of draw rect
    let center: CGPoint = CGPoint(x: rect.midX, y: rect.midY)

    // 2\. calculate radius of pie
    let radius = min(rect.width, rect.height) / 2.0

    var startAngle: CGFloat = 0.0
    for value in data {

      // 3\. calculate end angle for slice
      let endAngle = CGFloat(value) / 100.0 * CGFloat.pi * 2.0 + startAngle

      // 4\. create UIBezierPath for slide
      let circlePath = UIBezierPath(arcCenter: center, radius: radius, startAngle: startAngle, endAngle: endAngle, clockwise: true)

      // 5\. add line to center to close path
      circlePath.addLine(to: center)

      // 6\. set fill color for current slice
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill slice path
      circlePath.fill()

      // 8\. set end angle as start angle for next slice
      startAngle = endAngle
    }
  }
</code></pre>

<ul>
<li>column view
<img src="media/15036524793322/ayD5Y.png" alt="column view"/></li>
</ul>

<pre><code>- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@300, @150.65, @55.3, @507.7, @95.8, @700, @650.65];

    // 1.
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    NSInteger columnCount = 7;
    CGFloat width = self.bounds.size.width / (columnCount + columnCount - 1);
    for (NSInteger i = 0; i 

override func draw(_ rect: CGRect) {
    // define data for chart
    let data: [CGFloat] = [300, 150.65, 55.3, 507.7, 95.8, 700, 650.65]

    // 1\. calculate number of columns
    let columnCount = data.count

    // 2\. calculate column width
    let columnWidth = rect.width / CGFloat(columnCount + columnCount - 1)

    for (columnIndex, value) in data.enumerated() {
      // 3\. calculate column height
      let columnHeight = value / 1000.0 * rect.height

      // 4\. calculate column origin
      let columnOrigin = CGPoint(x: (columnWidth * 2.0 * CGFloat(columnIndex)), y: (rect.height - columnHeight))

      // 5\. create path for column
      let columnPath = UIBezierPath(rect: CGRect(origin: columnOrigin, size: CGSize(width: columnWidth, height: columnHeight)))

      // 6\. set fill color for current column
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill column path
      columnPath.fill()
    }
  }
</code></pre>

<hr/>

<h2 id="toc_12"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10892/uibezierpath-autolayout">UIBezierPath + AutoLayout</a></h2>

<p>For bezier path to get resized based on the view frame, override the drawRect of view that you are drawing the bezier path :</p>

<pre><code>- (void)drawRect:(CGRect)frame
{
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), CGRectGetWidth(frame), CGRectGetHeight(frame))];
    [UIColor.grayColor setFill];
    [rectanglePath fill];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD(Grand Central Dispatch)]]></title>
    <link href="http://www.citynight.cn/Blog/15035627499170.html"/>
    <updated>2017-08-24T16:19:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/15035627499170.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>

<p>Grand Central Dispatch (GCD) is Apple&rsquo;s answer to multithreading. It is a lightweight framework for performing tasks synchronously or asynchronously in queues and handles CPU threads for you behind the scenes.</p>

<h2 id="toc_0">Dispatch Semaphore</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28284/dispatch-semaphore">Stack Overflow地址</a></p>

<blockquote>
<p>DispatchSemaphore provides an efficient implementation of a traditional counting semaphore, which can be used to control access to a resource across multiple execution contexts.</p>
</blockquote>

<p>A scenario for when to use a semaphore could be if you are doing some file reading/writing, if multiple tasks are trying to read and write from file at the same time, it could increase your performance to make each task wait its turn so as to not overburden the I/O controller.</p>

<pre><code>func do2TasksAtATime () {
    print(&quot;starting long running tasks (2 at a time)&quot;)
    let sem = DispatchSemaphore(value: 2)            //this semaphore only allows 2 tasks to run at the same time (the resource count)
    for i in 0...7 {                                 //launch a bunch of tasks
        DispatchQueue.global().async {               //run tasks on a background thread
            sem.wait()                               //wait here if no resources available
            sleep(2)                                 //do some long task eg file access (here we are just sleeping for a 2 seconds for demonstration purposes)
            print(&quot;long task \(i) done! \(Date())&quot;)
            sem.signal()                             //let the semaphore know this resource is now available
        }
    }
}
</code></pre>

<p>Example output: (notice the time stamps)</p>

<pre><code>starting long running tasks (2 at a time)
long task 0 done! 2017-02-16 07:11:53 +0000
long task 1 done! 2017-02-16 07:11:53 +0000
long task 2 done! 2017-02-16 07:11:55 +0000
long task 3 done! 2017-02-16 07:11:55 +0000
long task 5 done! 2017-02-16 07:11:57 +0000
long task 4 done! 2017-02-16 07:11:57 +0000
long task 6 done! 2017-02-16 07:11:59 +0000
long task 7 done! 2017-02-16 07:11:59 +0000
</code></pre>

<h2 id="toc_1">Dispatch Group</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28278/dispatch-group">Stack Overflow地址</a></p>

<blockquote>
<p>DispatchGroup allows for aggregate synchronization of work. You can use them to submit multiple different work items and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.</p>
</blockquote>

<p>A Scenario when this could be useful is if you have multiple webservice calls that all need to finish before continuing. For example, you need to download multiple sets of data that needs to be processed by some function. You have to wait for all webservices to complete before calling the function to process all the received data.</p>

<p><strong>Swift 3</strong></p>

<pre><code>func doLongTasksAndWait () {
    print(&quot;starting long running tasks&quot;)
    let group = DispatchGroup()          //create a group for a bunch of tasks we are about to do
    for i in 0...3 {                     //launch a bunch of tasks (eg a bunch of webservice calls that all need to be finished before proceeding to the next ViewController)
        group.enter()                    //let the group know that something is being added
        DispatchQueue.global().async {   //run tasks on a background thread
            sleep(arc4random() % 4)      //do some long task eg webservice or database lookup (here we are just sleeping for a random amount of time for demonstration purposes)
            print(&quot;long task \(i) done!&quot;)
            group.leave()                //let group know that the task is finished
        }
    }
    group.wait()                         //will block whatever thread we are on here until all the above tasks have finished (so maybe dont use this function on your main thread)
    print(&quot;all tasks done!&quot;)
}
</code></pre>

<p>Alternatively, if you do not want to wait for the groups to finish, but instead want to run a function once all the tasks have completed, use the <code>notify</code> function in place of the <code>group.wait()</code></p>

<pre><code>group.notify(queue: DispatchQueue.main) { //the queue: parameter is which queue this block will run on, if you need to do UI updates, use the main queue
    print(&quot;all tasks done!&quot;)              //this will execute when all tasks have left the group
}
</code></pre>

<p>Example output:</p>

<pre><code>starting long running tasks
long task 0 done!
long task 3 done!
long task 1 done!
long task 2 done!
all tasks done!
</code></pre>

<h2 id="toc_2">Serial vs Concurrent Dispatch Queues</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28286/serial-vs-concurrent-dispatch-queues">Stack Overflow地址</a><br/>
<strong>Serial Queue</strong></p>

<pre><code>func serialQueues () {
    let serialQueue = DispatchQueue(label: &quot;com.example.serial&quot;) //default queue type is a serial queue
    let start = Date ()
    for i in 0...3 {                                             //launch a bunch of tasks
        serialQueue.async {                                      //run tasks on a background thread, using our serial queue
            sleep(2)                                             //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;serial long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>

<p>Example output:</p>

<pre><code>serial long task 0 done! total time taken: 2.07241100072861
serial long task 1 done! total time taken: 4.16347700357437
serial long task 2 done! total time taken: 6.23209798336029
serial long task 3 done! total time taken: 8.30682599544525
</code></pre>

<p><strong>Concurrent Queue</strong></p>

<pre><code>func concurrentQueues () {
    let concurrentQueue = DispatchQueue(label: &quot;com.example.concurrent&quot;, attributes: .concurrent) //explicitly specify the queue to be a concurrent queue
    let start = Date ()
    for i in 0...3 {            //launch a bunch of tasks
        concurrentQueue.async { //run tasks on a background thread, using our concurrent queue
            sleep(2)            //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;concurrent long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>

<p>Example output:</p>

<pre><code>concurrent long task 3 done! total time taken: 2.07092100381851
concurrent long task 0 done! total time taken: 2.07087397575378
concurrent long task 2 done! total time taken: 2.07086700201035
concurrent long task 1 done! total time taken: 2.07089096307755
</code></pre>

<p><strong>Discussion</strong></p>

<p>As we can see from the examples above, a serial queue will complete each task in the order they are submitted to the queue. Each task will wait for the previous task to finish before executing. As for the concurrent queue, each task does not wait on the others in the queue and executes as soon as possible; the advantage is that all tasks on the queue will run at the same time on separate threads, making a concurrent queue take less time than a serial queue.</p>

<p>If order of execution of tasks is not important, always use a concurrent queue for the best efficiency.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打包后出现 Undefined symbols for architecture i386]]></title>
    <link href="http://www.citynight.cn/Blog/14963702971919.html"/>
    <updated>2017-06-02T10:24:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/14963702971919.html</id>
    <content type="html"><![CDATA[
<p>出现问题:<br/>
自己打framework真机与模拟器合并后在使用的时候提示 <code>Undefined symbols for architecture i386</code></p>

<p>原因: 打framework的时候使用的是<code>debug</code> 改为<code>release</code><br/>
<img src="media/14963702971919/14963704118450.jpg" alt=""/></p>

<p><strong>合并命令:</strong></p>

<p><code>lipo -create 真机(或者模拟器)framework地址 模拟器(或者真机)ramework地址 -output 输出地址(一般我选择真机framework地址)</code></p>

<p><strong>查看信息:</strong></p>

<p><code>lipo -info 真机(或者模拟器)framework地址</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 文件、磁盘管理]]></title>
    <link href="http://www.citynight.cn/Blog/14954528363090.html"/>
    <updated>2017-05-22T19:33:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954528363090.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.文件管理</h2>

<h3 id="toc_1">查看文件信息：ls</h3>

<p>ls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于DOS下的dir命令。</p>

<p><code>Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。</code></p>

<p>ls常用参数：</p>

<table>
<thead>
<tr>
<th style="text-align: center">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td style="text-align: center">-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td style="text-align: center">-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>

<p><img src="media/14954528363090/14954529185223.jpg" alt=""/></p>

<p>图中列出的信息含义如下图所示：</p>

<p><img src="media/14954528363090/14954529393080.jpg" alt=""/></p>

<p>与DOS下的文件操作类似，在Unix/Linux系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p>

<table>
<thead>
<tr>
<th style="text-align: left">通配符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">*</td>
<td>文件代表文件名中所有字符</td>
</tr>
<tr>
<td style="text-align: left">ls te*</td>
<td>查找以te开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls *html</td>
<td>查找结尾为html的文件</td>
</tr>
<tr>
<td style="text-align: left">？</td>
<td>代表文件名中任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls ?.c</td>
<td>只找第一个字符任意，后缀为.c的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a.?</td>
<td>只找只有3个字符，前2字符为a.，最后一个字符任意的文件</td>
</tr>
<tr>
<td style="text-align: left">[]</td>
<td>[”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。</td>
</tr>
<tr>
<td style="text-align: left">[abc]</td>
<td>匹配a、b、c中的任意一个</td>
</tr>
<tr>
<td style="text-align: left">[a-f]</td>
<td>匹配从a到f范围内的的任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls [a-f]*</td>
<td>找到从a到f范围内的的任意一个字符开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a-f</td>
<td>查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用</td>
</tr>
<tr>
<td style="text-align: left">\</td>
<td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。</td>
</tr>
<tr>
<td style="text-align: left">ls *a</td>
<td>查找文件名为*a的文件</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">输出重定向命令：&gt;</h3>

<p>Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p>

<p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p>

<p><img src="media/14954528363090/14954530933243.jpg" alt=""/><br/>
注意： <code>&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。</code></p>

<h3 id="toc_3">分屏显示：more</h3>

<p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助。</p>

<p><img src="media/14954528363090/14954533115641.jpg" alt=""/></p>

<h3 id="toc_4">管道：|</h3>

<p>管道：一个命令的输出可以通过管道做为另一个命令的输入。</p>

<p>管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。</p>

<p><img src="media/14954528363090/14954534699128.jpg" alt=""/></p>

<h3 id="toc_5">清屏：clear</h3>

<p>clear作用为清除终端上的显示(类似于DOS的cls清屏功能)，也可使用快捷键：Ctrl + l ( “l” 为字母 )。</p>

<h3 id="toc_6">切换工作目录： cd</h3>

<p>在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。<code>Linux所有的目录和文件名大小写敏感</code></p>

<p>cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">cd</td>
<td>切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。</td>
</tr>
<tr>
<td style="text-align: left">cd ~</td>
<td>切换到当前用户的主目录(/home/用户目录)</td>
</tr>
<tr>
<td style="text-align: left">cd .</td>
<td>切换到当前目录</td>
</tr>
<tr>
<td style="text-align: left">cd ..</td>
<td>切换到上级目录</td>
</tr>
<tr>
<td style="text-align: left">cd -</td>
<td>可进入上次所在的目录</td>
</tr>
</tbody>
</table>

<p><img src="media/14954528363090/14955894273051.jpg" alt=""/><br/>
注意：</p>

<ul>
<li>如果路径是从根路径开始的，则路径的前面需要加上 “ / ”，如 “ /mnt ”，通常进入某个目录里的文件夹，前面不用加 “ / ”。</li>
</ul>

<p><img src="media/14954528363090/14955900895519.jpg" alt=""/></p>

<h3 id="toc_7">显示当前路径：pwd</h3>

<p>使用pwd命令可以显示当前的工作目录，该命令很简单，直接输入pwd即可，后面不带参数。</p>

<h3 id="toc_8">创建目录：mkdir</h3>

<p>通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。</p>

<p>需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。<br/>
<img src="media/14954528363090/14955907314659.jpg" alt=""/></p>

<h3 id="toc_9">删除目录：rmdir</h3>

<p>可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。</p>

<h3 id="toc_10">删除文件：rm</h3>

<p>可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。</p>

<p>常用参数及含义如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-i</td>
<td>以进行交互式方式执行</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>递归地删除目录下的内容，删除文件夹时必须加此参数</td>
</tr>
</tbody>
</table>

<h3 id="toc_11">建立链接文件：ln</h3>

<p>Linux链接文件类似于Windows下的快捷方式。</p>

<p>链接文件分为软链接和硬链接。</p>

<p>软链接：软链接不占用磁盘空间，源文件删除则软链接失效。</p>

<p>硬链接：硬链接只能链接普通文件，不能链接目录。</p>

<p>使用格式：</p>

<pre><code>ln 源文件 链接文件
ln -s 源文件 链接文件

</code></pre>

<p>如果<code>没有-s</code>选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。</p>

<p>注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</p>

<h3 id="toc_12">查看或者合并文件内容：cat</h3>

<h3 id="toc_13">文本搜索：grep</h3>

<p>Linux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。</p>

<p>grep一般格式为：</p>

<pre><code>grep [-选项] ‘搜索内容串’文件名

</code></pre>

<p>在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-v</td>
<td>显示不包含匹配文本的所有行（相当于求反）</td>
</tr>
<tr>
<td style="text-align: left">-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>

<p>grep搜索内容串可以是正则表达式。</p>

<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>

<p>grep常用正则表达式：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><sup>a</sup></td>
<td>行首,搜寻以 m 开头的行；grep -n &lsquo;<sup>a&rsquo;</sup> 1.txt</td>
</tr>
<tr>
<td style="text-align: left">ke$</td>
<td>行尾,搜寻以 ke 结束的行；grep -n &lsquo;ke$&rsquo; 1.txt</td>
</tr>
<tr>
<td style="text-align: left">[Ss]igna[Ll]</td>
<td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n &lsquo;[Ss]igna[Ll]&rsquo; 1.txt</td>
</tr>
<tr>
<td style="text-align: left">.</td>
<td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n &lsquo;e.e&rsquo; 1.txt</td>
</tr>
</tbody>
</table>

<h3 id="toc_14">查找文件：find</h3>

<p>find命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</p>

<p>常用用法：</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">find ./ -name test.sh</td>
<td>查找当前目录下所有名为test.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name &lsquo;*.sh&rsquo;</td>
<td>查找当前目录下所有后缀为.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name &ldquo;[A-Z]*&rdquo;</td>
<td>查找当前目录下所有以大写字母开头的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size 2M</td>
<td>查找在/tmp 目录下等于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size +2M</td>
<td>查找在/tmp 目录下大于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size -2M</td>
<td>查找在/tmp 目录下小于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -size +4k -size -5M</td>
<td>查找当前目录下大于4k，小于5M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -perm 0777</td>
<td>查找当前目录下权限为 777 的文件或目录</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">拷贝文件：cp</h3>

<p>cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-a</td>
<td>该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>已经存在的目标文件而不提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>交互式复制，在覆盖目标文件之前将给出提示要求用户确认</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示拷贝进度</td>
</tr>
</tbody>
</table>

<p>cp vim_configure/ code/ -ivr 把文件夹 vim_configure 拷贝到 code 目录里：</p>

<p><strong>暂时缺图稍后补</strong></p>

<h3 id="toc_16">移动文件：mv</h3>

<p>用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-f</td>
<td>禁止交互式操作，如有覆盖也不会给出提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示移动进度</td>
</tr>
</tbody>
</table>

<h3 id="toc_17">归档管理：tar</h3>

<p>计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。</p>

<p>tar使用格式 tar [参数] 打包文件名 文件</p>

<p>tar命令很特殊，其参数前面可以使用“-”，也可以不使用。</p>

<p>常用参数：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td>
</tr>
<tr>
<td style="text-align: left">-t</td>
<td>列出档案中包含的文件</td>
</tr>
<tr>
<td style="text-align: left">-x</td>
<td>解开档案文件</td>
</tr>
</tbody>
</table>

<p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p>

<h3 id="toc_18">文件压缩解压：gzip</h3>

<p>tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。</p>

<p>gzip使用格式如下：</p>

<pre><code>gzip  [选项]  被压缩文件

</code></pre>

<p>常用选项：</p>

<p>|选项|含义| |-d|解压| |-r|压缩所有子目录|</p>

<p><strong>这里缺图</strong></p>

<p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p>

<p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 &hellip;</p>

<pre><code>-z ：指定压缩包的格式为：file.tar.gz

</code></pre>

<p>例如： tar zcvf test.tar.gz 1.c 2.c 3.c 4.c把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz<br/>
<strong>这里缺图</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 常用基本命令]]></title>
    <link href="http://www.citynight.cn/Blog/14954518367171.html"/>
    <updated>2017-05-22T19:17:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954518367171.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.命令使用方法</h2>

<p>Linux命令格式:</p>

<pre><code>    command  [-options]  [parameter1]  …
</code></pre>

<p>说明：</p>

<ul>
<li>command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，<code>[]代表可选</code> parameter1 …：传给命令的参数：可以是零个一个或多个</li>
</ul>

<p>例：</p>

<p><img src="media/14954518367171/14954519660499.jpg" alt=""/></p>

<h2 id="toc_1">2.查看帮助文档</h2>

<h3 id="toc_2"><1> &ndash;help</h3>

<p>一般是linux命令自带的帮助信息</p>

<p>如：ls &ndash;help</p>

<h3 id="toc_3"><2> man(有问题找男人，manual)</h3>

<p>man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明</p>

<p>该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>

<p>例：man ls ; man 2 printf</p>

<p>man中各个section意义如下：</p>

<ol>
<li>Standard commands（标准命令）</li>
<li>System calls（系统调用，如open,write）</li>
<li>Library functions（库函数，如printf,fopen）</li>
<li>Special devices（设备文件的说明，/dev下各种设备）</li>
<li>File formats（文件格式，如passwd）</li>
<li>Games and toys（游戏和娱乐）</li>
<li>Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</li>
<li>Administrative Commands（管理员命令，如ifconfig）</li>
</ol>

<p>man是按照手册的章节号的顺序进行搜索的。</p>

<p>man设置了如下的功能键：</p>

<table>
<thead>
<tr>
<th style="text-align: center">功能键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td style="text-align: center">Enter键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td style="text-align: center">f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td style="text-align: center">q</td>
<td>退出man命令</td>
</tr>
<tr>
<td style="text-align: center">h</td>
<td>列出所有功能键</td>
</tr>
<tr>
<td style="text-align: center">/word</td>
<td>搜索word字符串</td>
</tr>
</tbody>
</table>

<p><img src="media/14954518367171/14954525011190.jpg" alt=""/></p>

<p>注意：实际上，我们不用指定第几个章节也用查看，如，man ls</p>

<h2 id="toc_4">3.自动补全：</h2>

<p>在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>

<h2 id="toc_5">4.历史命令：</h2>

<p>当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 文件和目录]]></title>
    <link href="http://www.citynight.cn/Blog/14954377078014.html"/>
    <updated>2017-05-22T15:21:47+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954377078014.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类Unix系统目录结构</h2>

<p>ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面</p>

<p><img src="media/14954377078014/14954378312055.jpg" alt=""/></p>

<h2 id="toc_1">Linux 目录</h2>

<ul>
<li>/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</li>
<li>/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。</li>
<li>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</li>
<li>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</li>
<li>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。</li>
<li>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</li>
<li>/opt：给主机额外安装软件所摆放的目录。</li>
<li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</li>
<li>/root：系统管理员root的家目录。</li>
<li>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li>
<li>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</li>
<li>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。</li>
<li>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。</li>
</ul>

<h2 id="toc_2">用户目录</h2>

<p>位于/home/user，称之为用户工作目录或家目录,表示方式：</p>

<pre><code>/home/user
~

</code></pre>

<h3 id="toc_3">相对路径和绝对路径</h3>

<h4 id="toc_4">绝对路径</h4>

<p>从/目录开始描述的路径为绝对路径，如：</p>

<pre><code>cd /home
ls /usr

</code></pre>

<h4 id="toc_5">相对路径</h4>

<p>从当前位置开始描述的路径为相对路径，如：</p>

<pre><code>cd ../../
ls abc/def

</code></pre>

<h4 id="toc_6">.和..</h4>

<p>每个目录下都有.和..</p>

<p>. 表示当前目录</p>

<p>.. 表示上一级目录，即父目录</p>

<p>根目录下的.和..都表示当前目录</p>

<h2 id="toc_7">文件权限</h2>

<p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p>

<p>Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>

<p>在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>

<h3 id="toc_8">访问用户</h3>

<p>通过设定权限可以从以下三种访问方式限制访问权限：</p>

<ul>
<li><p>只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。</p></li>
<li><p>允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。</p></li>
<li><p>允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类</p></li>
</ul>

<p>这有点类似于 QQ 空间的访问权限：<br/>
<img src="media/14954377078014/14954384555256.jpg" alt=""/></p>

<ul>
<li>这个 QQ 空间是属于我的，我相当于管理者（也就是“所有者”），我想怎么访问就怎么访问。</li>
<li>同时，我可以设置允许 QQ 好友访问，而这些 QQ 好友则类似于“用户组”。</li>
<li>当然，我可以允许所有人访问，这里的所有人则类似于“其他用户”。</li>
</ul>

<h3 id="toc_9">访问权限</h3>

<p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p>

<ul>
<li>读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</li>
<li>写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</li>
</ul>

<p>注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>

<h3 id="toc_10">示例说明</h3>

<p><img src="media/14954377078014/14954394260837.jpg" alt=""/><br/>
(图中  用户改为 用户组)</p>

<p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。</p>

<p>每一个用户都有它自身的读、写和执行权限。</p>

<ul>
<li>第一组权限控制访问自己的文件权限，即所有者权限。</li>
<li>第二组权限控制用户组访问其中一个用户的文件的权限。</li>
<li>第三组权限控制其他所有用户访问一个用户的文件的权限。</li>
</ul>

<p>这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目优化记录]]></title>
    <link href="http://www.citynight.cn/Blog/14919624884376.html"/>
    <updated>2017-04-12T10:01:28+08:00</updated>
    <id>http://www.citynight.cn/Blog/14919624884376.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">首页显示</h2>

<p>重点: 数据处理放在获取数据的时候,尽管这样数据不会实时更新,但是保证了数据显示的速度.<br/>
关于Cache, 目前使用数据库.关于异步访问要用 <code>safeAsync</code></p>

<pre><code>extension DispatchQueue {
    // This method will dispatch the `block` to self.
    // If `self` is the main queue, and current thread is main thread, the block
    // will be invoked immediately instead of being dispatched.
    func safeAsync(_ block: @escaping ()-&gt;()) {
        if self === DispatchQueue.main &amp;&amp; Thread.isMainThread {
            block()
        } else {
            async { block() }
        }
    }
}
</code></pre>

<h2 id="toc_1">Topbar 移除</h2>

<p>这个原有的导航对项目入侵太深,已经忍无可忍了&hellip;这周终于下决心移除它用原生的导航栏和自定义视图代替她..进展非常顺利.写了一天自定义控件,然后让大家各自把自己的控制过滤一遍.总耗时,我自己一天,其他同事不到1个小时.还是非常顺利的.用比较少的时间完成了项目中的毒瘤.</p>

<h2 id="toc_2">下拉刷新封装</h2>

<p>老版本使用的是<code>MJRefresh</code> 但是需要定制, 在老项目中我是通过继承完成的功能修改,这样做的原因是老项目是OC和Swift混编的,而且都是把第三方库源文件拖到项目中的方式进行的. 在重构的时候我把第三方库放到了公司的git上,然后更改源码.再打包成成库调用.</p>

<h2 id="toc_3">关于时间比较</h2>

<p>新项目中存在一个功能比如 <code>10:00:00</code> 到 <code>11:59:59</code> 算早市,需要判断当前时间是否是早市. 一种更方便的处理方式:</p>

<p>时间格式 <code>HH:mm:ss</code> 一共6位数字,我们可以去掉中间的<code>:</code>,这样时间就是一个整数了,然后三个整数之间进行比较比 先比小时再比分钟最后比秒数要方便很多.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 关于信号量]]></title>
    <link href="http://www.citynight.cn/Blog/14916349354566.html"/>
    <updated>2017-04-08T15:02:15+08:00</updated>
    <id>http://www.citynight.cn/Blog/14916349354566.html</id>
    <content type="html"><![CDATA[
<p>信号量的使用</p>

<p><img src="media/14916349354566/%E4%BF%A1%E5%8F%B7%E9%87%8F.gif" alt="信号量"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 读书笔记]]></title>
    <link href="http://www.citynight.cn/Blog/14907835920803.html"/>
    <updated>2017-03-29T18:33:12+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907835920803.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">单一职责原则(Single Responsibility Principe 简称SRP)</h2>

<blockquote>
<p>定义: 应该有且仅有一个原因引起类的变更.. </p>
</blockquote>

<h3 id="toc_1">对职责的定义,什么是类的职责,以及怎么划分类的职责.</h3>

<p>图书中 &lt;图1-1用户信息IUserInfo位图类图&gt; 中设计的有问题:<br/>
用户的属性和用户的行为没有分开,这是一个严重的错误.. 应该把用户的信息抽取成一个BO(Bussiness Object,业务对象),把行为抽取成一个Biz(Bussiness Logic,业务逻辑)</p>

<p>重新拆封成两个接口. IUserBO 负责用户的属性,简单的说就是收集和反馈用户的属性信息.IUserBiz负责用户的行为,完成用户信息的维护和变更.</p>

<h3 id="toc_2">好处</h3>

<ol>
<li>类的复杂性降低.实现什么职责都有清晰明确的定义了;</li>
<li>可读性提高.复杂性降低,当然可读性提高了;</li>
<li>可维护性提高.可读性提高,那当然更容易维护了;</li>
<li>变更引起的风险降低,变更时必不可少的.如果接口的单一职责做的好,一个接口的修改只对相应的实现类有影响,对其他的接口无影响,这对系统的扩展性和维护性都有非常大的帮助.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac zsh 使用命令打开sublime]]></title>
    <link href="http://www.citynight.cn/Blog/14907559721950.html"/>
    <updated>2017-03-29T10:52:52+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907559721950.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1/添加</h2>

<p><code>vim .zshrc</code></p>

<p>添加 <br/>
 <code>alias subl=&quot;open -a Sublime\ Text&quot;</code>（如果你是Sublime Text ）<br/>
  或者<br/>
<code>alias subl=&quot;open -a Sublime\ Text\ 2&quot;</code> （如果你是Sublime Text 2）</p>

<h2 id="toc_1">2/生效</h2>

<p><code>source ~/.zshrc</code></p>

<h2 id="toc_2">3/测试</h2>

<p>在命令行输入：<br/>
    <code>subl</code>     就可以打开sublime</p>

<p>输入：<br/>
    <code>subl test.txt</code> 就可以打开文件</p>

]]></content>
  </entry>
  
</feed>
