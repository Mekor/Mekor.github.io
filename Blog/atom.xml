<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2018-07-26T15:07:31+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[控制器透明，WebView透明]]></title>
    <link href="http://www.citynight.cn/Blog/15323970557540.html"/>
    <updated>2018-07-24T09:50:55+08:00</updated>
    <id>http://www.citynight.cn/Blog/15323970557540.html</id>
    <content type="html"><![CDATA[
<p>设置控制器透明</p>

<pre><code class="language-text">let vc = AfterOrderPotADViewController()
self.definesPresentationContext = true
vc.modalPresentationStyle = .overCurrentContext
vc.view.backgroundColor = UIColor(red: 0, green: 0, blue: 0, alpha: 0.3)
self.present(vc, animated: false, completion: nil)
</code></pre>

<p>webView 设置透明</p>

<pre><code class="language-text">webView.backgroundColor = UIColor.clear
webView.isOpaque = false
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法总结]]></title>
    <link href="http://www.citynight.cn/Blog/15323249439841.html"/>
    <updated>2018-07-23T13:49:03+08:00</updated>
    <id>http://www.citynight.cn/Blog/15323249439841.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Fibonacci （斐波那契数列实现）</h2>

<pre><code class="language-text">///Fibonacci （斐波那契数列实现）
func fibonacci(_ n: Int) -&gt; Int{
    let result = [0,1]
    if n &lt; 2 {
        return result[n]
    }
    
    var fibNMinusOne = 1
    var fibNMinusTwo = 0
    var fibN = 0
    
    for _ in 2...n {
        fibN = fibNMinusOne + fibNMinusTwo
        fibNMinusTwo = fibNMinusOne
        fibNMinusOne = fibN
    }
    return fibN
}
</code></pre>

<h2 id="toc_1">BinarySearch (二分查找)</h2>

<h3 id="toc_2">非递归</h3>

<pre><code class="language-text">func binarySearch&lt;T: Comparable&gt;(_ a:[T], key: T) -&gt; Int {
    print(key)
    var lowerBound = 0
    var upperBound = a.count
    while lowerBound &lt; upperBound {

        let midIndex = lowerBound + (upperBound - lowerBound)/2

        if a[midIndex] == key {
            return midIndex
        }else if a[midIndex] &lt; key {
            lowerBound = midIndex + 1
        }else {
            upperBound = midIndex
        }
    }
    return -1
}
</code></pre>

<h3 id="toc_3">递归</h3>

<pre><code class="language-text">func binarySearch&lt;T : Comparable&gt;(startIndex: Int, endIndex: Int , arr:[T], key: T) -&gt; Int{
    let mind = startIndex + (endIndex - startIndex) / 2
    let mindValue = arr[mind]
    if mindValue == key {
        return mind
    }
    if mindValue &lt; key {
        return binarySearch(startIndex: mind + 1, endIndex: endIndex, arr: arr, key: key)
    } else if mindValue &gt; key {
        return binarySearch(startIndex: 0, endIndex: mind, arr: arr, key: key)
    }
    return -1
}
</code></pre>

<h2 id="toc_4">快速排序</h2>

<pre><code class="language-text">func quicksort&lt;T: Comparable&gt;(_ unsort:[T]) -&gt; [T] {
    guard unsort.count &gt; 1 else {
        return unsort
    }
    
    let pivot = unsort[unsort.count / 2]
    let less = unsort.filter { $0 &lt; pivot }
    let equal = unsort.filter { $0 == pivot }
    let greater = unsort.filter { $0 &gt; pivot }
    
    return quicksort(less) + equal + quicksort(greater)
}
</code></pre>

<p>测试结果</p>

<pre><code class="language-text">let list = [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]

print(list)
print(quicksort(list))
--------------------
[10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26]
[-1, 0, 1, 2, 3, 5, 8, 8, 9, 10, 14, 26, 27]

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决UILabel 末尾的空格被忽略]]></title>
    <link href="http://www.citynight.cn/Blog/15319018166027.html"/>
    <updated>2018-07-18T16:16:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/15319018166027.html</id>
    <content type="html"><![CDATA[
<p>看到这篇文章<a href="https://www.lidaren.com/archives/1333">UILabel取消自动Trim空格和换行等空白字符</a></p>

<pre><code class="language-text">UILabel会自动清除的空白字符（UNICODE）
\u0009 CHARACTER TABULATION
\u000A LINE FEED
\u000D CARRIAGE RETURN
\u0020 SPACE
\u0085 NEXT LINE
\u00A0 NBSP
\u1680 OGHAM SPACE MARK
\u180E MONGOLIAN VOWEL SEPARATOR
\u2000 EN QUAD
\u200A HAIR SPACE
\u200B ZERO WIDTH SPACE
\u2028 LINE SEPARATOR
\u2029 PARAGRAPH SEPARATOR
\u202F NARROW NO-BREAK SPACE
\u205F MEDIUM MATHEMATICAL SPACE
\u3000 IDEOGRAPHIC SPACE
</code></pre>

<p>解决方案</p>

<pre><code class="language-text">    let paragraphStyle = NSMutableParagraphStyle()
    paragraphStyle.alignment = .right
    paragraphStyle.tailIndent = -10
    let myMutableString = NSMutableAttributedString(
        string: text,
        attributes: [
            NSAttributedStringKey.font: UIFont.systemFont(ofSize: 16),
            NSAttributedStringKey.paragraphStyle: paragraphStyle
        ]
    )
    label.attributedText = myMutableString
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片加载方式]]></title>
    <link href="http://www.citynight.cn/Blog/15299939008214.html"/>
    <updated>2018-06-26T14:18:20+08:00</updated>
    <id>http://www.citynight.cn/Blog/15299939008214.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15299939008214/15299939112098.jpg" alt=""/><br/>
<img src="media/15299939008214/15299939172785.jpg" alt=""/></p>

<p>图像的降采样</p>

<p>不要使用昂贵的UIImage：UIImage会解压原始的图片占用大量的内存<br/>
内部的坐标变换也非常昂贵</p>

<p>使用ImageIO的CGImageSourceCreateThumbnailAtIndex API: 无视原始图片尺寸，resize的内存开销只是目标尺寸（请看Session中后半部分的Demo）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[金额显示]]></title>
    <link href="http://www.citynight.cn/Blog/15271249936113.html"/>
    <updated>2018-05-24T09:23:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/15271249936113.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">//初始化NumberFormatter
let format = NumberFormatter()
//设置numberStyle（有多种格式）
format.numberStyle = .decimal
//转换后的string
let string = format.string(from: NSNumber(value: 1234567.89))
//打印
print(string)  //1,234,567.89

//显示样式和输出样式
numberStyle:
public enum Style : UInt {  

        case none //1234567.89

        case decimal //1,234,567.89

        case currency //￥1,234,567.89

        case percent //123,456,789%

        case scientific //1.23456789E6

        case spellOut //一百二十三万四千五百六十七点八九

        @available(iOS 9.0, *)
        case ordinal //第123,4568

        @available(iOS 9.0, *)
        case currencyISOCode //CNY1,234,567.89

        @available(iOS 9.0, *)
        case currencyPlural//1,234,567.89人民币

        @available(iOS 9.0, *)
        case currencyAccounting//￥1,234,567.89
    }

//输入123456789分别输出
// 123456789
// 123,456,789
//￥123,456,789.00
//12345678900%
//1.23456789E8
//一亿二千三百四十五万六千七百八十九
//第1,2345,6789
//CNY123,456,789.00
//123,456,789.00人民币
//￥123,456,789.00
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程需要注意的问题]]></title>
    <link href="http://www.citynight.cn/Blog/15257017136249.html"/>
    <updated>2018-05-07T22:01:53+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257017136249.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">死锁（Dead Lock）</h2>

<p>第一种情况：</p>

<pre><code class="language-text">let serialQueue = DispatchQueue(label:&quot;test&quot;)
serialQueue.async {
    //.....
    serialQueue.sync {
        //...
    }
}

</code></pre>

<p>第二种情况：</p>

<pre><code class="language-text">let operationA = Operation()
let operationB = Operation()
operationA.addDependency(operationB)
operationB.addDependency(operationA)

</code></pre>

<p>怎样避免死锁：</p>

<ol>
<li>少用依赖</li>
<li>慎用同步</li>
</ol>

<h2 id="toc_1">优先倒置（Priority Inversion）</h2>

<pre><code class="language-text">var highPriorityQueue = DispatchQueue.global(qos: .userInitiated)
var lowPriorityQueue = DispatchQueue.global(qos: .utility)

let semaphore = DispatchSemaphore(value: 1)

lowPriorityQueue.async {
    semaphore.wait()
    for i in 0...10 {
        print(i)
    }
    semaphore.signal()
}

highPriorityQueue.async {
    semaphore.wait()
    for i in 11...20 {
        print(1)
    }
}

</code></pre>

<p>解决办法：<br/>
同一个资源用同一个Qos</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 应用图标没有在launchpad里显示]]></title>
    <link href="http://www.citynight.cn/Blog/15257016488742.html"/>
    <updated>2018-05-07T22:00:48+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257016488742.html</id>
    <content type="html"><![CDATA[
<p>重置Launchpad</p>

<pre><code class="language-text">rm ~/Library/Application\ Support/Dock/*.db

</code></pre>

<pre><code class="language-text">killall Dock
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Carthage 不能正常更新]]></title>
    <link href="http://www.citynight.cn/Blog/15257016195473.html"/>
    <updated>2018-05-07T22:00:19+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257016195473.html</id>
    <content type="html"><![CDATA[
<p>报错</p>

<pre><code class="language-text">➜  PersonalMusic git:(master) carthage update
*** Cloning GCDWebServer
A shell task (/usr/bin/env git clone --bare --quiet https://github.com/swisspol/GCDWebServer.git /Users/lixzzzzzz/Library/Caches/org.carthage.CarthageKit/dependencies/GCDWebServer) failed with exit code 128:
fatal: unable to access &#39;https://github.com/swisspol/GCDWebServer.git/&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443

</code></pre>

<p>解决办法：</p>

<p>清缓存</p>

<pre><code class="language-text">rm -rf ~/Library/Caches/org.carthage.CarthageKit
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置placeholder颜色]]></title>
    <link href="http://www.citynight.cn/Blog/15257015417604.html"/>
    <updated>2018-05-07T21:59:01+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257015417604.html</id>
    <content type="html"><![CDATA[
<p>从前设置颜色可能是这样的：</p>

<pre><code class="language-text">self.textField.setValue(UIColor.white, forKeyPath: &quot;_placeholderLabel.textColor&quot;)

</code></pre>

<p>今天发现，居然有一个属性可以设置：</p>

<pre><code class="language-text">self.textField.attributedPlaceholder =
            NSAttributedString(string: &quot;自定义金额&quot;,
                               attributes:
                [NSAttributedStringKey.foregroundColor: UIColor.white]
        )

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[懒加载的另一种写法]]></title>
    <link href="http://www.citynight.cn/Blog/15257015215231.html"/>
    <updated>2018-05-07T21:58:41+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257015215231.html</id>
    <content type="html"><![CDATA[
<p>原先我一直这样写：</p>

<pre><code class="language-text">    private lazy var imageView: UIImageView = {
        let imageView = UIImageView(image: UIImage(named: &quot;placeholder&quot;))
        imageView.contentMode = .center
        return imageView
    }()

</code></pre>

<p>今天看到了另一种比较简洁的写法</p>

<pre><code class="language-text">private lazy var imageView: UIImageView = {
        $0.contentMode = .center
        return $0
    }(UIImageView())

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cell点击时多次Push]]></title>
    <link href="http://www.citynight.cn/Blog/15257014756710.html"/>
    <updated>2018-05-07T21:57:55+08:00</updated>
    <id>http://www.citynight.cn/Blog/15257014756710.html</id>
    <content type="html"><![CDATA[
<p><a href="https://stackoverflow.com/questions/5687991/uitableview-didselectrowatindexpath-called-twice">stackoverflow上面的解决方案</a></p>

<pre><code class="language-text">func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {

    tableView.deselectRowAtIndexPath(indexPath, animated: true)

    if let navigationController = navigationController {
        guard navigationController.topViewController == self else {
            return
        }
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[防止Timer 与控制器耦合导致控制器不释放]]></title>
    <link href="http://www.citynight.cn/Blog/15180682554389.html"/>
    <updated>2018-02-08T13:37:35+08:00</updated>
    <id>http://www.citynight.cn/Blog/15180682554389.html</id>
    <content type="html"><![CDATA[
<p>在<code>OC</code>中可以使用<code>NSProxy</code> 的转发机制防止timer强引用<br/>
具体例子可以参考<a href="https://github.com/ibireme/YYKit/blob/3869686e0e560db0b27a7140188fad771e271508/YYKit/Utility/YYWeakProxy.h">YYKit</a>中的处理方式,代码如下：</p>

<pre><code class="language-text">#import &quot;YYWeakProxy.h&quot;


@implementation YYWeakProxy

- (instancetype)initWithTarget:(id)target {
    _target = target;
    return self;
}

+ (instancetype)proxyWithTarget:(id)target {
    return [[YYWeakProxy alloc] initWithTarget:target];
}

- (id)forwardingTargetForSelector:(SEL)selector {
    return _target;
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    void *null = NULL;
    [invocation setReturnValue:&amp;null];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
    return [NSObject instanceMethodSignatureForSelector:@selector(init)];
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return [_target respondsToSelector:aSelector];
}

- (BOOL)isEqual:(id)object {
    return [_target isEqual:object];
}

- (NSUInteger)hash {
    return [_target hash];
}

- (Class)superclass {
    return [_target superclass];
}

- (Class)class {
    return [_target class];
}

- (BOOL)isKindOfClass:(Class)aClass {
    return [_target isKindOfClass:aClass];
}

- (BOOL)isMemberOfClass:(Class)aClass {
    return [_target isMemberOfClass:aClass];
}

- (BOOL)conformsToProtocol:(Protocol *)aProtocol {
    return [_target conformsToProtocol:aProtocol];
}

- (BOOL)isProxy {
    return YES;
}

- (NSString *)description {
    return [_target description];
}

- (NSString *)debugDescription {
    return [_target debugDescription];
}
</code></pre>

<p>在Swift中怎么处理？王巍的<a href="https://gist.github.com/onevcat/2d1ceff1c657591eebde">Gist</a>中写了一种</p>

<pre><code class="language-text">private class Block&lt;T&gt; {
    let f : T
    init (_ f: T) { self.f = f }
}

extension NSTimer {
    static func xxx_scheduledTimerWithTimeInterval(ti: NSTimeInterval, block: ()-&gt;(), repeats: Bool) -&gt; NSTimer {
        return self.scheduledTimerWithTimeInterval(ti, target:
            self, selector: &quot;xxx_blcokInvoke:&quot;, userInfo: Block(block), repeats: repeats)
    }
    
    static func xxx_blcokInvoke(timer: NSTimer) {
        if let block = timer.userInfo as? Block&lt;()-&gt;()&gt; {
            block.f()
        }
    }
}
</code></pre>

<p>当然还有其他的方式比如：<a href="https://stackoverflow.com/questions/44096793/how-to-set-cadisplaylink-in-swift-with-weak-reference-between-target-and-cadispl">How to set CADisplayLink in Swift with weak reference between target and CADisplayLink instance<br/>
</a> 等等。。。</p>

<p>目前公司项目中采用的方式如下：</p>

<pre><code class="language-text">class WeakTimer: NSObject {
    
    private weak var target: NSObject?
    private weak var timer: Timer?
    private var selector: Selector
    
    private var userInfo: Any?
    
    init(withTimeInterval ti: TimeInterval, target aTarget: NSObject, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) {
        self.target = aTarget
        self.selector = aSelector
        self.userInfo = userInfo
        super.init()
        timer = Timer.scheduledTimer(timeInterval: ti, target: self, selector: #selector(test), userInfo: userInfo, repeats: yesOrNo)
    }
    
    @objc private func test() {
        target?.perform(selector, with: self.userInfo, afterDelay: 0)
    }
    
    open class func scheduledTimer(timeInterval ti: TimeInterval, target aTarget: NSObject, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) -&gt; WeakTimer {
        let weakTimer = WeakTimer(withTimeInterval: ti, target: aTarget, selector: aSelector, userInfo: userInfo, repeats: yesOrNo)
        
        return weakTimer
    }
    
    open func invalidate() {
        timer?.invalidate()
    }
}
</code></pre>

<p>应用</p>

<pre><code class="language-text">    @objc private func dismissSelf() {
        self.weakTimer?.invalidate()
        self.weakTimer = nil
        // HHTSwitchGlobalData.shared.waiterLoginTimeOut
        self.weakTimer = WeakTimer.scheduledTimer(timeInterval: HHTSwitchGlobalData.shared.waiterLoginTimeOut, target: self, selector: #selector(autoDismiss), userInfo: nil, repeats: true)
    }
</code></pre>

<p>第三方库 Kingfisher 中的处理办法</p>

<pre><code class="language-text">    /// Proxy object for prevending a reference cycle between the CADDisplayLink and AnimatedImageView.
    class TargetProxy {
        private weak var target: AnimatedImageView?
        
        init(target: AnimatedImageView) {
            self.target = target
        }
        
        @objc func onScreenUpdate() {
            target?.updateFrame()
        }
    }
</code></pre>

<p>应用:</p>

<pre><code class="language-text">private lazy var displayLink: CADisplayLink = {
        self.isDisplayLinkInitialized = true
        let displayLink = CADisplayLink(target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate))
        displayLink.add(to: .main, forMode: self.runLoopMode)
        displayLink.isPaused = true
        return displayLink
    }()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[显示中划线,下划线]]></title>
    <link href="http://www.citynight.cn/Blog/15166722537296.html"/>
    <updated>2018-01-23T09:50:53+08:00</updated>
    <id>http://www.citynight.cn/Blog/15166722537296.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">OC中显示</h3>

<h5 id="toc_1">添加中划线:</h5>

<pre><code class="language-text">  UILabel * strikeLabel = [[UILabel alloc] initWithFrame:(CGRectMake(10, 10, 50, 30))];
  NSString *textStr = [NSString stringWithFormat:@&quot;%@元&quot;, primeCost];

  //中划线
  NSDictionary *attribtDic = @{NSStrikethroughStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle]};
  NSMutableAttributedString *attribtStr = [[NSMutableAttributedString alloc]initWithString:textStr attributes:attribtDic];

  // 赋值
  strikeLabel.attributedText = attribtStr;

  [self.view addSubview:strikeLabel];
</code></pre>

<h5 id="toc_2">添加下划线:</h5>

<pre><code class="language-text">  UILabel *underlineLabel = [[UILabel alloc] initWithFrame:(CGRectMake(10, 10, 50, 30))];
  NSString *textStr = [NSString stringWithFormat:@&quot;%@元&quot;, primeCost];

  // 下划线
  NSDictionary *attribtDic = @{NSUnderlineStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle]};
  NSMutableAttributedString *attribtStr = [[NSMutableAttributedString alloc]initWithString:textStr attributes:attribtDic];

  //赋值
  underlineLabel.attributedText = attribtStr;

  [self.view addSubview:underlineLabel];
</code></pre>

<h3 id="toc_3">Swift中显示</h3>

<pre><code class="language-text">let myAttributes: [NSAttributedStringKey : Any] = [NSAttributedStringKey.strikethroughStyle: NSUnderlineStyle.styleSingle.rawValue]
            
let attributedText = NSAttributedString(string: &quot;被划线文字&quot;, attributes: myAttributes)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftTips - 集中处理]]></title>
    <link href="http://www.citynight.cn/Blog/15158138774013.html"/>
    <updated>2018-01-13T11:24:37+08:00</updated>
    <id>http://www.citynight.cn/Blog/15158138774013.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">集中处理@objc</h2>

<p><img src="media/15158138774013/WX20180113-112401@2x.png" alt="WX20180113-112401@2x"/></p>

<h2 id="toc_1">模拟器不能执行的代码单独处理</h2>

<p><img src="media/15158138774013/15159872783257.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企业证书需要]]></title>
    <link href="http://www.citynight.cn/Blog/15132354899270.html"/>
    <updated>2017-12-14T15:11:29+08:00</updated>
    <id>http://www.citynight.cn/Blog/15132354899270.html</id>
    <content type="html"><![CDATA[
<ol>
<li>邓白氏码  不清楚公司是否申请过,如果没有申请过可能需要半个月左右时间(最快1周)</li>
<li>申请企业证书, 现在苹果对国内企业证书申请比较严格最快1周可能需要半个月甚至更久(美国快过圣诞节和元旦了)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Runloop 遇到的问题]]></title>
    <link href="http://www.citynight.cn/Blog/15101967456310.html"/>
    <updated>2017-11-09T11:05:45+08:00</updated>
    <id>http://www.citynight.cn/Blog/15101967456310.html</id>
    <content type="html"><![CDATA[
<p>首先: <code>swift</code> 与 <code>C</code> 兼容不如 <code>OC</code> </p>

<ol>
<li>生成<code>CFRunLoopObserverContext</code>比<code>OC</code>艰难好多...</li>
</ol>

<pre><code class="language-text">func addRunloopObserver() {
        autoreleasepool {
            guard let runloop = CFRunLoopGetCurrent() else {return}
            let unmanaged = Unmanaged.passRetained(self)
            let uptr = unmanaged.toOpaque()
            let vptr = UnsafeMutableRawPointer(uptr)
            var content = CFRunLoopObserverContext(version: 0, info: vptr, retain: nil, release: nil, copyDescription: nil)
            guard let obserber = CFRunLoopObserverCreate(kCFAllocatorDefault, CFRunLoopActivity.beforeWaiting.rawValue, true, Int.max - 999, observerCallbackFunc(), &amp;content) else {return}
            CFRunLoopAddObserver(runloop, obserber, CFRunLoopMode.defaultMode)
        }
    }
</code></pre>

<p>注意 content ,真是比OC复杂啊</p>

<ol>
<li>强转也变了...</li>
</ol>

<pre><code class="language-text">func observerCallbackFunc() -&gt; CFRunLoopObserverCallBack {
        
        return {(observer, activity, context) -&gt; Void in
            guard let context = context else {
                return
            }
            let work = Unmanaged&lt;RunLoopWorker&gt;.fromOpaque(context).takeUnretainedValue()
            
            if work.tasks.count == 0 { return }
            var result = false
            while result == false &amp;&amp; work.tasks.count &gt; 0 {
                // 取出任务
                if let unit = work.tasks.first,unit.values.count &gt; 0 {
                    result = unit.values.first!()
                    work.tasks.removeFirst()
                }
            }
        }
    }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[collectionView自定义layout]]></title>
    <link href="http://www.citynight.cn/Blog/15096779127051.html"/>
    <updated>2017-11-03T10:58:32+08:00</updated>
    <id>http://www.citynight.cn/Blog/15096779127051.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>今天,YouTube推荐了一个自定义layout的视频( Custom Collection View Layouts in iOS),看了一下挺简单明了的,而且基本的操作都包含了. <br/>
<strong>视频地址:</strong> <a href="https://www.youtube.com/watch?v=DIxyCh55SqQ">Pinterest Basic Layout - Custom Collection View Layouts in iOS - raywenderlich.com</a><br/>
<strong>github地址:</strong> <a href="https://github.com/AZCoder2/Pinterest">Pinterest</a></p>
</blockquote>

<p>核心代码:</p>

<pre><code class="language-text">//
//  PinterestLayout.swift
//  Pinterest
//
//  Created by Tom Ranalli on 12/25/16.
//  Copyright © 2016 Razeware LLC. All rights reserved.
//

import UIKit

// MARK: - Protocols
protocol PinterestLayoutDelegate {
  
  // Request height of photo
  func collectionView(_ collectionView:UICollectionView, heightForPhotoAtIndexPath indexPath:NSIndexPath,
                      withWidth:CGFloat) -&gt; CGFloat
  
  // Request annotation for photo
  func collectionView(_ collectionView: UICollectionView,
                      heightForAnnotationAtIndexPath indexPath: NSIndexPath, withWidth width: CGFloat) -&gt; CGFloat
}

class PinterestLayoutAttributes: UICollectionViewLayoutAttributes {
  
  // This declares the photoHeight property that the cell will use to resize its image view
  var photoHeight: CGFloat = 0.0
  
  /* This overrides copy(_with:)
   
     Subclasses of UICollectionViewLayoutAttributes need to conform to the NSCopying protocol 
     because the attribute’s objects can be copied internally. You override this method to 
     guarantee that the photoHeight property is set when the object is copied.
  */
  
  override func copy(with zone: NSZone? = nil) -&gt; Any {
    let copy = super.copy(with: zone) as! PinterestLayoutAttributes
    copy.photoHeight = photoHeight
    return copy
  }
  
  /* This overrides isEqual(_:), and it’s mandatory as well.
 
     The collection view determines whether the attributes have changed by comparing the old 
     and new attribute objects using isEqual(_:). You must implement it to compare the custom
     properties of your subclass. The code compares the photoHeight of both instances, and
     if they are equal, calls super to determine if the inherited attributes are the same;
     if the photo heights are different, it returns false
  */

  override func isEqual(_ object: Any?) -&gt; Bool {
    if let attributes = object as? PinterestLayoutAttributes {
      if( attributes.photoHeight == photoHeight  ) {
        return super.isEqual(object)
      }
    }
    return false
  }
}

// MARK: - Class definition
class PinterestLayout: UICollectionViewLayout {
  
  // MARK: - Properties
  
  // Keep reference to the delegate
  var delegate: PinterestLayoutDelegate!
  
  // Configure number of columns and cell padding
  var numberOfColumns = 2
  var cellPadding: CGFloat = 6.0
  
  // This is an array to cache the calculated attributes. 
  
  /* When you call prepareLayout(), you’ll calculate the attributes for all items and add them to the cache. When the collection view later requests the layout attributes, you can be efficient and query the cache instead of recalculating them every time
  */
  
  private var cache = [PinterestLayoutAttributes]()
  
  // This declares two properties to store the content size.
  // contentHeight is incremented as photos are added
  private var contentHeight: CGFloat  = 0.0
  
  // contentWidth is calculated based on the collection view width and its content inset.
  private var contentWidth: CGFloat {
    let insets = collectionView!.contentInset
    return collectionView!.bounds.width - (insets.left + insets.right)
  }
  
  // Variable overrides
  
  /* This overrides collectionViewContentSize variable of the abstract parent class, and returns the size of the collection view’s contents. To do this, you use both contentWidth and contentHeight calculated in the previous steps.
  */
 
  override var collectionViewContentSize: CGSize {
    return CGSize(width: contentWidth, height: contentHeight)
  }
  
  /* This overrides layoutAttributesClass variable to tell the collection view to use PinterestLayoutAttributes whenever it creates layout attributes objects.
  */
  
  override class var layoutAttributesClass: AnyClass {
    return PinterestLayoutAttributes.self
  }
  
  // MARK: - Overrides
  
  override func prepare() {
    
    // Only calculate if cache is empty
    if cache.isEmpty {
      
      /*  This declares and fills the xOffset array with the x-coordinate for every column based on the column widths.
      */
      let columnWidth = contentWidth / CGFloat(numberOfColumns)
      
      var xOffset = [CGFloat]()
      
      for column in 0 ..&lt; numberOfColumns {
        xOffset.append(CGFloat(column) * columnWidth )
      }
      
      /*  The yOffset array tracks the y-position for every column. You initialize each value in yOffset to 0, since this is the offset of the first item in each column.
      */
      var column = 0
      var yOffset = [CGFloat](repeating: 0, count: numberOfColumns)
      
      // This loops through all the items in the first section, as this particular 
      // layout has only one section
      for item in 0 ..&lt; collectionView!.numberOfItems(inSection: 0) {
        
        let indexPath = NSIndexPath(item: item, section: 0)
        
        // This is where you perform the frame calculation
        // Width is the previously calculated cellWidth, with the padding between cells removed
        let width = columnWidth - cellPadding * 2
        
        // You ask the delegate for the height of the image
        let photoHeight = delegate.collectionView(collectionView!,
                                                  heightForPhotoAtIndexPath: indexPath,
                                                  withWidth:width)

        // You ask the delegate for the height of the annotation
        let annotationHeight = delegate.collectionView(collectionView!,
                                    heightForAnnotationAtIndexPath: indexPath,
                                    withWidth: width)
        
        // Calculate the frame height based on those heights and the predefined cellPadding 
        // for the top and bottom
        let height = cellPadding +  photoHeight + annotationHeight + cellPadding
        
        // Combine this with the x and y offsets of the current column to create the
        // insetFrame used by the attribute
        let frame = CGRect(x: xOffset[column], y: yOffset[column], width: columnWidth, height: height)
        let insetFrame = frame.insetBy(dx: cellPadding, dy: cellPadding)
        
        // This creates an instance of PinterestLayoutAttributes
        let attributes = PinterestLayoutAttributes(forCellWith: indexPath as IndexPath)
        attributes.photoHeight = photoHeight
        
        // Sets its frame using insetFrame
        attributes.frame = insetFrame
        
        // Append the attributes to cache
        cache.append(attributes)
        
        // This expands contentHeight to account for the frame of the newly calculated item
        contentHeight = max(contentHeight, frame.maxY)
        
        // It then advances the yOffset for the current column based on the frame
        yOffset[column] = yOffset[column] + height
        
        // Finally, it advances the column so that the next item will be placed in the next column.
        if column &gt;= numberOfColumns - 1 {
          column = 0
        } else {
          column = column + 1
        }
        
      }
    }
  }
  
  override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
    
    var layoutAttributes = [UICollectionViewLayoutAttributes]()
    
    //  Iterate through the attributes in cache and check if their frames intersect with rect
    for attributes in cache {
      if attributes.frame.intersects(rect) {
        layoutAttributes.append(attributes) // Add in any attributes for display
      }
    }
    return layoutAttributes
  }

}

</code></pre>

<p>比较有意思的一个计算高度方式:</p>

<pre><code class="language-text">  // This provides the height of the photos
  
  /* It uses AVMakeRectWithAspectRatioInsideRect() from AVFoundation to calculate a height that retains the photo’s aspect ratio, restricted to the cell’s width.
   */
  
  func collectionView(_ collectionView:UICollectionView,
                      heightForPhotoAtIndexPath indexPath: NSIndexPath,
                      withWidth width: CGFloat) -&gt; CGFloat {
    
    let photo = photos[indexPath.item]
    let boundingRect =  CGRect(x: 0, y: 0, width: width, height: CGFloat(MAXFLOAT))
    let rect  = AVMakeRect(aspectRatio: photo.image.size, insideRect: boundingRect)
    
    return rect.size.height
  }
</code></pre>

<p>图片解压:</p>

<pre><code class="language-text">extension UIImage {
  
  var decompressedImage: UIImage {
    UIGraphicsBeginImageContextWithOptions(size, true, 0)
    draw(at: CGPoint.zero)
    let decompressedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decompressedImage!
  }
  
}
</code></pre>

<p>一个从前没有用过的Api:</p>

<pre><code class="language-text">  /* 
   This code calls the super implementation to make sure that the standard attributes are applied. Then, it casts the attributes object into an instance of PinterestLayoutAttributes to obtain the photo height and then changes the image view height by setting the imageViewHeightLayoutConstraint constant value.
  */
  
  override func apply(_ layoutAttributes: UICollectionViewLayoutAttributes) {
    super.apply(layoutAttributes)
    
    if let attributes = layoutAttributes as? PinterestLayoutAttributes {
      imageViewHeightLayoutConstraint.constant = attributes.photoHeight
    }
  }
</code></pre>

<p>===========<mark>完</mark>=========</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]浅析 iOS 应用开发中的断点续传]]></title>
    <link href="http://www.citynight.cn/Blog/15060704391596.html"/>
    <updated>2017-09-22T16:53:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/15060704391596.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原贴地址<a href="https://www.ibm.com/developerworks/cn/mobile/mo-cn-breakpoint/index.html">IBM developerWorks</a></p>
</blockquote>

<h2 id="toc_0">断点续传概述</h2>

<p>断点续传就是从文件上次中断的地方开始重新下载或上传数据，而不是从文件开头。（本文的断点续传仅涉及下载，上传不在讨论之内）当下载大文件的时候，如果没有实现断点续传功能，那么每次出现异常或者用户主动的暂停，都会去重头下载，这样很浪费时间。所以项目中要实现大文件下载，断点续传功能就必不可少了。当然，断点续传有一种特殊的情况，就是 iOS 应用被用户 kill 掉或者应用 crash，要实现应用重启之后的断点续传。这种特殊情况是本文要解决的问题。</p>

<h2 id="toc_1">断点续传原理</h2>

<p>要实现断点续传 , 服务器必须支持。目前最常见的是两种方式：FTP 和 HTTP。下面来简单介绍 HTTP 断点续传的原理。</p>

<h3 id="toc_2">HTTP</h3>

<p>通过 HTTP，可以非常方便的实现断点续传。断点续传主要依赖于 HTTP 头部定义的 Range 来完成。具体 Range 的说明参见 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>中 14.35.2 节，在请求某范围内的资源时，可以更有效地对大资源发出请求或从传输错误中恢复下载。有了 Range，应用可以通过 HTTP 请求曾经获取失败的资源的某一个返回或者是部分，来恢复下载该资源。当然并不是所有的服务器都支持 Range，但大多数服务器是可以的。Range 是以字节计算的，请求的时候不必给出结尾字节数，因为请求方并不一定知道资源的大小。Range 的定义如图 1 所示：</p>

<h5 id="toc_3">图 1. HTTP-Range</h5>

<p><img src="media/15060704391596/image001.png" alt="HTTP-Range"/></p>

<p>图 2 展示了 HTTP request 的头部信息：</p>

<h5 id="toc_4">图 2. HTTP request 例子</h5>

<p><img src="media/15060704391596/image002.png" alt="HTTP request 例子"/></p>

<p>在上面的例子中的“Range: bytes=1208765-”表示请求资源开头 1208765 字节之后的部分。</p>

<p>图 3 展示了 HTTP response 的头部信息：</p>

<h5 id="toc_5">图 3. HTTP response 例子</h5>

<p><img src="media/15060704391596/image003.png" alt="HTTP response 例子"/></p>

<p>上面例子中的”Accept-Ranges: bytes”表示服务器端接受请求资源的某一个范围，并允许对指定资源进行字节类型访问。”Content-Range: bytes 1208765-20489997/20489998”说明了返回提供了请求资源所在的原始实体内的位置，还给出了整个资源的长度。这里需要注意的是 HTTP return code 是 206 而不是 200。</p>

<h2 id="toc_6">断点续传分析 -AFHTTPRequestOperation</h2>

<p>了解了断点续传的原理之后，我们就可以动手来实现 iOS 应用中的断点续传了。由于笔者项目的资源都是部署在 HTTP 服务器上 , 所以断点续传功能也是基于 HTTP 实现的。首先来看下第三方网络框架 AFNetworking 中提供的实现。清单 1 示例代码是用来实现断点续传部分的代码：</p>

<h5 id="toc_7">清单 1. 使用 AFHTTPRequestOperation 实现断点续传的代码</h5>

<pre><code class="language-text">// 1 指定下载文件地址 URLString 
// 2 获取保存的文件路径 filePath 
// 3 创建 NSURLRequest 
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:URLString]]; 
unsigned long long downloadedBytes = 0; 
 
if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) { 
// 3.1 若之前下载过 , 则在 HTTP 请求头部加入 Range 
   // 获取已下载文件的 size 
   downloadedBytes = [self fileSizeForPath:filePath]; 
        
   // 验证是否下载过文件
   if (downloadedBytes &gt; 0) { 
       // 若下载过 , 断点续传的时候修改 HTTP 头部部分的 Range 
       NSMutableURLRequest *mutableURLRequest = [request mutableCopy]; 
       NSString *requestRange = 
       [NSString stringWithFormat:@&quot;bytes=%llu-&quot;, downloadedBytes]; 
       [mutableURLRequest setValue:requestRange forHTTPHeaderField:@&quot;Range&quot;]; 
       request = mutableURLRequest; 
   } 
} 
 
// 4 创建 AFHTTPRequestOperation 
AFHTTPRequestOperation *operation 
 = [[AFHTTPRequestOperation alloc] initWithRequest:request]; 
 
// 5 设置操作输出流 , 保存在第 2 步的文件中
operation.outputStream = [NSOutputStream 
outputStreamToFileAtPath:filePath append:YES]; 
 
// 6 设置下载进度处理 block 
[operation setDownloadProgressBlock:^(NSUInteger bytesRead, 
long long totalBytesRead, long long totalBytesExpectedToRead) { 
// bytesRead 当前读取的字节数
// totalBytesRead 读取的总字节数 , 包含断点续传之前的
// totalBytesExpectedToRead 文件总大小
}]; 
 
// 7 设置 success 和 failure 处理 block 
[operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation 
*operation, id responseObject) { 
 
} failure:^(AFHTTPRequestOperation *operation, NSError *error) { 
 
}]; 
 
// 8 启动 operation 
[operation start];
</code></pre>

<p>使用以上代码 , 断点续传功能就实现了，应用重新启动或者出现异常情况下 , 都可以基于已经下载的部分开始继续下载。关键的地方就是把已经下载的数据持久化。接下来简单看下 AFHTTPRequestOperation 是怎么实现的。通过查看源码 , 我们发现 AFHTTPRequestOperation 继承自 AFURLConnectionOperation , 而 AFURLConnectionOperation 实现了 NSURLConnectionDataDelegate 协议。处理流程如图 4 所示：</p>

<h5 id="toc_8">图 4. AFURLHTTPrequestOperation 处理流程</h5>

<p><img src="media/15060704391596/image004.png" alt="AFURLHTTPrequestOperation 处理流程"/></p>

<p>这里 AFNetworking 为什么采取子线程调异步接口的方式 , 是因为直接在主线程调用异步接口 , 会有一个 Runloop 的问题。当主线程调用 [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES] 时 , 请求发出之后的监听任务会加入到主线程的 Runloop 中 ,RunloopMode 默认为 NSDefaultRunLoopMode, 这个表示只有当前线程的 Runloop 处理 NSDefaultRunLoopMode 时，这个任务才会被执行。而当用户在滚动 TableView 和 ScrollView 的时候，主线程的 Runloop 处于 NSEventTrackingRunLoop 模式下，就不会执行 NSDefaultRunLoopMode 的任务。</p>

<p>另外由于采取子线程调用接口的方式 , 所以这边的 DownloadProgressBlock,success 和 failure Block 都需要回到主线程来处理。</p>

<h2 id="toc_9">断点续传实战</h2>

<p>了解了原理和 AFHTTPRequestOperation 的例子之后 , 来看下实现断点续传的三种方式：</p>

<h3 id="toc_10">NSURLConnection</h3>

<p>基于 NSURLConnection 实现断点续传 , 关键是满足 NSURLConnectionDataDelegate 协议，主要实现了如下三个方法：</p>

<h5 id="toc_11">清单 2. NSURLConnection 的实现</h5>

<pre><code class="language-text">// SWIFT 
// 请求失败处理
func connection(connection: NSURLConnection, 
didFailWithError error: NSError) { 
   self.failureHandler(error: error) 
} 
 
// 接收到服务器响应是调用
func connection(connection: NSURLConnection, 
 didReceiveResponse response: NSURLResponse) { 
   if self.totalLength != 0 { 
       return 
   } 
 
   self.writeHandle = NSFileHandle(forWritingAtPath: 
   FileManager.instance.cacheFilePath(self.fileName!)) 
 
   self.totalLength = response.expectedContentLength + self.currentLength 
} 
 
// 当服务器返回实体数据是调用
func connection(connection: NSURLConnection, didReceiveData data: NSData) { 
   let length = data.length 
    
   // move to the end of file 
   self.writeHandle.seekToEndOfFile() 
    
   // write data to sanbox 
   self.writeHandle.writeData(data) 
    
   // calculate data length 
   self.currentLength = self.currentLength + length 
    
   print(&quot;currentLength\(self.currentLength)-totalLength\(self.totalLength)&quot;) 
    
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: length, totalBytes: 
       self.currentLength, totalBytesExpected: self.totalLength) 
   } 
} 
 
// 下载完毕后调用
func connectionDidFinishLoading(connection: NSURLConnection) { 
   self.currentLength = 0 
   self.totalLength = 0 
 
   //close write handle 
   self.writeHandle.closeFile() 
   self.writeHandle = nil 
 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
        
   do { 
       try FileManager.instance.moveItemAtPath(cacheFilePath, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
    
   self.successHandler(responseObject:fileName!) 
}
</code></pre>

<p>如图 5 所示 , 说明了 NSURLConnection 的一般处理流程。（代码详见下载包）</p>

<h5 id="toc_12">图 5. NSURLConnection 流程</h5>

<p><img src="media/15060704391596/image005.png" alt="NSURLConnection 流程"/></p>

<p>根据图 5 的一般流程，在 didReceiveResponse 中初始化 fileHandler, 在 didReceiveData 中 , 将接收到的数据持久化的文件中 , 在 connectionDidFinishLoading 中，清空数据和关闭 fileHandler，并将文件保存到 Document 目录下。所以当请求出现异常或应用被用户杀掉，都可以通过持久化的中间文件来断点续传。初始化 NSURLConnection 的时候要注意设置 scheduleInRunLoop 为 NSRunLoopCommonModes，不然就会出现进度条 UI 无法更新的现象。实现效果如图 6 所示：</p>

<h5 id="toc_13">图 6. NSURLConnection 演示</h5>

<p><img src="media/15060704391596/image006.gif" alt="NSURLConnection 演示"/></p>

<h3 id="toc_14">NSURLSessionDataTask</h3>

<p>苹果在 iOS7 开始，推出了一个新的类 NSURLSession, 它具备了 NSURLConnection 所具备的方法，并且更强大。由于通过 NSURLConnection 从 2015 年开始被弃用了，所以读者推荐基于 NSURLSession 去实现续传。NSURLConnection 和 NSURLSession delegate 方法的映射关系 , 如图 7 所示。所以关键是要满足 NSURLSessionDataDelegate 和 NSURLsessionTaskDelegate。</p>

<h5 id="toc_15">图 7. 协议之间映射关系</h5>

<p><img src="media/15060704391596/image007.png" alt="协议之间映射关系"/></p>

<p>代码如清单 3 所示 , 基本和 NSURLConnection 实现的一样。</p>

<h5 id="toc_16">清单 3. NSURLSessionDataTask 的实现</h5>

<pre><code class="language-text">// SWIFT 
// 接收数据
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
idReceiveData data: NSData) { 
   //. . . 
} 
// 接收服务器响应
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
didReceiveResponse response: NSURLResponse, completionHandler: 
 (NSURLSessionResponseDisposition) -&gt; Void) { 
   // . . . 
   completionHandler(.Allow) 
} 
 
// 请求完成
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
 didCompleteWithError error: NSError?) { 
   if error == nil { 
       // . . . 
       self.successHandler(responseObject:self.fileName!) 
   } else { 
       self.failureHandler(error:error!) 
   } 
}
</code></pre>

<p>区别在与 didComleteWithError, 它将 NSURLConnection 中的 connection:didFailWithError:</p>

<p>和 connectionDidFinishLoading: 整合到了一起 , 所以这边要根据 error 区分执行成功的 Block 和失败的 Block。实现效果如图 8 所示：</p>

<h5 id="toc_17">图 8. NSURLSessionDataTask 演示</h5>

<p><img src="media/15060704391596/image008.gif" alt="NSURLSessionDataTask 演示"/></p>

<h3 id="toc_18">NSURLSessionDownTask</h3>

<p>最后来看下 NSURLSession 中用来下载的类 NSURLSessionDownloadTask，对应的协议是 NSURLSessionDownloadDelegate，如图 9 所示：</p>

<h5 id="toc_19">图 9. NSURLSessionDownloadDelegate 协议</h5>

<p><img src="media/15060704391596/image009.png" alt="NSURLSessionDownloadDelegate 协议"/></p>

<p>其中在退出 didFinishDownloadingToURL 后，会自动删除 temp 目录下对应的文件。所以有关文件操作必须要在这个方法里面处理。之前笔者曾想找到这个 tmp 文件 , 基于这个文件做断点续传 , 无奈一直找不到这个文件的路径。等以后 SWIFT 公布 NSURLSession 的源码之后，兴许会有方法找到。基于 NSURLSessionDownloadTask 来实现的话 , 需要在 cancelByProducingResumeData 中保存已经下载的数据。进度通知就非常简单了，直接在 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite: 实现即可。代码如清单 4 所示：</p>

<h5 id="toc_20">清单 4. NSURLSessionDownloadTask 的实现</h5>

<pre><code class="language-text">//SWIFT 
 
//UI 触发 pause 
func pause(){ 
   self.downloadTask?.cancelByProducingResumeData({data -&gt; Void in 
       if data != nil { 
data!.writeToFile(FileManager.instance.cacheFilePath(self.fileName!), 
atomically: false) 
} 
       }) 
   self.downloadTask = nil 
} 
 
// MARK: - NSURLSessionDownloadDelegate 
func URLSession(session: NSURLSession, downloadTask: 
NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, 
totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) { 
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: Int(bytesWritten), 
        totalBytes: totalBytesWritten, totalBytesExpected: totalBytesExpectedToWrite) 
   } 
} 
 
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
didCompleteWithError error: NSError?) { 
   if error != nil {//real error 
       self.failureHandler(error:error!) 
   } 
} 
 
func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, 
 didFinishDownloadingToURL location: NSURL) { 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
   do { 
       if FileManager.instance.fileExistsAtPath(cacheFilePath){ 
           try FileManager.instance.removeItemAtPath(cacheFilePath) 
       } 
       try FileManager.instance.moveItemAtPath(location.path!, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
   self.successHandler(responseObject:documenFilePath) 
}
</code></pre>

<p>实现效果如图 10 所示：</p>

<h5 id="toc_21">图 10. NSURLSessionDownloadTask 演示</h5>

<p><img src="media/15060704391596/image010.gif" alt="NSURLSessionDownloadTask 演示"/></p>

<h2 id="toc_22">总结</h2>

<p>本文从断点续传概述开始，介绍了断点续传的应用背景，通过原理的描述，相信读者对断点续传有了基本的认识和理解。接着笔者介绍了通过 AFHTTPRequestOpeartion 实现的代码，并对 AFHTTPRequestOpeartion 做了简单的分析。最后笔者结合的实际需求，基于 NSURLConnection, NSURLSeesionDataTask 和 NSURLSessionDownloadtask。其实，下载的实现远不止这些内容，本文只介绍了简单的使用。希望在进一步的学习和应用中能继续与大家分享。</p>

<h4 id="toc_23">相关主题</h4>

<ul>
<li>参考 <a href="https://www.w3.org/Protocols/rfc959/4_FileTransfer.html">RFC959</a>，了解 FTP 协议文本的说明。</li>
<li>参考 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>，了解 HTTP 的说明。</li>
<li>参考 <a href="https://github.com/AFNetworking/AFNetworking/blob/2.x/AFNetworking/AFHTTPRequestOperation.m">AFHTTPRequestOperation</a>, 了解源码。</li>
<li>参考 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091">iOSDeveloperLibrary</a>，了解 Apple 官方文档对 NSURLConnection, NSURLSeesionDownloadTask 和 NSURLSeesionDataTask 的说明。</li>
<li>访问 developerWorks <a href="http://www.ibm.com/developerworks/cn/mobile/">Mobile 专区</a>，了解关于信息管理的更多信息，获取技术文档、how-to 文章、培训、下载、产品信息以及其他资源。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优化iPad 2 总结]]></title>
    <link href="http://www.citynight.cn/Blog/15058021769287.html"/>
    <updated>2017-09-19T14:22:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/15058021769287.html</id>
    <content type="html"><![CDATA[
<p>实施反馈项目在<code>iPad 2</code>上比较卡顿,所以要对项目进行优化.</p>

<h2 id="toc_0">优化集中点为collectionView</h2>

<p>项目有两种显示效果,一种是图片模式,一种是纯文字模式. 纯文字模式滑动起来还不错,图片模式就比较卡了.经分析,项目做了部分修改,使滑动效果比较顺畅.</p>

<ul>
<li>栅格化: 目的是离屏渲染,不过还是卡顿</li>
</ul>

<pre><code class="language-text">    self.layer.shouldRasterize = true
    self.layer.rasterizationScale = UIScreen.main.scale
    self.layer.drawsAsynchronously = true
</code></pre>

<ul>
<li>Color Blended Layers 处理
<img src="media/15058021769287/15058027400968.jpg" alt=""/>
发现部分UILabel存在问题,解决方案:
<img src="media/15058021769287/15058028256147.jpg" alt=""/></li>
</ul>

<p>添加 <code>label.layer.masksToBounds = true</code>,效果还是不行.</p>

<ul>
<li> 使用iOS最新的API<code>UICollectionViewDataSourcePrefetching</code></li>
</ul>

<pre><code class="language-text">extension DishesViewController: UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
        let urls = indexPaths.flatMap { (index) -&gt; URL? in
            let big = dishsArray[index.section]
            let key = big.keys.first!
            let small = big[key]!
            let item = small[index.item]
            return URL(string: item.dishModel.smallImageUrl)
        }
        
        ImagePrefetcher(urls: urls).start()
    }
}

</code></pre>

<ul>
<li>上面优化后效果不是很明显,最后采取了<strong>以空间换时间</strong>的方式优化图片列表页<br/>
提前用<code>Kingfisher</code>下载图片(这个过程原先就有)下载过图片也做了不再下载的处理,由于图片过多导致不会有太多列表页的图片缓存中内存中. 针对这个问题,我采用了每次进入app就把列表页的图片使用<code>NSCache&lt;NSString, UIImage&gt;</code>缓存起来,效果很明显.</li>
</ul>

<h2 id="toc_1">目前还存在问题</h2>

<p>下载图片失败率还是很高的,我设置的超时时间为60s <code>downloader.downloadTimeout = 60</code> 但是还是有很多图片下载超时,导致首次加载的时候需要下载图片滑动卡顿.<br/>
由于<code>NSCache</code>的特殊性,不能保证图片一直在内存中,正在考虑是否替换成Dictionary,然后自己处理内存警告.这个稍后验证下.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指针]]></title>
    <link href="http://www.citynight.cn/Blog/15052686192490.html"/>
    <updated>2017-09-13T10:10:19+08:00</updated>
    <id>http://www.citynight.cn/Blog/15052686192490.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. 指针是一种数据类型</h2>

<ol>
<li>指针也是一种变量,占有内存空间,用来保存内存地址  指针的大小--&gt; 32位: 4  64位: 8</li>
<li><p><code>*p</code> 操作内存</p>
<pre><code class="language-text">在指针声明时,`*`号表示所声明的变量为指针
在指针使用时,`*`号表示**操作**指针所指向的内存空间中的值<br/>
`*p`相当于通过地址(p变量的值)找到一块内存,然后操作内存<br/>
`*p`放在等号左边赋值(给内存赋值)<br/>
`*p`放在等号右边取值(从内存获取值)
</code></pre></li>
<li><p>指针变量和它指向的内存块是两个不同的概念</p>
<pre><code class="language-text">含义1: 给p赋值 p = 0x1111; 只会改变指针变量值,不会改变所指的内容; p = p+1
含义2: 给`*p`赋值 *p = &#39;a&#39;;不会改变指针变量的值,只会改变所指的内存块的值<br/>
保证所指向的内存空间能修改()<br/>
*就像一把钥匙,通过一个地址(&amp;a),去修改a变量的标示的内存空间
</code></pre></li>
<li><p>指针是一种数据类型,是指它指向的内存空间的数据类型</p>
<pre><code class="language-text">指针步长(p++),根据所指内存空间的数据类型类确定
p++ = ---&gt; p+sizeof(a)
</code></pre></li>
</ol>

]]></content>
  </entry>
  
</feed>
