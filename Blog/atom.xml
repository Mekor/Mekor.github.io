<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2016-12-21T20:52:38+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift - 全屏返回手势]]></title>
    <link href="http://www.citynight.cn/Blog/14823239811290.html"/>
    <updated>2016-12-21T20:39:41+08:00</updated>
    <id>http://www.citynight.cn/Blog/14823239811290.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>通过<code>runtime</code>与<code>KVC</code>配合完成</p>
</blockquote>

<p>在<code>UINavigationController</code>的<code>viewDidLoad</code>方法中:</p>

<pre><code>// 获取系统的手势
let gest = self.interactivePopGestureRecognizer!
// 禁用系统的手势
interactivePopGestureRecognizer?.isEnabled = false

// 通过KVC获取target 属性是通过runtime获取的,具体方法参见`Swift - KVC 和 运行时获取属性列表`
guard let targets = gest.value(forKey: &quot;_targets&quot;) as? [AnyObject] else {
    return
}
let target = targets[0].value(forKey: &quot;_target&quot;)

// 给视图添加点击事件
let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
view.addGestureRecognizer(pan)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库复习]]></title>
    <link href="http://www.citynight.cn/Blog/14817245458052.html"/>
    <updated>2016-12-14T22:09:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14817245458052.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>项目中部分功能打算使用数据库进行数据本地存储,所以复习了下数据库语句</p>
</blockquote>

<h2 id="toc_0">DDL</h2>

<pre><code>/*
删除表,如果存在表就删除表
*/
DROP TABLE IF EXISTS &#39;t_student&#39;;

/*
创建表
*/

CREATE TABLE IF NOT EXISTS &#39;t_student&#39; (
    &#39;id&#39; INTEGER NOT NULL PRIMARY KEY  AUTOINCREMENT,
    &#39;name&#39; TEXT,
    &#39;age&#39; INTEGER
);
</code></pre>

<h2 id="toc_1">DML</h2>

<pre><code>/*
插入数据
*/
/*
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz1&#39;, 18);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz2&#39;, 19);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz3&#39;, 21);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz4&#39;, 22);
*/

/*更新*/
-- UPDATE t_student SET age = 20 WHERE name = &#39;lxz1&#39;
UPDATE t_student SET name = &#39;xxx&#39; WHERE age &gt; 20


/*删除*/
DELETE FROM t_student WHERE name = &#39;xxx&#39;
</code></pre>

<h2 id="toc_2">DQL</h2>

<pre><code>/*查询语句*/
-- SELECT * FROM t_student;

/*查询特殊的字段*/
-- SELECT name,age FROM t_student;

/*通过条件来查询语句*/
-- SELECT name, age FROM t_student WHERE age &lt; 20;

/*模糊查询*/
-- SELECT name,age FROM t_student WHERE name LIKE &#39;%l%&#39;

/*多个条件的查询
AND 并且
OR 或者
*/
-- SELECT name, age FROM t_student WHERE name LIKE &#39;%l%&#39; AND age &lt; 20;

/*计算个数*/
-- SELECT count(*) FROM t_student WHERE age &lt; 20

/*排序
升序 ASC
降序 DESC
*/
-- SELECT * FROM t_student ORDER BY age DESC

-- SELECT * FROM t_student ORDER BY age ASC, name DESC;

/*起别名*/
-- 给表起别名
SELECT s.name, s.age FROM t_student AS s;
-- 给字段起别名
SELECT name AS myName, age AS myAge FROM t_student;


/*分页查询 limt
数字1的意思是前面跳过多少条数据
数字2的意思是本次查询多少条数据
SELECT * FROM t_student LIMIT 数字1,数字2

跳过0条数据查询5条数据
SELECT * FROM t_student LIMIT 5
*/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取崩溃信息]]></title>
    <link href="http://www.citynight.cn/Blog/14816416025061.html"/>
    <updated>2016-12-13T23:06:42+08:00</updated>
    <id>http://www.citynight.cn/Blog/14816416025061.html</id>
    <content type="html"><![CDATA[
<p>日志详细信息:</p>

<pre><code>static void exceptionHandler( NSException * exception )
{
    NSString *date = [NSString stringWithFormat:@&quot;崩溃日志-%@&quot;, [[NSDate date] description]];

    NSLog(DEBUG_CRASH, @&quot;%@ app crashed %@&quot;,date,exception.description);
     abort();
}
</code></pre>

<p>Appdelegate中调用:</p>

<pre><code>NSSetUncaughtExceptionHandler( &amp;exceptionHandler );
</code></pre>

<p>当然也可以在日志信息中记录堆栈信息:</p>

<pre><code>[exception callStackSymbols]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 上周问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14815534553600.html"/>
    <updated>2016-12-12T22:37:35+08:00</updated>
    <id>http://www.citynight.cn/Blog/14815534553600.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">懒加载的正确姿势</h2>

<blockquote>
<p>使用Swift的时候用懒加载,但是我发现我使用的时候不能再懒加载中调用本文件中声明的属性,原因是我在写懒加载的时候没有注明类型,正确的姿势应该是:</p>
</blockquote>

<pre><code>    lazy var &lt;#property name#&gt;: &lt;#type name#&gt; = {
        &lt;#statements#&gt;
        return &lt;#value#&gt;
    }()
</code></pre>

<p>快捷键<br/>
<img src="media/14815534553600/14815536582812.jpg" alt=""/><br/>
采用这种方式声明的懒加载能够在内部使用self</p>

<h2 id="toc_1">OC中用KVC赋值,使NSString类型指向了NSNumber,导致Swift中调用崩溃</h2>

<blockquote>
<p>崩溃信息:<code>reason: &#39;-[__NSCFNumber length]: unrecognized selector sent to instance 0x00000XXXX</code></p>
</blockquote>

<p>原因分析:NSString指向的数据类型为NSNumber的数据,取值时崩溃.第一种方案找到赋值有误的地方修改,第二不修改原有的代码,提出一种解决方案,重写NSString数据的<code>set</code>方法,赋值前判断数据类型,如果是NSNumber类型就转换成NSString类型.ß®</p>

<h2 id="toc_2">视图层级深,内部视图如何通知控制器数据更新?</h2>

<p>我想到的一种方法是把函数当做参数来传递,这样能够在一定程度上减少层级结构.甲冠提出设置一个属性,然后在属性的<code>didSet</code>中调用方法.目前还没有做实践,目测层级结构没有任何减少,但是代码量会少些.需要实验验证下.</p>

<p><strong>注:</strong>讨论中间有讨论MVC框架,这里附上苹果多MVC的介绍:<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1">https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1</a></p>

<p>传统:<br/>
<img src="media/14815534553600/14815566784560.gif" alt=""/></p>

<p>Cocoa:<br/>
<img src="media/14815534553600/14815567675257.gif" alt=""/></p>

<h2 id="toc_3">Xcode升级后部分第三方库报错</h2>

<p><img src="media/14815534553600/Snip20161215_3.png" alt="Snip20161215_3"/><br/>
让第三方库不跟随Xcode的swift版本®</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8之后设置PopoverController]]></title>
    <link href="http://www.citynight.cn/Blog/14813828036514.html"/>
    <updated>2016-12-10T23:13:23+08:00</updated>
    <id>http://www.citynight.cn/Blog/14813828036514.html</id>
    <content type="html"><![CDATA[
<p>直接上代码:</p>

<pre><code>    @IBOutlet weak var popoverButton: UIButton!
    @IBAction func popoverClick(_ sender: Any) {
        
        // 需要被展示的控制器
        let popover = PopoverViewController()
        // 设置呈现样式
        popover.modalPresentationStyle = .popover
        // 对应原来PopoverController中的rect
        popover.popoverPresentationController?.sourceRect = self.popoverButton.bounds
        // 对应原来PopoverController中的inView
        popover.popoverPresentationController?.sourceView = self.popoverButton
        // 展示
        self.present(popover, animated: true, completion: nil)
    }
</code></pre>

<p>在被呈现的控制器中设置显示的大小:</p>

<pre><code>class PopoverViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        /// 设置呈现大小
        self.preferredContentSize = CGSize(width: 400, height: 400)
    }
}
</code></pre>

<p>以上设置,如果是iPhone的话,模态弹出视图,popover属性就会被忽略.iPad则会Popover弹出</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scroll UICollectionView to section header view]]></title>
    <link href="http://www.citynight.cn/Blog/14810139766101.html"/>
    <updated>2016-12-06T16:46:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14810139766101.html</id>
    <content type="html"><![CDATA[
<p>新界面左右联动的时候遇到了一个问题,怎么在左侧tableView点击某一cell的时候右侧collectionView跳转到对应的section</p>

<p>如果没有section header View 的时候直接跳转到这个section的第一个Item就ok了,但是如果有section header View 的时候就需要注意了,不能这样进行跳转了,下面👇是经过测试的方法能够完美跳转到相应的section:</p>

<pre><code>let attributes = self.collectionView.collectionViewLayout.layoutAttributesForSupplementaryViewOfKind(UICollectionElementKindSectionHeader, atIndexPath: NSIndexPath(forItem: 0, inSection: index))

self.collectionView.setContentOffset(CGPointMake(0, attributes!.frame.origin.y - self.collectionView.contentInset.top), animated: true)
</code></pre>

<p>参见:<a href="http://stackoverflow.com/questions/22100227/scroll-uicollectionview-to-section-header-view">Scroll UICollectionView to section header view</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[左右联动效果再实现]]></title>
    <link href="http://www.citynight.cn/Blog/14807724917867.html"/>
    <updated>2016-12-03T21:41:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14807724917867.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>在微指的时候,商户详情界面中就存在左右联动,具体实现可见<a href="https://github.com/Mekor/MKShowDetail">MKShowDetail</a> .当然这次和微指的时候有所不同,层级结构更深,所属视图跨控制器.下面是正文👇</p>
</blockquote>

<h2 id="toc_0">数据结构</h2>

<p>在海底捞Pad版本项目中,点菜和点锅是两种完全不同的东西,但是又都属于点菜类中,所以数据结构比较复杂:</p>

<pre><code>点锅: 大分类 --&gt; 具体的锅底
点菜: 大分类 --&gt; 小分类 --&gt; 具体菜品
</code></pre>

<p><strong>需求:</strong> <em>大分类下如果有小分类并且小分类个数大于1个的时候显示小分类,如果小于一个则不显示.</em></p>

<p>这样两种数据结构完全不同的数据需要整合成相同的显示样式,跟同事讨论后决定粗暴的也是最简单的方法修改点锅数据,给大分类后面强行包裹一层小分类.</p>

<h2 id="toc_1">视图设计</h2>

<p>数据层搞定了,又到了显示问题了:<br/>
分类显示马上想到了<code>tableView</code>,但是<code>点锅</code>和<code>点菜</code>互不干扰,我想到的就是分成两个<code>section</code>,这时又有一个问题,需求又要求大分类和小分类的样式是不一样的,不一样的,不一样的&hellip;怎么办? 使用<code>tableViewSectionHeader</code>.按大类进行划分,<code>点锅</code>和<code>点菜</code>之间的区分用数据.小分类则用cell表示.</p>

<h3 id="toc_2">tableViewSectionHeader 设计</h3>

<p>既然已经决定了用<code>headerView</code>那么怎么设计呢?</p>

<ol>
<li>点击事件</li>
<li>确定具体点击的是哪个</li>
</ol>

<p>所以我在设计<code>headerView</code>的时候让它在显示数据的时候也要传入当前的<code>index</code>:</p>

<pre><code>    func setName(_ name: String, index: Int) {
        nameLabel.text = name
        self.index = index
    }
</code></pre>

<p>(ps: 不要吐槽,刚开始用Swift写项目😂)</p>

<p>这样我自己记录下传入的<code>index</code>当点击事件的时候再告诉外界具体点击的是哪一个:</p>

<pre><code>    @objc private func labelClick() {
        delegate?.didSelectedHeader(section : self.index)
    }
</code></pre>

<p>很明显的知道我是使用代理进行数据传递的..说下为啥不使用属性记录<code>index</code>?? 任性😁</p>

<p>到这里<code>headerView</code>基本完成了,控制器实现代理方法就好了,然后根据<code>index</code>让右侧具体的菜品滚动到相应的位置就好了&hellip;</p>

<h3 id="toc_3">点锅点菜区分&amp;跳转</h3>

<p>接上,左侧显示的大分类与小分类都是统一的了,但是右侧的点菜与点锅是分开的<strong>锅是锅,菜是菜</strong>.怎样区分呢?使用两套数据源,然后随时切换&gt;?? 不行🚫&hellip;要求要像淘宝或者京东详情页那样,可以滚动到下一页还可以滚回到上一页&hellip;怎么办? 使用两个collection控制器,一个显示点锅数据,一个显示点菜数据.这样做能够尽量减少某一个单独的控制器中存在过多的逻辑代码.那么谁来承载这两个控制器呢?再创建一个控制器然后把这两个放进去? 这样也能实现,就是控制器太多了&hellip;我想用的是一个<code>scrollow</code>来包裹这两个控制器,好处是能够控制显示那个控制器,逻辑也比较简单..比如说滚到第一个视图:</p>

<pre><code>        UIView.animate(withDuration: 0.25, delay: 0, options: .layoutSubviews, animations: ({
            self.contentView.contentOffset = CGPoint(x: 0, y: 0)
        }), completion: nil)
</code></pre>

<p>直接设置<code>scrollow</code>的<code>contentOffset</code>就可以了</p>

<p><strong>怎么做到电商网站中详情页与图文详情页滚动呢?</strong> 以当前项目为例(点锅在首屏),最简单的一种实现方式:</p>

<p>使用下拉刷新&amp;上拉加载更多实现</p>

<ol>
<li>点锅页面上拉加载更多跳转到点菜页面(通过上面代码设置<code>scrollow</code>的<code>contentOffset</code>实现)</li>
<li>点菜页面下拉刷新跳转到点锅页面,实现方式同上..</li>
</ol>

<p>这样很容易实现两个页面之间的跳转.</p>

<h3 id="toc_4">右侧具体菜品数据处理</h3>

<p>终于到数据处理了&hellip;这里的主要矛盾点在与collectionView是一个二级结构数据即可分成<code>section</code>与具体的<code>Item</code>,<code>点锅</code>数据还好,可以强制抹除大分类和具体内容之间强加的子分类封装,那么点菜数据怎么处理呢?毕竟右侧数据滚动后还要通知左侧视图跳转到相应的分类&hellip;<br/>
我想到的一种处理方式,可能不是最好的,但是这是我在短时间内想到比较行之有效的方法:</p>

<p>把点菜数据也通过一层操作转成两层数据:  <code>三层数据 --&gt; 遍历 --&gt; 数组 + 字典</code><br/>
具体点就是遍历三层数据,然后使用IndexPath当做 key ,具体的<code>Item</code>数组当做 value 这样就转换成立一个二级结构数据.具体<code>IndexPath</code>中<code>section</code>存放原有的大分类信息,<code>row</code>存放子分类数据信息..这样我们就可以通过 key 找到原有的数据结构信息,然后通过 key 把原有的信息传递到tableView,实现联动.</p>

<h3 id="toc_5">具体联动效果实现</h3>

<p>左侧点击后使用 <code>collectionView?.scrollToItem(at: IndexPath(item: 0, section: section), at: .top, animated: true)</code> 让右侧数据滚动到相应位置,关键是右侧滚动怎么判断左侧滚动到相应位置</p>

<p>在<code>scrollViewDidScroll</code>方法中获得当前显示的<code>Item</code>,具体计算方法如下:</p>

<pre><code>    private func minCurrentSection(collectionView:UICollectionView) -&gt; Int {
        // 根据屏幕的某一坐标,获取当前的index
        // 将collectionView在控制器屏幕的点转化成collectionView上的坐标
        let topPoint = CGPoint(x: UIScreen.main.bounds.size.width*0.5, y: 64)
        let pInView = view.convert(topPoint, to: collectionView)
        
        // 获取这一点的indexPath
        let  indexPathNow = collectionView.indexPathForItem(at: pInView)

        // 赋值给记录当前坐标的变量
        return indexPathNow?.section ?? 0
    }

</code></pre>

<p>这样就能够得到当前<code>Item</code>的<code>section</code>,<code>点锅</code>数据就可以直接让row等于0 然后直接回调就OK了,点菜数据还有些差别:<br/>
点菜需要返回具体的<code>indexPathNow</code>而不是只返回所在<code>section</code>,因为我们需要返回来的<code>index</code>寻找所在的<code>Item</code></p>

<pre><code>guard let cell = collectionView?.cellForItem(at: index) as? OrderDishOrPotCollectionCell else {
            return
        }
        delegate?.orderDishCurrent(position: IndexPath(row:cell.index.row , section: cell.index.section))
</code></pre>

<p>如上,我在<code>cell</code>中存放一个使用元组的属性</p>

<pre><code>    // 记录对应的大分类与小分类
    var index:(section:Int,row:Int) = (section: 0,row: 0)
</code></pre>

<p>处理菜品数据的时候所说的,<code>点菜</code>比较特殊我用<code>IndexPath</code>来记录原先所在的大分类与小分类,那么这里的属性就是记录<code>Key</code>中<code>IndexPath</code>所对应的值.我们既然能够找到这个<code>Item</code>那么问题就都解决了,就像上面代码中的回调.</p>

<h3 id="toc_6">注意</h3>

<p>因为这次需求是右侧数据滚动的过程中让左侧数据及时响应,而不是滚动结束的时候响应,所以需要判断是触摸滚动还是左侧数据点击后右侧数据滚动,毕竟两侧联动吗不做处理的话点击右侧数据左侧滚动,在左侧数据滚动的过程中又会及时回调让左侧数据滚动..</p>

<h3 id="toc_7">思考🤔</h3>

<p>第一种:<br/>
<img src="media/14807724917867/14809480143802.jpg" alt=""/><br/>
第二种:(目前采用)<br/>
<img src="media/14807724917867/14809473897512.jpg" alt=""/></p>

<p>第一种是所要展现的内容控制器是底层控制器的自控制器<br/>
第二种是所要展现内容的控制器在collectionView中,collectionView将不仅仅是一个视图而是变成了一个中间层<br/>
这两种方式那种更好?</p>

<p>&mdash; 12.7 &mdash;-<br/>
需求有变动,不过改动起来看,还是第二种修改方便些😂,所有的逻辑跳转代码没有混合在最外层VC.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xib报错]]></title>
    <link href="http://www.citynight.cn/Blog/14802973825600.html"/>
    <updated>2016-11-28T09:43:02+08:00</updated>
    <id>http://www.citynight.cn/Blog/14802973825600.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>错误信息: Unknown class XXXX in Interface Builder file. (lldb)</p>
</blockquote>

<p>原因,Xib是在其他项目中创建的,拖进来的时候没有注意,只要修改<br/>
<img src="media/14802973825600/14802974822042.jpg" alt=""/></p>

<p>修改module为项目的就好了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 面向协议编程]]></title>
    <link href="http://www.citynight.cn/Blog/14799970254990.html"/>
    <updated>2016-11-24T22:17:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14799970254990.html</id>
    <content type="html"><![CDATA[
<p>跟全部写在base中比较:</p>

<ol>
<li>代码没有增多,却更复用</li>
<li>面向协议(接口),而不是实现,充分解耦</li>
<li>静态类型检查版主在编译时发现问题</li>
<li>写代码像搭积木,先设计接口,再逐一实现</li>
<li>依赖少,更容易调试</li>
</ol>

<pre><code>protocol Hello {
    func sayHello()
}

extension Hello {
    func sayHello() {
        print(&quot;Hello!&quot;)
    }
}

struct Person: Hello {
    
}

let p = Person()
p.sayHello()
</code></pre>

<p>创建一个协议,并且做一个默认实现.使用的时候可以直接调用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 函数式编程]]></title>
    <link href="http://www.citynight.cn/Blog/14799126696997.html"/>
    <updated>2016-11-23T22:51:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/14799126696997.html</id>
    <content type="html"><![CDATA[
<p>一般情况:</p>

<pre><code>struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

usr.login(password: passwd)
</code></pre>

<p>函数式编程</p>

<pre><code>struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

User.login(usr)(password: passwd)
</code></pre>

<p>由此可见: <code>usr.login(password: passwd)</code> == <code>User.login(usr)(password: passwd)</code></p>

<p>如果忽略外部参数</p>

<pre><code>struct User {
    func login(_ password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()
usr.login(passwd)
User.login(usr)(passwd)
</code></pre>

<p>这样就更简洁了</p>

<hr/>

<p>&mdash; 11.24更 &ndash;</p>

<h2 id="toc_0">柯里化(Currying)</h2>

<pre><code>// 柯里化(Currying)

func addOne(num:Int) -&gt;Int {
    return num + 1
}

print(addOne(num: 10))

func addTo(_ adder:Int) -&gt;(_ num:Int) -&gt; Int {
    return {
        num in
        return num + adder
    }
}

let addTwo = addTo(2)

print(addTwo(6))

// 更简单的调用方式
print(addTo(9)(1))

</code></pre>

<p>&mdash;-12.8&mdash;-<br/>
说到函数式编程,我突然想起了今天实现一个功能所用到的技术,这里只做简单记录.</p>

<p>项目中遇到一个问题:根据参数创建相应个数的视图,视图中按钮的点击事件还要回调..我一开始想用代理来做,发现如果层级结构比较深的话代理不是很好用.既然否定了代理那么怎样还能实现该效果呢?我尝试用函数(闭包).</p>

<p>需要传递的数据<br/>
<code><br/>
let dict = [<br/>
    [&quot;title&quot;:GLOBAL_LANGUAGE(&quot;历史锅底&quot;) ,<br/>
     &quot;subtitle&quot;:GLOBAL_LANGUAGE(&quot;上次的定制锅底,再来一单&quot;),<br/>
     &quot;imagename&quot;:&quot;OrderDishOrPot1&quot;,<br/>
     &quot;callback&quot;:historyPotsList!]  // callback 中存放的就是函数名或者闭包名<br/>
]<br/>
</code></p>

<pre><code>let showTitle =  data[i][&quot;title&quot;] as! String
let showSubTitle = data[i][&quot;subtitle&quot;] as! String
let imageName = data[i][&quot;imagename&quot;] as! String
let callBack = data[i][&quot;callback&quot;] as! (()-&gt;()) // 这里就是我需要的闭包

//=======

callBack() // 闭包调用

</code></pre>

<p>只需要这样我就能实现需求了&hellip;函数的传递虽然不像👆所说的那样函数式编程,但是还是有必要记录下,swift跟OC比还是灵活了很多.</p>

<p>&mdash;-未完待续&mdash;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 使用代理和闭包传值]]></title>
    <link href="http://www.citynight.cn/Blog/14796301513904.html"/>
    <updated>2016-11-20T16:22:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14796301513904.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">代理传值</h2>

<p>声明协议:</p>

<pre><code>protocol FunctionButtonViewDelegate {
    func gotoViewController(vcString:String)
}
</code></pre>

<pre><code>var delegate :FunctionButtonViewDelegate?
</code></pre>

<p>这里<code>?</code>就具有<code>weak</code>的作用</p>

<p>传值:</p>

<pre><code>delegate?.gotoViewController(vcString: button.currentTitle!)
</code></pre>

<p>实现代理方法</p>

<pre><code>extension PersonalCenterViewController:FunctionButtonViewDelegate {
    //MARK: - 跳转到对应的功能模块
    func gotoViewController(vcString: String) {
        print(vcString)
    }
}
</code></pre>

<h2 id="toc_1">闭包传值</h2>

<p>声明:</p>

<pre><code>var callback : ((Int?) -&gt; Void)?
</code></pre>

<p>传值</p>

<pre><code>if let cb = callback {
    cb(200)
}
</code></pre>

<p>实现:</p>

<pre><code>bottomView.callback = { (num)-&gt;Void in
    print(num ?? 0)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 在swift中如何使用 hexcolor 值表示颜色]]></title>
    <link href="http://www.citynight.cn/Blog/14796201135474.html"/>
    <updated>2016-11-20T13:35:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/14796201135474.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>结果来自<a href="http://stackoverflow.com/questions/24263007/how-to-use-hex-colour-values-in-swift-ios">How to use hex colour values in Swift, iOS</a></p>
</blockquote>

<pre><code>extension UIColor {
    convenience init(hexString: String) {
        let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int = UInt32()
        Scanner(string: hex).scanHexInt32(&amp;int)
        let a, r, g, b: UInt32
        switch hex.characters.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int &gt;&gt; 8) * 17, (int &gt;&gt; 4 &amp; 0xF) * 17, (int &amp; 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int &gt;&gt; 16, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int &gt;&gt; 24, int &gt;&gt; 16 &amp; 0xFF, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)
    }
}
</code></pre>

<p>使用方法:</p>

<pre><code>let darkGrey = UIColor(hexString: &quot;#757575&quot;)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习]]></title>
    <link href="http://www.citynight.cn/Blog/14793607171148.html"/>
    <updated>2016-11-17T13:31:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/14793607171148.html</id>
    <content type="html"><![CDATA[
<p>工作中必须使用git,但是原先一直使用svn,所以有点坑&hellip;这里简单总结下简单用法</p>

<h2 id="toc_0">svn与git的不同</h2>

<p>一个是集中式版本管理控制,一个是分布式</p>

<p><strong>集中式版本控制:</strong><br/>
<img src="media/14793607171148/14795544773647.jpg" alt=""/></p>

<p><strong>分布式版本控制:</strong><br/>
<img src="media/14793607171148/14795545177377.jpg" alt=""/></p>

<h2 id="toc_1">git简单实用</h2>

<h3 id="toc_2">git help</h3>

<pre><code>$ git help
</code></pre>

<p>查看git所有命令的帮助</p>

<pre><code>$ git help 子命令
</code></pre>

<p>要退出帮助信息，按<code>&quot;q&quot;</code><br/>
翻看下页，按<code>&quot;空格&quot;</code><br/>
翻看上页，按<code>&quot;CTRL+B&quot;</code><br/>
要搜索相关文字，按<code>&quot;/&quot;</code>然后输入<code>&quot;相关文字&quot;</code></p>

<h3 id="toc_3">配置</h3>

<p>1&gt;  创建代码仓库</p>

<pre><code>$ git init
</code></pre>

<p>2&gt;  配置用户名和邮箱</p>

<pre><code>$ git config user.name manager
$ git config user.email manager@gmail.com
</code></pre>

<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中</li>
</ul>

<p>3&gt;  如果要一次性配置完成可以使用一下命令</p>

<pre><code>$ git config --global user.name manager
$ git config --global user.email manager@gmail.com
</code></pre>

<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 <code>.gitconfig</code> 文件中</li>
</ul>

<p>4&gt;  查看当前所有配置</p>

<pre><code>$ git config -l
</code></pre>

<h3 id="toc_4">开发中常用</h3>

<p>1&gt;  创建代码，开始开发</p>

<pre><code>$ touch main.c
$ open main.c
</code></pre>

<p>2&gt;  将代码添加到代码库</p>

<ol>
<li> 查看当前代码库状态
<code>
$ git status
</code></li>
<li> 将文件添加到代码库
<code>
$ git add main.c
</code></li>
<li><p>将修改提交到代码库<br/>
<code><br/>
$ git commit -m &quot;添加了main.c&quot;<br/>
</code><br/>
提示：</p>

<ul>
<li>   在此一定要使用 -m 参数指定修改的备注信息</li>
<li>   否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情</li>
</ul></li>
<li><p>将当前文件夹下的所有新建或修改的文件一次性添加到代码库<br/>
<code>$ git add .</code></p></li>
</ol>

<p>3&gt;  添加多个文件</p>

<pre><code>$ touch Person.h Person.m
$ git add .
$ git commit -m &quot;添加了Person类&quot;
$ open Person.h
$ git add .
$ git commit -m &quot;增加Person类属性&quot;
</code></pre>

<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的</li>
</ul>

<h2 id="toc_5">git 的重要概念及工作原理</h2>

<p>工作区<br/>
暂存区(staged)<br/>
分支(HEAD)</p>

<h2 id="toc_6">别名 &amp; 日志</h2>

<pre><code>$ git config alias.st status
$ git config alias.ci &quot;commit -m&quot;
</code></pre>

<p>除非特殊原因，最好不要设置别名，否则换一台机器就不会用了</p>

<p>查看所有版本库日志</p>

<pre><code>$ git log
</code></pre>

<p>查看指定文件的版本库日志</p>

<pre><code>$ git log 文件名
</code></pre>

<p>配置带颜色的log别名</p>

<pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;
</code></pre>

<p>提示：在git中，版本号是一个由SHA1生成的哈希值</p>

<h2 id="toc_7">版本号，让我们在任意版本之间穿梭</h2>

<pre><code># 回到当前版本，放弃所有没有提交的修改
$ git reset --hard HEAD
# 回到上一个版本
$ git reset --hard HEAD^
# 回到之前第3个修订版本
$ git reset --hard HEAD~3
# 回到指定版本号的版本
$ git reset --hard e695b67

# 查看分支引用记录
$ git reflog

</code></pre>

<h2 id="toc_8">分支管理 - Tag</h2>

<pre><code># 查看当前标签
$ git tag
# 在本地代码库给项目打上一个标签
$ git tag -a v1.0 -m &#39;Version 1.0&#39;
# 将标签添推送到远程代码库中
$ git push origin v1.0

# 使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本
# 签出v1.0标签
$ git checkout v1.0
# 从签出状态创建v1.0bugfix分支
$ git checkout -b bugfix1.0

# 查看远程分支
$ git branch -r
# 删除远程分支
$ git branch -r -d origin/bugfix1.0
</code></pre>

<p>删除修改返回到上次提交状态</p>

<pre><code>git checkout -f
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 自定义tableViewCell]]></title>
    <link href="http://www.citynight.cn/Blog/14793055516073.html"/>
    <updated>2016-11-16T22:12:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14793055516073.html</id>
    <content type="html"><![CDATA[
<p>习惯 OC 刚刚接触 Swift 还是有很多地方不适应,创建自定义cell的时候出现如下情况</p>

<pre><code>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
    }
</code></pre>

<p>OC 中,我们会用 self 来接 super 初始化来判断是否创建成功,但是 Swift 中怎样做呢?调用 <code>super.init</code>是没有返回值的,那么我们怎样判断呢?</p>

<p>从网上看<a href="http://stackoverflow.com/questions/37098742/super-init-in-swift">Super init in Swift</a>没有必要在进行<code>if(self)</code>判断了&hellip;不过,我还是找到了一种更容易理解的方法:</p>

<pre><code>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        if !self.isEqual(nil) {
            setupInterface()
        }
    }

</code></pre>

<p>虽然感觉有点画蛇添足,不过很符合刚刚从OC 转 Swift 的理解方式</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[隐藏tabBar的小技巧]]></title>
    <link href="http://www.citynight.cn/Blog/14793034700265.html"/>
    <updated>2016-11-16T21:37:50+08:00</updated>
    <id>http://www.citynight.cn/Blog/14793034700265.html</id>
    <content type="html"><![CDATA[
<p>突然想起来 <code>微指App</code> 里面控制 tabBar 显示与隐藏非常麻烦,在控制器中的 <code>viewWillAppear</code> 和 <code>viewWillDisappear</code>中做处理,这样能保证在控制器中控制 tabBar 的显示与隐藏,但是也非常麻烦,每个控制器都需要控制..</p>

<p>一劳永逸的做法:</p>

<pre><code>    // 重写 push 方法
    override func pushViewController(_ viewController: UIViewController, animated: Bool) {
        // 如果不是栈底控制器才需要隐藏, 根控制器 不需要处理
        if childViewControllers.count &gt; 0 {
            // 隐藏底部的 TabBar
            viewController.hidesBottomBarWhenPushed = true
        }
        super.pushViewController(viewController, animated: true)
    }
</code></pre>

<p>在导航控制器中重写 <code>push</code> 方法,这样就能省去好多麻烦..</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS依赖库管理工具：Carthage]]></title>
    <link href="http://www.citynight.cn/Blog/14791335483032.html"/>
    <updated>2016-11-14T22:25:48+08:00</updated>
    <id>http://www.citynight.cn/Blog/14791335483032.html</id>
    <content type="html"><![CDATA[
<p>新项目需要使用一种新的依赖库管理工具:<code>Carthage</code> </p>

<blockquote>
<p>参见:<a href="http://www.jianshu.com/p/9a37b81a59d6">iOS依赖库管理工具：Carthage</a></p>
</blockquote>

<h2 id="toc_0">安装Carthage</h2>

<ul>
<li>使用终端安装</li>
</ul>

<pre><code>$brew update
$brew install carthage
</code></pre>

<ul>
<li>在<a href="https://github.com/Carthage/Carthage/releases">https://github.com/Carthage/Carthage/releases</a> 下载最新版的Carthage.pkg</li>
</ul>

<p>安装好Carthage后，查看Carthage当前版本</p>

<pre><code>$brew carthage version
</code></pre>

<h2 id="toc_1">使用Carthage</h2>

<ul>
<li>在项目所在文件夹中创建一个空的Carthage文件</li>
</ul>

<pre><code>$touch Cartfile  
$vi Cartfile
</code></pre>

<p><strong>$touch Cartfile</strong>：新建一个名为Cartfile的文件</p>

<p><strong>$vi Cartfile</strong>：打开名为Cartfile文件，如若该文件不存在会新建</p>

<ul>
<li>在Cartfile中加入一下内容，以Alamofire为例：</li>
</ul>

<pre><code>github &quot;Alamofire/Alamofire&quot; ~&gt; 3.0
</code></pre>

<p>版本含义：<br/>
<code>~&gt; 3.0：表示使用版本高于3.0低于4.0的最新版本</code><br/>
<code>== 3.0：使用3.0版本</code><br/>
<code>&gt;= 3.0：使用3.0版本或者更高版本</code><br/>
如果没有指明版本号，默认使用最新版本</p>

<ul>
<li>保存并关闭Cartfile文件，在终端执行如下命令，carthage开始下载和编译所需要的第三方库，当命令执行完毕，项目文件夹中会创建一个名为Carthage的文件夹，并且在~/Carthage/Build/iOS中出现Alamofire.framework文件</li>
</ul>

<pre><code>$carthage update
</code></pre>

<ul>
<li><p>打开项目，点击project-&gt;target-&gt;General，在Embedded Binaries添加Alamofire.framework</p></li>
<li><p>此时已经可以使用导入的第三方库了，在需要的文件中导入头文件</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 懒加载 lazy]]></title>
    <link href="http://www.citynight.cn/Blog/14791319119586.html"/>
    <updated>2016-11-14T21:58:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14791319119586.html</id>
    <content type="html"><![CDATA[
<p>为什么使用懒加载?</p>

<ol>
<li>能够延迟创建</li>
<li>解除解包的烦恼</li>
</ol>

<blockquote>
<p>参考<strong>Swifter</strong>中`lazy 修饰符和 lazy 方法</p>
</blockquote>

<h2 id="toc_0">常用方法</h2>

<p>OC中的懒加载</p>

<pre><code>// ClassA.h
@property (nonatomic, copy) NSString *testString;

// ClassA.m
- (NSString *)testString {
     if (!_testString) {
         _testString = @&quot;Hello&quot;;
        NSLog(@&quot;只在首次访问输出&quot;);
     }
     return _testString;
}
</code></pre>

<p>Swift中:</p>

<pre><code>class ClassA {
    lazy var str: String = {
        let str = &quot;Hello&quot;
        print(&quot;只在首次访问输出&quot;)
        return str
    }()
}
</code></pre>

<p>简化版本:</p>

<pre><code>lazy var str: String = &quot;Hello&quot;
</code></pre>

<h2 id="toc_1">其他用法</h2>

<pre><code>        let data = 1...3
        let result = data.map { (i:Int) -&gt; Int in
            print(&quot;正在处理\(i)&quot;)
            return 1*2
        }
        
        print(&quot;准备访问结果&quot;)
        
        for i in result {
            print(&quot;操作后结果为\(i)&quot;)
        }

</code></pre>

<p>结果:</p>

<pre><code>正在处理1
正在处理2
正在处理3
准备访问结果
操作后结果为2
操作后结果为4
操作后结果为6
</code></pre>

<p>如果使用lazy</p>

<pre><code>        let data = 1...3
        let result = data.lazy.map { (i:Int) -&gt; Int in
            print(&quot;正在处理\(i)&quot;)
            return i*2
        }
        
        print(&quot;准备访问结果&quot;)
        
        for i in result {
            print(&quot;操作后结果为\(i)&quot;)
        }

</code></pre>

<p>结果:<br/>
<code><br/>
准备访问结果<br/>
正在处理1<br/>
操作后结果为2<br/>
正在处理2<br/>
操作后结果为4<br/>
正在处理3<br/>
操作后结果为6<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - convenience 便利构造函数]]></title>
    <link href="http://www.citynight.cn/Blog/14790461560134.html"/>
    <updated>2016-11-13T22:09:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14790461560134.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>具体解释可以参见 <strong>Swifter</strong> 中<code>Designated，Convenience 和 Required</code></p>
</blockquote>

<p>使用遍历工造函数的好处可以参见如下代码:</p>

<pre><code>import UIKit

extension UITextField {
    convenience init(frame:CGRect, placeholder:String,fontSize:CGFloat = 14) {
        self.init(frame:frame)
        
        self.borderStyle = .roundedRect
        self.placeholder = placeholder
        self.font = UIFont.systemFont(ofSize: fontSize)
    }
}

</code></pre>

<p><strong>好处:</strong><br/>
1. 判断条件,只有满足条件才实例化对象,可以防止造成不必要的内存开销<br/>
2. 简化对象的创建  -&gt;利用<code>extension</code>抽取控件创建方法<br/>
3. 本身不负责属性的创建和初始化工作<br/>
4. 可以返回nil</p>

<p><strong>注意点:</strong><br/>
1. 必须调用本类的 <code>self.init</code>,不能调用父类的<code>super.init</code><br/>
2. 不能被重写</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - KVC 和 运行时获取属性列表]]></title>
    <link href="http://www.citynight.cn/Blog/14790381443417.html"/>
    <updated>2016-11-13T19:55:44+08:00</updated>
    <id>http://www.citynight.cn/Blog/14790381443417.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Swift中如何使用KVC</h2>

<pre><code>import UIKit

class Person: NSObject {
    var name:String?
    var age: Int = 0
    var title:String?
    
    init(dict:[String:Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {
        
    }
}
</code></pre>

<p>注意:基本数据类型一开始要设置默认值.</p>

<h2 id="toc_1">Swift中运行时获取属性列表</h2>

<pre><code>class Person: NSObject {
    var name:String?
    var age: Int = 0
    var title:String?
    
    init(dict:[String:Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {
        
    }
    
    class func propertyList() -&gt; [String] {
        var count:UInt32 = 0
        
        let list = class_copyPropertyList(self,&amp;count)
        
        var array:[String] = [];
        
        for i in 0..&lt;Int(count) {
            
            // 获取属性
            let pty = list?[i]
            
            // 获取属性名称
            let cName = property_getName(pty)
            let name = String(utf8String: cName!)
            array.append(name!)
        }
        free(list)
        return array
    }
}

</code></pre>

<p>上面是OC写法,可以改进的更Swift一点:</p>

<pre><code>    class func propertyList() -&gt; [String] {
        var count:UInt32 = 0
        
        let list = class_copyPropertyList(self,&amp;count)
        
        var array:[String] = [];
        
        for i in 0..&lt;Int(count) {
            
            guard let pty = list?[i],
                let cName = property_getName(pty),
                let name = String(utf8String: cName)
                else {
                    // 继续遍历下一个
                    continue
            }
            array.append(name)
        }
        free(list)
        return array
    }
</code></pre>

<p>通过运行时可以发现:</p>

<ol>
<li>基本数据类型如果设置成可选类型则运行时获取不到(在OC中没有可选)&hellip;.  这就说明了上面的注意点,否则使用<code>KVC</code>会崩溃 </li>
<li>如果属性为<code>private</code>同样获取不到属性(可以获取到ivar),同样会让<code>KVC</code>崩溃</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 函数]]></title>
    <link href="http://www.citynight.cn/Blog/14790175059723.html"/>
    <updated>2016-11-13T14:11:45+08:00</updated>
    <id>http://www.citynight.cn/Blog/14790175059723.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">函数的几种情况</h2>

<pre><code>// 正常
func sum(x:Int, y:Int) -&gt; Int {
    return x+y
}
print(sum(x: 10, y: 20))

// 去掉形参
func sum(_ x:Int,_ y:Int) -&gt; Int {
    return x+y
}
print(sum(10, 20))

// 外部参数
func sum(num1 x:Int,num2 y:Int) -&gt; Int {
    return x+y
}
print(sum(num1: 10, num2: 20))

// 函数带默认值
func sum(x:Int = 1, y:Int = 2) -&gt; Int {
    return x+y
}
print(sum())
</code></pre>

<h2 id="toc_1">闭包</h2>

<blockquote>
<p>闭包类似于OC中的block,但应用更广. 与OC对比, OC中block是特殊的函数,在Swift中函数是特殊的闭包</p>
</blockquote>

<pre><code>// 最简单的闭包
// 定义
let foo = {
    print(&quot;最简单的闭包&quot;)
}
// 调用
foo()

// 带参数无返回值
let foo = { (x:Int) -&gt; () in
    print(x)
}
foo(100)

// 带参数有返回值
let foo = { (x:Int) -&gt; Int in
    return x+1
}
foo(10)
</code></pre>

<p>block常用在异步执行,回调&hellip;Swift中异步跟OC稍微有些区别.</p>

<h3 id="toc_2">模拟异步加载</h3>

<pre><code>    /// 加载数据
    func loadData(completion:@escaping (_ result: [String])-&gt;()) {
        
        DispatchQueue.global().async {
            print(&quot;耗时操作\(Thread.current)&quot;)
            
            DispatchQueue.main.async {
                print(&quot;主线程更新\(Thread.current)&quot;)
                let json = [&quot;头条&quot;,&quot;八卦&quot;,&quot;出大事了&quot;]
                completion(json)
            }
        }
    }
</code></pre>

<p>注:关于<strong>@escaping</strong>参见 Swifter 中<code>@escaping</code></p>

<h3 id="toc_3">尾随闭包</h3>

<pre><code>        // 如果函数的最后一个参数是闭包,函数参数可以提前结束,最后一个参数直接使用{}包装闭包的代码
        loadData { (JSON) in
            print(JSON)
        }

</code></pre>

]]></content>
  </entry>
  
</feed>
