<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2017-08-27T23:12:13+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[3D Touch]]></title>
    <link href="http://www.citynight.cn/Blog/15038471972999.html"/>
    <updated>2017-08-27T23:19:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/15038471972999.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/6705/3d-touch/22813/3d-touch-with-swift">3D Touch with Swift</a></h2>

<p>3D touch has been introduced with iPhone 6s Plus. There are two behaviors added with this new interface layer: Peek and Pop.</p>

<p><strong>Peek and Pop in a nutshell</strong></p>

<p>Peek - Press hard</p>

<p>Pop - Press really hard</p>

<p><strong>Checking for 3D support</strong></p>

<p>You should check if the device has a 3D touch support. You can do this by checking the value of <em>forceTouchCapability</em> property of a <em>UITraitCollection</em> object. UITraitCollection describes the iOS interface environment for your app.</p>

<pre><code>if (traitCollection.forceTouchCapability == .Available) {    
    registerForPreviewingWithDelegate(self, sourceView: view)
}
</code></pre>

<p><strong>Implementing the delegate</strong></p>

<p>You need to implement the two methods of <em>UIViewControllerPreviewingDelegate</em> in your class. One of the methods is for <em>peek</em> and the other one is for <em>pop</em> behavior.</p>

<p>The method to be implemented for the <em>peek</em> is <em>previewingContext</em>.</p>

<pre><code>func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? {

    guard let indexPath = self.tableView.indexPathForRowAtPoint(location), cell = self.tableView.cellForRowAtIndexPath(indexPath) as? &lt;YourTableViewCell&gt; else {
        return nil
    }

    guard let datailVC = storyboard?.instantiateViewControllerWithIdentifier(&quot;&lt;YourViewControllerIdentifier&gt;&quot;) as? &lt;YourViewController&gt; else {
        return nil
    }

    datailVC.peekActive = true
    previewingContext.sourceRect = cell.frame

    // Do the stuff

    return datailVC

}
</code></pre>

<p>The method to be implemented for the <em>pop</em> is <em>previewingContext</em>. :)</p>

<pre><code>func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {

    let balanceViewController = viewControllerToCommit as! &lt;YourViewController&gt;

    // Do the stuff

    navigationController?.pushViewController(balanceViewController, animated: true)

}
</code></pre>

<p>As you can see they are overloaded methods. You can use 3D touch in any way implementing these methods.</p>

<p><strong>Objective-C</strong></p>

<pre><code>//Checking for 3-D Touch availability
if ([self.traitCollection respondsToSelector:@selector(forceTouchCapability)] &amp;&amp;
        (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable))
    {
        [self registerForPreviewingWithDelegate:self sourceView:self.view];
    }
//Peek
- (UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {

    NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location];
    Country *country = [self countryForIndexPath:indexPath];
    if (country) {
        CountryCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
        if (cell) {
            previewingContext.sourceRect = cell.frame;
            UINavigationController *navController = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;UYLCountryNavController&quot;];
            [self configureNavigationController:navController withCountry:country];
            return navController;
        }
    }
    return nil;
}
//Pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit {

    [self showDetailViewController:viewControllerToCommit sender:self];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAGradientLayer]]></title>
    <link href="http://www.citynight.cn/Blog/15038463059094.html"/>
    <updated>2017-08-27T23:05:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/15038463059094.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/3856/creating-a-cagradientlayer">Creating a CAGradientLayer</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.red.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellow.cgColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 1.0]

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/q26bv.png" alt="Simple CAGradientLayer."/></p>

<h2 id="toc_1"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/12652/animating-a-color-change-in-cagradientlayer">Animating a color change in CAGradientLayer.</a></h2>

<pre><code>// Get the current colors of the gradient.
let oldColors = self.gradientLayer.colors

// Define the new colors for the gradient.
let newColors = [UIColor.red.cgColor, UIColor.yellow.cgColor]

// Set the new colors of the gradient.
self.gradientLayer.colors = newColors

// Initialize new animation for changing the colors of the gradient.
let animation: CABasicAnimation = CABasicAnimation(keyPath: &quot;colors&quot;)

// Set current color value.
animation.fromValue = oldColors

// Set new color value.
animation.toValue = newColors

// Set duration of animation.
animation.duration = 0.3

// Set animation to remove once its completed.
animation.isRemovedOnCompletion = true

// Set receiver to remain visible in its final state when the animation is completed.
animation.fillMode = kCAFillModeForwards

// Set linear pacing, which causes an animation to occur evenly over its duration.
animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)

// Set delegate of animation.
animation.delegate = self

// Add the animation.
self.gradientLayer.addAnimation(animation, forKey: &quot;animateGradientColorChange&quot;)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/AquKd.gif" alt="Basic CAGradientLayer color change animation."/></p>

<h2 id="toc_2"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4229/creating-a-horizontal-cagradientlayer-with-multiple-colors">Creating a horizontal CAGradientLayer with multiple colors.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.greenColor().CGColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.blueColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.blackColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/I4OGH.png" alt="enter image description here"/></p>

<h2 id="toc_3"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4228/creating-a-horizontal-cagradientlayer">Creating a horizontal CAGradientLayer.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.redColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellowColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/7VCnW.png" alt="Horizontal CAGradientLayer."/></p>

<h2 id="toc_4"><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4227/creating-a-cggradientlayer-with-multiple-colors">Creating a CGGradientLayer with multiple colors.</a></h2>

<pre><code>// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.blue.cgColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.yellow.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.green.cgColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 0.5, 1.0]

// Insert gradient layer into view&#39;s layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>

<p>Result :</p>

<p><img src="media/15038463059094/tV4OL.png" alt="Complex CAGradientLayer."/></p>

<hr/>

<h2 id="toc_5">Syntax</h2>

<pre><code>CAGradientLayer() // Returns an initialized CALayer object.
-------------------
CAGradientLayer(layer: layer) // Override to copy or initialize custom fields of the specified layer.
</code></pre>

<h2 id="toc_6">Parameters</h2>

<table>
<thead>
<tr>
<th style="text-align: left">Parameter</th>
<th style="text-align: left">Details</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">color</td>
<td style="text-align: left">An array of <code>CGColorRef</code> objects defining the color of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">locations</td>
<td style="text-align: left">An optional array of <code>NSNumber</code> objects defining the location of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">endPoint</td>
<td style="text-align: left">The end point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">startPoint</td>
<td style="text-align: left">The start point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">type</td>
<td style="text-align: left">Style of gradient drawn by the layer. Defaults to <code>kCAGradientLayerAxial</code>.</td>
</tr>
</tbody>
</table>

<h2 id="toc_7">Remarks</h2>

<ul>
<li>Use <code>startPoint</code> and <code>endPoint</code> to change the orientation of the <code>CAGradientLayer</code>.</li>
<li>Use the <code>locations</code> to affect the spread/positions of the colors.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom UIViews from XIB files]]></title>
    <link href="http://www.citynight.cn/Blog/15036540820094.html"/>
    <updated>2017-08-25T17:41:22+08:00</updated>
    <id>http://www.citynight.cn/Blog/15036540820094.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/4443/wiring-elements">Wiring elements</a></h2>

<ul>
<li><blockquote>
<p>Create a XIB file</p>
</blockquote>

<p>Xcode Menu Bar &gt; File &gt; New &gt; File.<br/>
Select iOS, User Interface and then &ldquo;View&rdquo;:</p>

<p><a href="media/15036540820094/RSkzu.png"><img src="media/15036540820094/RSkzu.png" alt="First step"/></a></p>

<p>Give your XIB a name (yes, we are doing a Pokemon example 👾).<br/>
<strong>Remember to check your target</strong> and hit &ldquo;Create&rdquo;.</p>

<p><a href="media/15036540820094/oJ1s1.png"><img src="media/15036540820094/oJ1s1.png" alt="Second step"/></a></p>

<blockquote>
<p>Design your view</p>
</blockquote>

<p>To make things easier, set:</p>

<ul>
<li>Size: Freeform</li>
<li>Status Bar: None</li>
<li>Top Bar: None</li>
<li>Bottom Bar: None</li>
</ul>

<p><a href="media/15036540820094/Gy0KD.png"><img src="media/15036540820094/Gy0KD.png" alt="Third step"/></a></p>

<p>Click on the Size Inspector and resize the view.<br/>
For this example we&rsquo;ll be using width 321 and height 256.</p>

<p><a href="media/15036540820094/PNIek.png"><img src="media/15036540820094/PNIek.png" alt="Fourth step"/></a></p>

<p>Drop some elements into your XIB file like shown below.<br/>
Here we&rsquo;ll be adding an <strong>Image View</strong> (256x256) and a <strong>Switch</strong>.</p>

<p><a href="media/15036540820094/6u3pd.png"><img src="media/15036540820094/6u3pd.png" alt="Fifth step"/></a></p>

<p>Add Auto-Layout constraints by clicking on &ldquo;Resolve Auto Layout Issues&rdquo; (bottom-right) and selecting &ldquo;Add Missing Constraints&rdquo; under &ldquo;All Views&rdquo;.</p>

<p><a href="media/15036540820094/esZhQ.png"><img src="media/15036540820094/esZhQ.png" alt="Sixth step"/></a></p>

<p>Preview the changes you made by clicking on &ldquo;Show the Assistant Editor&rdquo; (top-right), then &ldquo;Preview&rdquo;.<br/>
You can add iPhone screens by clicking on the &ldquo;Plus&rdquo; button.<br/>
The preview should look like this:</p>

<p><a href="media/15036540820094/D3rac.png"><img src="media/15036540820094/D3rac.png" alt="Seventh step"/></a></p>

<blockquote>
<p>Subclass UIView</p>
</blockquote>

<p>Create the class that is going to manage the XIB file.<br/>
Xcode Menu Bar &gt; File &gt; New &gt; File.<br/>
Select iOS / Source / Cocoa Touch Class. Hit &ldquo;Next&rdquo;.</p>

<p><a href="media/15036540820094/0EyHy.png"><img src="media/15036540820094/0EyHy.png" alt="Eighth step"/></a></p>

<p>Give the class a name, which must be the same name as the XIB file (Pokemon).<br/>
Select UIView as the subclass type, then hit &ldquo;Next&rdquo;.</p>

<p><a href="media/15036540820094/qbo3s.png"><img src="media/15036540820094/qbo3s.png" alt="Nineth step"/></a></p>

<p>On the next window, select your target and hit &ldquo;Create&rdquo;.</p>

<p><a href="media/15036540820094/Ks9Tu.png"><img src="media/15036540820094/Ks9Tu.png" alt="Tenth step"/></a></p>

<blockquote>
<p>Connect Pokemon.xib to Pokemon.swift via &ldquo;File’s Owner&rdquo; attribute</p>
</blockquote>

<p>Click on the Pokemon.xib file in Xcode.<br/>
Click on the &ldquo;File&rsquo;s Owner&rdquo; outlet.<br/>
On the &ldquo;Identity inspector&rdquo; (top-right), set the Class to our recently created Pokemon.swift file.</p>

<p><a href="media/15036540820094/4YT3i.png"><img src="media/15036540820094/4YT3i.png" alt="Eleventh step"/></a></p>

<blockquote>
<p>POKEMONS!!!</p>
</blockquote>

<p>Yes! Drag and drop some Pokemons into your project to finish up our &ldquo;infrastructure&rdquo;.<br/>
Here we are adding two PGN files, 256x256, transparent.</p>

<p><a href="media/15036540820094/ibqxZ.png"><img src="media/15036540820094/ibqxZ.png" alt="Twelfth step"/></a></p>

<blockquote>
<p>Show me code already.</p>
</blockquote>

<p>All right, all right.<br/>
Time to add some code to our Pokemon.swift class.</p>

<p>It&rsquo;s actually pretty simple:</p>

<ol>
<li>Implement required initializers</li>
<li>Load the XIB file</li>
<li>Configure the view that will display the XIB file</li>
<li>Show the above view</li>
</ol>

<p>Add the following code to the Pokemon.swift class:</p>

<pre><code>import UIKit

class Pokemon: UIView {

    // MARK: - Initializers

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setupView()
    }

    // MARK: - Private Helper Methods

    // Performs the initial setup.
    private func setupView() {
        let view = viewFromNibForClass()
        view.frame = bounds

        // Auto-layout stuff.
        view.autoresizingMask = [
            UIViewAutoresizing.flexibleWidth,
            UIViewAutoresizing.flexibleHeight
        ]

        // Show the view.
        addSubview(view)
    }

    // Loads a XIB file into a view and returns this view.
    private func viewFromNibForClass() -&gt; UIView {

        let bundle = Bundle(for: type(of: self))
        let nib = UINib(nibName: String(describing: type(of: self)), bundle: bundle)
        let view = nib.instantiate(withOwner: self, options: nil).first as! UIView

        /* Usage for swift &lt; 3.x
        let bundle = NSBundle(forClass: self.dynamicType)
        let nib = UINib(nibName: String(self.dynamicType), bundle: bundle)
        let view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView
        */

        return view
    }
}

</code></pre>

<blockquote>
<p>@IBDesignable and @IBInspectable</p>
</blockquote>

<p>By adding <code>@IBDesignable</code> to your class, you make possible for it to live-render in Interface Builder.<br/>
By adding <code>@IBInspectable</code> to the properties of your class, you can see your custom views changing in Interface Builder as soon as you modify those properties.</p>

<p>Let&rsquo;s make the <code>Image View</code> of our custom view &ldquo;Inspectable&rdquo;.</p>

<p>First, hook up the <code>Image View</code> from the Pokemon.xib file to the Pokemon.swift class.</p>

<p><a href="media/15036540820094/Dxyv2.png"><img src="media/15036540820094/Dxyv2.png" alt="Thirteenth step"/></a></p>

<p>Call the outlet <code>imageView</code> and then add the following code (notice the <code>@IBDesignable</code> before the class name):</p>

<pre><code>@IBDesignable class Pokemon: UIView {

    // MARK: - Properties

    @IBOutlet weak var imageView: UIImageView!

    @IBInspectable var image: UIImage? {
        get {
            return imageView.image
        }
        set(image) {
            imageView.image = image
        }
    }

    // MARK: - Initializers
    ...

</code></pre>

<blockquote>
<p>Using your Custom Views</p>
</blockquote>

<p>Got to your Main storyboard file, drag a UIView into it.<br/>
Resize the view to, say 200x200. Centralize.<br/>
Go to the Identity inspector (top-right) and set the Class to Pokemon.</p>

<p><a href="media/15036540820094/Iah3Y.png"><img src="media/15036540820094/Iah3Y.png" alt="Fourteenth steps"/></a></p>

<p>To select a Pokemon, go to the Attribute Inspector (top-right) and select one of the Pokemon images you previously added using the awesome <code>@IBInspectable</code> image property.</p>

<p><a href="media/15036540820094/727mm.png"><img src="media/15036540820094/727mm.png" alt="Fifteenth step"/></a></p>

<p>Now duplicate your custom Pokemon view.<br/>
Give it a different size, say 150x150.<br/>
Choose another Pokemon image, observe:</p>

<p><a href="media/15036540820094/xrTXw.png"><img src="media/15036540820094/xrTXw.png" alt="Sixteenth step"/></a></p>

<p>Now we are going to add more logic to that self-containing custom UI element.<br/>
The button will allow Pokemons to be enabled/disabled.</p>

<p>Create an <code>IBAction</code> from the Switch button to the Pokemon.swift class.<br/>
Call the action something like <code>switchTapped</code>.<br/>
Add the following code to it:</p>

<pre><code>// MARK: - Actions

@IBAction func switchTapped(sender: UISwitch) {
    imageView.alpha = sender.on ? 1.0 : 0.2
}

// MARK: - Initializers
...

</code></pre>

<p>Final result:</p>

<p><a href="media/15036540820094/DQJvO.gif"><img src="media/15036540820094/DQJvO.gif" alt="Final"/></a></p>

<p>You are done!<br/>
Now you can create complex custom views and reuse them anywhere you want.<br/>
This will increase productivity while isolating code into self-contained UI elements.</p>

<p><a href="https://github.com/singledev/custom-uiviews-from-xib">The final project can be cloned in Github.</a><br/>
(<strong>Updated to Swift 3.1</strong>)</p></li>
</ul>

<h2 id="toc_1"><a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/11599/how-to-make-custom-reusable-uiview-using-xib">How to make custom reusable UIView using XIB</a></h2>

<p>Following example shows steps involved in initializing a view from XIB.</p>

<p>This is not a complex operation but exact steps need to be followed in order to do it right way first time, avoiding exceptions.</p>

<p><a href="http://stackoverflow.com/questions/20323393/how-does-loadnibnamed-work-uiview-outlets-not-initializing-using-loadnibnamed">How does loadNibNamed Works</a></p>

<p>Main steps are:</p>

<ol>
<li>Create XIB</li>
<li>Create class .h and .m</li>
<li>Define outlets in .h</li>
<li><p>Connect outlets between .h and XIB</p>

<p>See attached screenshot:</p>

<p><a href="media/15036540820094/rSBw6.png"><img src="media/15036540820094/rSBw6.png" alt="Label Object connected to myLabel IBOutlet UILabel variable"/></a></p></li>
<li><p>Invoke loadNibNamed inside initWithCoder function of .m file. This is needed to ensure you can directly place UIView object into storyboard / Parent UIView XIB file and define it as your custom view. No other initialization code is needed once you load the storyboard / parent XIB. Your custom view can be added to other views just like other built-in Objective C view objects given in XCode.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath]]></title>
    <link href="http://www.citynight.cn/Blog/15036524793322.html"/>
    <updated>2017-08-25T17:14:39+08:00</updated>
    <id>http://www.citynight.cn/Blog/15036524793322.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>

<h2 id="toc_0"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/13624/designing-and-drawing-a-bezier-path">Designing and drawing a Bezier Path</a></h2>

<p>This example shows the process from designing the shape you want to drawing it on a view. A specific shap is used but the concepts you learn can be applied to any shape.</p>

<h3 id="toc_1">How to draw a <a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html">Bézier path</a> in a custom view</h3>

<p>These are the main steps:</p>

<ol>
<li>Design the outline of the shape you want.</li>
<li>Divide the outline path into segments of lines, arcs, and curves.</li>
<li>Build that path programmatically.</li>
<li>Draw the path either in <code>drawRect</code> or using a <code>CAShapeLayer</code>.</li>
</ol>

<h3 id="toc_2">Design shape outline</h3>

<p>You could do anything, but as an example I have chosen the shape below. It could be a popup key on a keyboard.</p>

<p><a href="media/15036524793322/geckR.png"><img src="media/15036524793322/geckR.png" alt="enter image description here"/></a></p>

<h3 id="toc_3">Divide the path into segments</h3>

<p>Look back at your shape design and break it down into simpler elements of lines (for straight lines), arcs (for circles and round corners), and curves (for anything else).</p>

<p>Here is what our example design would look like:</p>

<p><a href="media/15036524793322/4mkcI.png"><img src="media/15036524793322/4mkcI.png" alt="enter image description here"/></a></p>

<ul>
<li>Black are line segments</li>
<li>Light blue are arc segments</li>
<li>Red are curves</li>
<li>Orange dots are the control points for the curves</li>
<li>Green dots are the points between path segments</li>
<li>Dotted lines show the bounding rectangle</li>
<li>Dark blue numbers are the segments in the order that they will be added programmatically</li>
</ul>

<h3 id="toc_4">Build the path programmatically</h3>

<p>We&rsquo;ll arbitrarily start in the bottom left corner and work clockwise. I&rsquo;ll use the grid in the image to get the x and y values for the points. I&rsquo;ll hardcode everything here, but of course you wouldn&rsquo;t do that in a real project.</p>

<p>The basic process is:</p>

<ol>
<li>Create a new <code>UIBezierPath</code></li>
<li>Choose a starting point on the path with <code>moveToPoint</code></li>
<li><p>Add segments to the path</p></li>
</ol>

<ul>
<li>line: <code>addLineToPoint</code></li>
<li>arc: <code>addArcWithCenter</code></li>
<li><p>curve: <code>addCurveToPoint</code></p></li>
</ul>

<ol>
<li>Close the path with <code>closePath</code></li>
</ol>

<p>Here is the code to make the path in the image above.</p>

<pre><code>func createBezierPath() -&gt; UIBezierPath {

    // create a new path
    let path = UIBezierPath()

    // starting point for the path (bottom left)
    path.moveToPoint(CGPoint(x: 2, y: 26))

    // *********************
    // ***** Left side *****
    // *********************

    // segment 1: line
    path.addLineToPoint(CGPoint(x: 2, y: 15))

    // segment 2: curve
    path.addCurveToPoint(CGPoint(x: 0, y: 12), // ending point
        controlPoint1: CGPoint(x: 2, y: 14),
        controlPoint2: CGPoint(x: 0, y: 14))

    // segment 3: line
    path.addLineToPoint(CGPoint(x: 0, y: 2))

    // *********************
    // ****** Top side *****
    // *********************

    // segment 4: arc
    path.addArcWithCenter(CGPoint(x: 2, y: 2), // center point of circle
        radius: 2, // this will make it meet our path line
        startAngle: CGFloat(M_PI), // π radians = 180 degrees = straight left
        endAngle: CGFloat(3*M_PI_2), // 3π/2 radians = 270 degrees = straight up
        clockwise: true) // startAngle to endAngle goes in a clockwise direction

    // segment 5: line
    path.addLineToPoint(CGPoint(x: 8, y: 0))

    // segment 6: arc
    path.addArcWithCenter(CGPoint(x: 8, y: 2),
        radius: 2,
        startAngle: CGFloat(3*M_PI_2), // straight up
        endAngle: CGFloat(0), // 0 radians = straight right
        clockwise: true)

    // *********************
    // ***** Right side ****
    // *********************

    // segment 7: line
    path.addLineToPoint(CGPoint(x: 10, y: 12))

    // segment 8: curve
    path.addCurveToPoint(CGPoint(x: 8, y: 15), // ending point
        controlPoint1: CGPoint(x: 10, y: 14),
        controlPoint2: CGPoint(x: 8, y: 14))

    // segment 9: line
    path.addLineToPoint(CGPoint(x: 8, y: 26))

    // *********************
    // **** Bottom side ****
    // *********************

    // segment 10: line
    path.closePath() // draws the final line to close the path

    return path
}
</code></pre>

<p>Note: Some of the above code can be reduced by adding a line and an arc in a single command (since the arc has an implied starting point). See <a href="http://ronnqvi.st/thinking-like-a-bzier-path/">here</a> for more details.</p>

<h3 id="toc_5">Draw the path</h3>

<p>We can draw the path either in a layer or in <code>drawRect</code>.</p>

<p><strong>Method 1: Draw path in a layer</strong></p>

<p>Our custom class looks like this. We add our Bezier path to a new <code>CAShapeLayer</code> when the view is initialized.</p>

<pre><code>import UIKit
class MyCustomView: UIView {

    override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    func setup() {

        // Create a CAShapeLayer
        let shapeLayer = CAShapeLayer()

        // The Bezier path that we made needs to be converted to 
        // a CGPath before it can be used on a layer.
        shapeLayer.path = createBezierPath().CGPath

        // apply other properties related to the path
        shapeLayer.strokeColor = UIColor.blueColor().CGColor
        shapeLayer.fillColor = UIColor.whiteColor().CGColor
        shapeLayer.lineWidth = 1.0
        shapeLayer.position = CGPoint(x: 10, y: 10)

        // add the new layer to our custom view
        self.layer.addSublayer(shapeLayer)
    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>

<p>And creating our view in the View Controller like this</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // create a new UIView and add it to the view controller
    let myView = MyCustomView()
    myView.frame = CGRect(x: 100, y: 100, width: 50, height: 50)
    myView.backgroundColor = UIColor.yellowColor()
    view.addSubview(myView)

}
</code></pre>

<p>We get&hellip;</p>

<p><a href="media/15036524793322/oELys.png"><img src="media/15036524793322/oELys.png" alt="enter image description here"/></a></p>

<p>Hmm, that&rsquo;s a little small because I hardcoded all the numbers in. I can scale the path size up, though, like this:</p>

<pre><code>let path = createBezierPath()
let scale = CGAffineTransformMakeScale(2, 2)
path.applyTransform(scale)
shapeLayer.path = path.CGPath
</code></pre>

<p><a href="media/15036524793322/LXvPc.png"><img src="media/15036524793322/LXvPc.png" alt="enter image description here"/></a></p>

<p><strong>Method 2: Draw path in <code>drawRect</code></strong></p>

<p>Using <code>drawRect</code> is slower than drawing to the layer, so this is not the recommended method if you don&rsquo;t need it.</p>

<p>Here is the revised code for our custom view:</p>

<pre><code>import UIKit
class MyCustomView: UIView {

    override func drawRect(rect: CGRect) {

        // create path (see previous code)
        let path = createBezierPath()

        // fill
        let fillColor = UIColor.whiteColor()
        fillColor.setFill()

        // stroke
        path.lineWidth = 1.0
        let strokeColor = UIColor.blueColor()
        strokeColor.setStroke()

        // Move the path to a new location
        path.applyTransform(CGAffineTransformMakeTranslation(10, 10))

        // fill and stroke the path (always do these last)
        path.fill()
        path.stroke()

    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>

<p>which gives us the same result&hellip;</p>

<p><a href="media/15036524793322/2hqMa.png"><img src="media/15036524793322/2hqMa.png" alt="enter image description here"/></a></p>

<h3 id="toc_6">Further study</h3>

<p>Excellent articles for understanding Bezier paths.</p>

<ul>
<li><a href="http://ronnqvi.st/thinking-like-a-bzier-path/">Thinking like a Bézier path</a> (Everything I&rsquo;ve ever read from this author is good and the inspiration for my example above came from here.)</li>
<li><a href="https://www.youtube.com/watch?v=dXECQRlmIaE">Coding Math: Episode 19 - Bezier Curves</a> (entertaining and good visual illustrations)</li>
<li><a href="https://www.youtube.com/watch?v=Qu-QK3uoMdY">Bezier Curves</a> (how they are used in graphics applications)</li>
<li><a href="https://www.youtube.com/watch?v=2HvH9cmHbG4">Bezier Curves</a> (good description of how the mathematical formulas are derived)</li>
</ul>

<h3 id="toc_7">Notes</h3>

<ul>
<li>This example originally comes from <a href="http://stackoverflow.com/a/34659468/3681880">this Stack Overflow answer</a>.</li>
<li>In your actual projects you probably shouldn&rsquo;t use hard coded numbers, but rather get the sizes from your view&rsquo;s bounds.</li>
</ul>

<hr/>

<h2 id="toc_8"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10890/how-to-apply-corner-radius-to-rectangles-drawn-by-uibezierpath">How to apply corner radius to rectangles drawn by UIBezierPath</a></h2>

<p><em>Corner radius for all 4 edges:</em></p>

<p><a href="media/15036524793322/O8qTg.png"><img src="media/15036524793322/O8qTg.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) cornerRadius: 11];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>Corner radius for top-left edge:</em></p>

<p><a href="media/15036524793322/OEOJa.png"><img src="media/15036524793322/OEOJa.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>Corner radius for top-right edge:</em></p>

<p><a href="media/15036524793322/1xhp8.png"><img src="media/15036524793322/1xhp8.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom-left edge:</em></p>

<p><a href="media/15036524793322/yqd87.png"><img src="media/15036524793322/yqd87.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom-right edge:</em></p>

<p><a href="media/15036524793322/AIgP0.png"><img src="media/15036524793322/AIgP0.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for bottom edges:</em></p>

<p><a href="media/15036524793322/4BrrS.png"><img src="media/15036524793322/4BrrS.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p><em>corner radius for top edges:</em></p>

<p><a href="media/15036524793322/lecWo.png"><img src="media/15036524793322/lecWo.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<hr/>

<h2 id="toc_9"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10893/how-to-apply-shadows-to-uibezierpath">How to apply shadows to UIBezierPath</a></h2>

<p>Consider a simple rectangle that is drawn by the bezier path.</p>

<p><a href="media/15036524793322/imDTW.png"><img src="media/15036524793322/imDTW.png" alt="enter image description here"/></a></p>

<pre><code> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
 [UIColor.grayColor setFill];
 [rectanglePath fill];
</code></pre>

<p><em>Basic Outer-fill shadow:</em></p>

<p><a href="media/15036524793322/mqiIV.png"><img src="media/15036524793322/mqiIV.png" alt="enter image description here"/></a></p>

<pre><code>CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(7.1, 5.1)];
[shadow setShadowBlurRadius: 5];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
CGContextSaveGState(context);
CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [shadow.shadowColor CGColor]);
[UIColor.grayColor setFill];
[rectanglePath fill];
CGContextRestoreGState(context);
</code></pre>

<p><em>Basic Inner fill shadow:</em></p>

<p><a href="media/15036524793322/C1rZk.png"><img src="media/15036524793322/C1rZk.png" alt="enter image description here"/></a></p>

<pre><code>CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(9.1, -7.1)];
[shadow setShadowBlurRadius: 6];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
[UIColor.grayColor setFill];
[rectanglePath fill];

CGContextSaveGState(context);
UIRectClip(rectanglePath.bounds);
CGContextSetShadowWithColor(context, CGSizeZero, 0, NULL);

CGContextSetAlpha(context, CGColorGetAlpha([shadow.shadowColor CGColor]));
CGContextBeginTransparencyLayer(context, NULL);
{
    UIColor* opaqueShadow = [shadow.shadowColor colorWithAlphaComponent: 1];
    CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [opaqueShadow CGColor]);
    CGContextSetBlendMode(context, kCGBlendModeSourceOut);
    CGContextBeginTransparencyLayer(context, NULL);

    [opaqueShadow setFill];
    [rectanglePath fill];

    CGContextEndTransparencyLayer(context);
}
CGContextEndTransparencyLayer(context);
CGContextRestoreGState(context);
</code></pre>

<h2 id="toc_10"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10891/how-to-create-a-simple-shapes-using-uibezierpath">How to create a simple shapes using UIBezierPath</a></h2>

<p><em>For a simple circle:</em></p>

<p><a href="media/15036524793322/ymoay.png"><img src="media/15036524793322/ymoay.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let ovalPath = UIBezierPath(ovalInRect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>

<p><em>For a simple Rectangle:</em></p>

<p><a href="media/15036524793322/C1GFH.png"><img src="media/15036524793322/C1GFH.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
rectanglePath.fill()
</code></pre>

<p><em>For a simple Line:</em></p>

<p><a href="media/15036524793322/KIAOK.png"><img src="media/15036524793322/KIAOK.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* bezierPath = [UIBezierPath bezierPath];
[bezierPath moveToPoint: CGPointMake(x1,y1)];
[bezierPath addLineToPoint: CGPointMake(x2,y2)];
[UIColor.blackColor setStroke];
bezierPath.lineWidth = 1;
[bezierPath stroke];
</code></pre>

<p>Swift:</p>

<pre><code>let bezierPath = UIBezierPath()
bezierPath.moveToPoint(CGPoint(x: x1, y: y1))
bezierPath.addLineToPoint(CGPoint(x: x2, y: y2))
UIColor.blackColor().setStroke()
bezierPath.lineWidth = 1
bezierPath.stroke()
</code></pre>

<p><em>For a half circle:</em></p>

<p><a href="media/15036524793322/3Nywj.png"><img src="media/15036524793322/3Nywj.png" alt="enter image description here"/></a></p>

<pre><code> CGRect ovalRect = CGRectMake(x,y,width,height);
UIBezierPath* ovalPath = [UIBezierPath bezierPath];
[ovalPath addArcWithCenter: CGPointMake(0, 0) radius: CGRectGetWidth(ovalRect) / 2 startAngle: 180 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
[ovalPath addLineToPoint: CGPointMake(0, 0)];
[ovalPath closePath];

CGAffineTransform ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect));
ovalTransform = CGAffineTransformScale(ovalTransform, 1, CGRectGetHeight(ovalRect) / CGRectGetWidth(ovalRect));
[ovalPath applyTransform: ovalTransform];

[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let ovalRect = CGRect(x: 0, y: 0, width: 50, height: 50)
let ovalPath = UIBezierPath()
ovalPath.addArcWithCenter(CGPoint.zero, radius: ovalRect.width / 2, startAngle: 180 * CGFloat(M_PI)/180, endAngle: 0 * CGFloat(M_PI)/180, clockwise: true)
ovalPath.addLineToPoint(CGPoint.zero)
ovalPath.closePath()

var ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect))
ovalTransform = CGAffineTransformScale(ovalTransform, 1, ovalRect.height / ovalRect.width)
ovalPath.applyTransform(ovalTransform)

UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>

<p><em>For a simple triangle:</em></p>

<p><a href="media/15036524793322/5r6IE.png"><img src="media/15036524793322/5r6IE.png" alt="enter image description here"/></a></p>

<pre><code>UIBezierPath* polygonPath = [UIBezierPath bezierPath];
[polygonPath moveToPoint: CGPointMake(x1, y1)];
[polygonPath addLineToPoint: CGPointMake(x2, y2)];
[polygonPath addLineToPoint: CGPointMake(x3, y2)];
[polygonPath closePath];
[UIColor.grayColor setFill];
[polygonPath fill];
</code></pre>

<p>Swift:</p>

<pre><code>let polygonPath = UIBezierPath()
polygonPath.moveToPoint(CGPoint(x: x1, y: y1))
polygonPath.addLineToPoint(CGPoint(x: x2, y: y2))
polygonPath.addLineToPoint(CGPoint(x: x3, y: y3))
polygonPath.closePath()
UIColor.grayColor().setFill()
polygonPath.fill()
</code></pre>

<hr/>

<h2 id="toc_11"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/18109/pie-view-column-view-with-uibezierpath">pie view &amp; column view with UIBezierPath</a></h2>

<ul>
<li>pie view
<img src="media/15036524793322/oh0DL.png" alt="pie view"/></li>
</ul>

<pre><code>- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@30, @15, @5, @17, @3, @10, @20];

    // 1\. context
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    CGPoint center = CGPointMake(150, 150);
    CGFloat radius = 150;
    __block CGFloat startAngle = 0;
    [data enumerateObjectsUsingBlock:^(NSNumber * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {

        // 2\. create path
        CGFloat endAngle = obj.floatValue / 100 * M_PI * 2 + startAngle;
        UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
        [circlePath addLineToPoint:center];

        // 3\. add path
        CGContextAddPath(cxtRef, circlePath.CGPath);

        // set color
        [[UIColor colorWithRed:((float)arc4random_uniform(256) / 255.0) green:((float)arc4random_uniform(256) / 255.0) blue:((float)arc4random_uniform(256) / 255.0) alpha:1.0] setFill];

        // 4\. render
        CGContextDrawPath(cxtRef, kCGPathFill);

        // reset angle
        startAngle = endAngle;
    }];
}


override func draw(_ rect: CGRect) {
    // define data to create pie chart
    let data: [Int] = [30, 15, 5, 17, 3, 10, 20]

    // 1\. find center of draw rect
    let center: CGPoint = CGPoint(x: rect.midX, y: rect.midY)

    // 2\. calculate radius of pie
    let radius = min(rect.width, rect.height) / 2.0

    var startAngle: CGFloat = 0.0
    for value in data {

      // 3\. calculate end angle for slice
      let endAngle = CGFloat(value) / 100.0 * CGFloat.pi * 2.0 + startAngle

      // 4\. create UIBezierPath for slide
      let circlePath = UIBezierPath(arcCenter: center, radius: radius, startAngle: startAngle, endAngle: endAngle, clockwise: true)

      // 5\. add line to center to close path
      circlePath.addLine(to: center)

      // 6\. set fill color for current slice
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill slice path
      circlePath.fill()

      // 8\. set end angle as start angle for next slice
      startAngle = endAngle
    }
  }
</code></pre>

<ul>
<li>column view
<img src="media/15036524793322/ayD5Y.png" alt="column view"/></li>
</ul>

<pre><code>- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@300, @150.65, @55.3, @507.7, @95.8, @700, @650.65];

    // 1.
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    NSInteger columnCount = 7;
    CGFloat width = self.bounds.size.width / (columnCount + columnCount - 1);
    for (NSInteger i = 0; i 

override func draw(_ rect: CGRect) {
    // define data for chart
    let data: [CGFloat] = [300, 150.65, 55.3, 507.7, 95.8, 700, 650.65]

    // 1\. calculate number of columns
    let columnCount = data.count

    // 2\. calculate column width
    let columnWidth = rect.width / CGFloat(columnCount + columnCount - 1)

    for (columnIndex, value) in data.enumerated() {
      // 3\. calculate column height
      let columnHeight = value / 1000.0 * rect.height

      // 4\. calculate column origin
      let columnOrigin = CGPoint(x: (columnWidth * 2.0 * CGFloat(columnIndex)), y: (rect.height - columnHeight))

      // 5\. create path for column
      let columnPath = UIBezierPath(rect: CGRect(origin: columnOrigin, size: CGSize(width: columnWidth, height: columnHeight)))

      // 6\. set fill color for current column
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill column path
      columnPath.fill()
    }
  }
</code></pre>

<hr/>

<h2 id="toc_12"><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10892/uibezierpath-autolayout">UIBezierPath + AutoLayout</a></h2>

<p>For bezier path to get resized based on the view frame, override the drawRect of view that you are drawing the bezier path :</p>

<pre><code>- (void)drawRect:(CGRect)frame
{
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), CGRectGetWidth(frame), CGRectGetHeight(frame))];
    [UIColor.grayColor setFill];
    [rectanglePath fill];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD(Grand Central Dispatch)]]></title>
    <link href="http://www.citynight.cn/Blog/15035627499170.html"/>
    <updated>2017-08-24T16:19:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/15035627499170.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>

<p>Grand Central Dispatch (GCD) is Apple&rsquo;s answer to multithreading. It is a lightweight framework for performing tasks synchronously or asynchronously in queues and handles CPU threads for you behind the scenes.</p>

<h2 id="toc_0">Dispatch Semaphore</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28284/dispatch-semaphore">Stack Overflow地址</a></p>

<blockquote>
<p>DispatchSemaphore provides an efficient implementation of a traditional counting semaphore, which can be used to control access to a resource across multiple execution contexts.</p>
</blockquote>

<p>A scenario for when to use a semaphore could be if you are doing some file reading/writing, if multiple tasks are trying to read and write from file at the same time, it could increase your performance to make each task wait its turn so as to not overburden the I/O controller.</p>

<pre><code>func do2TasksAtATime () {
    print(&quot;starting long running tasks (2 at a time)&quot;)
    let sem = DispatchSemaphore(value: 2)            //this semaphore only allows 2 tasks to run at the same time (the resource count)
    for i in 0...7 {                                 //launch a bunch of tasks
        DispatchQueue.global().async {               //run tasks on a background thread
            sem.wait()                               //wait here if no resources available
            sleep(2)                                 //do some long task eg file access (here we are just sleeping for a 2 seconds for demonstration purposes)
            print(&quot;long task \(i) done! \(Date())&quot;)
            sem.signal()                             //let the semaphore know this resource is now available
        }
    }
}
</code></pre>

<p>Example output: (notice the time stamps)</p>

<pre><code>starting long running tasks (2 at a time)
long task 0 done! 2017-02-16 07:11:53 +0000
long task 1 done! 2017-02-16 07:11:53 +0000
long task 2 done! 2017-02-16 07:11:55 +0000
long task 3 done! 2017-02-16 07:11:55 +0000
long task 5 done! 2017-02-16 07:11:57 +0000
long task 4 done! 2017-02-16 07:11:57 +0000
long task 6 done! 2017-02-16 07:11:59 +0000
long task 7 done! 2017-02-16 07:11:59 +0000
</code></pre>

<h2 id="toc_1">Dispatch Group</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28278/dispatch-group">Stack Overflow地址</a></p>

<blockquote>
<p>DispatchGroup allows for aggregate synchronization of work. You can use them to submit multiple different work items and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.</p>
</blockquote>

<p>A Scenario when this could be useful is if you have multiple webservice calls that all need to finish before continuing. For example, you need to download multiple sets of data that needs to be processed by some function. You have to wait for all webservices to complete before calling the function to process all the received data.</p>

<p><strong>Swift 3</strong></p>

<pre><code>func doLongTasksAndWait () {
    print(&quot;starting long running tasks&quot;)
    let group = DispatchGroup()          //create a group for a bunch of tasks we are about to do
    for i in 0...3 {                     //launch a bunch of tasks (eg a bunch of webservice calls that all need to be finished before proceeding to the next ViewController)
        group.enter()                    //let the group know that something is being added
        DispatchQueue.global().async {   //run tasks on a background thread
            sleep(arc4random() % 4)      //do some long task eg webservice or database lookup (here we are just sleeping for a random amount of time for demonstration purposes)
            print(&quot;long task \(i) done!&quot;)
            group.leave()                //let group know that the task is finished
        }
    }
    group.wait()                         //will block whatever thread we are on here until all the above tasks have finished (so maybe dont use this function on your main thread)
    print(&quot;all tasks done!&quot;)
}
</code></pre>

<p>Alternatively, if you do not want to wait for the groups to finish, but instead want to run a function once all the tasks have completed, use the <code>notify</code> function in place of the <code>group.wait()</code></p>

<pre><code>group.notify(queue: DispatchQueue.main) { //the queue: parameter is which queue this block will run on, if you need to do UI updates, use the main queue
    print(&quot;all tasks done!&quot;)              //this will execute when all tasks have left the group
}
</code></pre>

<p>Example output:</p>

<pre><code>starting long running tasks
long task 0 done!
long task 3 done!
long task 1 done!
long task 2 done!
all tasks done!
</code></pre>

<h2 id="toc_2">Serial vs Concurrent Dispatch Queues</h2>

<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28286/serial-vs-concurrent-dispatch-queues">Stack Overflow地址</a><br/>
<strong>Serial Queue</strong></p>

<pre><code>func serialQueues () {
    let serialQueue = DispatchQueue(label: &quot;com.example.serial&quot;) //default queue type is a serial queue
    let start = Date ()
    for i in 0...3 {                                             //launch a bunch of tasks
        serialQueue.async {                                      //run tasks on a background thread, using our serial queue
            sleep(2)                                             //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;serial long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>

<p>Example output:</p>

<pre><code>serial long task 0 done! total time taken: 2.07241100072861
serial long task 1 done! total time taken: 4.16347700357437
serial long task 2 done! total time taken: 6.23209798336029
serial long task 3 done! total time taken: 8.30682599544525
</code></pre>

<p><strong>Concurrent Queue</strong></p>

<pre><code>func concurrentQueues () {
    let concurrentQueue = DispatchQueue(label: &quot;com.example.concurrent&quot;, attributes: .concurrent) //explicitly specify the queue to be a concurrent queue
    let start = Date ()
    for i in 0...3 {            //launch a bunch of tasks
        concurrentQueue.async { //run tasks on a background thread, using our concurrent queue
            sleep(2)            //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;concurrent long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>

<p>Example output:</p>

<pre><code>concurrent long task 3 done! total time taken: 2.07092100381851
concurrent long task 0 done! total time taken: 2.07087397575378
concurrent long task 2 done! total time taken: 2.07086700201035
concurrent long task 1 done! total time taken: 2.07089096307755
</code></pre>

<p><strong>Discussion</strong></p>

<p>As we can see from the examples above, a serial queue will complete each task in the order they are submitted to the queue. Each task will wait for the previous task to finish before executing. As for the concurrent queue, each task does not wait on the others in the queue and executes as soon as possible; the advantage is that all tasks on the queue will run at the same time on separate threads, making a concurrent queue take less time than a serial queue.</p>

<p>If order of execution of tasks is not important, always use a concurrent queue for the best efficiency.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打包后出现 Undefined symbols for architecture i386]]></title>
    <link href="http://www.citynight.cn/Blog/14963702971919.html"/>
    <updated>2017-06-02T10:24:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/14963702971919.html</id>
    <content type="html"><![CDATA[
<p>出现问题:<br/>
自己打framework真机与模拟器合并后在使用的时候提示 <code>Undefined symbols for architecture i386</code></p>

<p>原因: 打framework的时候使用的是<code>debug</code> 改为<code>release</code><br/>
<img src="media/14963702971919/14963704118450.jpg" alt=""/></p>

<p><strong>合并命令:</strong></p>

<p><code>lipo -create 真机(或者模拟器)framework地址 模拟器(或者真机)ramework地址 -output 输出地址(一般我选择真机framework地址)</code></p>

<p><strong>查看信息:</strong></p>

<p><code>lipo -info 真机(或者模拟器)framework地址</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 文件、磁盘管理]]></title>
    <link href="http://www.citynight.cn/Blog/14954528363090.html"/>
    <updated>2017-05-22T19:33:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954528363090.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.文件管理</h2>

<h3 id="toc_1">查看文件信息：ls</h3>

<p>ls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于DOS下的dir命令。</p>

<p><code>Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。</code></p>

<p>ls常用参数：</p>

<table>
<thead>
<tr>
<th style="text-align: center">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td style="text-align: center">-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td style="text-align: center">-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>

<p><img src="media/14954528363090/14954529185223.jpg" alt=""/></p>

<p>图中列出的信息含义如下图所示：</p>

<p><img src="media/14954528363090/14954529393080.jpg" alt=""/></p>

<p>与DOS下的文件操作类似，在Unix/Linux系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p>

<table>
<thead>
<tr>
<th style="text-align: left">通配符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">*</td>
<td>文件代表文件名中所有字符</td>
</tr>
<tr>
<td style="text-align: left">ls te*</td>
<td>查找以te开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls *html</td>
<td>查找结尾为html的文件</td>
</tr>
<tr>
<td style="text-align: left">？</td>
<td>代表文件名中任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls ?.c</td>
<td>只找第一个字符任意，后缀为.c的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a.?</td>
<td>只找只有3个字符，前2字符为a.，最后一个字符任意的文件</td>
</tr>
<tr>
<td style="text-align: left">[]</td>
<td>[”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。</td>
</tr>
<tr>
<td style="text-align: left">[abc]</td>
<td>匹配a、b、c中的任意一个</td>
</tr>
<tr>
<td style="text-align: left">[a-f]</td>
<td>匹配从a到f范围内的的任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls [a-f]*</td>
<td>找到从a到f范围内的的任意一个字符开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a-f</td>
<td>查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用</td>
</tr>
<tr>
<td style="text-align: left">\</td>
<td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。</td>
</tr>
<tr>
<td style="text-align: left">ls *a</td>
<td>查找文件名为*a的文件</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">输出重定向命令：&gt;</h3>

<p>Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p>

<p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p>

<p><img src="media/14954528363090/14954530933243.jpg" alt=""/><br/>
注意： <code>&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。</code></p>

<h3 id="toc_3">分屏显示：more</h3>

<p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助。</p>

<p><img src="media/14954528363090/14954533115641.jpg" alt=""/></p>

<h3 id="toc_4">管道：|</h3>

<p>管道：一个命令的输出可以通过管道做为另一个命令的输入。</p>

<p>管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。</p>

<p><img src="media/14954528363090/14954534699128.jpg" alt=""/></p>

<h3 id="toc_5">清屏：clear</h3>

<p>clear作用为清除终端上的显示(类似于DOS的cls清屏功能)，也可使用快捷键：Ctrl + l ( “l” 为字母 )。</p>

<h3 id="toc_6">切换工作目录： cd</h3>

<p>在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。<code>Linux所有的目录和文件名大小写敏感</code></p>

<p>cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">cd</td>
<td>切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。</td>
</tr>
<tr>
<td style="text-align: left">cd ~</td>
<td>切换到当前用户的主目录(/home/用户目录)</td>
</tr>
<tr>
<td style="text-align: left">cd .</td>
<td>切换到当前目录</td>
</tr>
<tr>
<td style="text-align: left">cd ..</td>
<td>切换到上级目录</td>
</tr>
<tr>
<td style="text-align: left">cd -</td>
<td>可进入上次所在的目录</td>
</tr>
</tbody>
</table>

<p><img src="media/14954528363090/14955894273051.jpg" alt=""/><br/>
注意：</p>

<ul>
<li>如果路径是从根路径开始的，则路径的前面需要加上 “ / ”，如 “ /mnt ”，通常进入某个目录里的文件夹，前面不用加 “ / ”。</li>
</ul>

<p><img src="media/14954528363090/14955900895519.jpg" alt=""/></p>

<h3 id="toc_7">显示当前路径：pwd</h3>

<p>使用pwd命令可以显示当前的工作目录，该命令很简单，直接输入pwd即可，后面不带参数。</p>

<h3 id="toc_8">创建目录：mkdir</h3>

<p>通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。</p>

<p>需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。<br/>
<img src="media/14954528363090/14955907314659.jpg" alt=""/></p>

<h3 id="toc_9">删除目录：rmdir</h3>

<p>可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。</p>

<h3 id="toc_10">删除文件：rm</h3>

<p>可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。</p>

<p>常用参数及含义如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-i</td>
<td>以进行交互式方式执行</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>递归地删除目录下的内容，删除文件夹时必须加此参数</td>
</tr>
</tbody>
</table>

<h3 id="toc_11">建立链接文件：ln</h3>

<p>Linux链接文件类似于Windows下的快捷方式。</p>

<p>链接文件分为软链接和硬链接。</p>

<p>软链接：软链接不占用磁盘空间，源文件删除则软链接失效。</p>

<p>硬链接：硬链接只能链接普通文件，不能链接目录。</p>

<p>使用格式：</p>

<pre><code>ln 源文件 链接文件
ln -s 源文件 链接文件

</code></pre>

<p>如果<code>没有-s</code>选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。</p>

<p>注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</p>

<h3 id="toc_12">查看或者合并文件内容：cat</h3>

<h3 id="toc_13">文本搜索：grep</h3>

<p>Linux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。</p>

<p>grep一般格式为：</p>

<pre><code>grep [-选项] ‘搜索内容串’文件名

</code></pre>

<p>在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-v</td>
<td>显示不包含匹配文本的所有行（相当于求反）</td>
</tr>
<tr>
<td style="text-align: left">-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>

<p>grep搜索内容串可以是正则表达式。</p>

<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>

<p>grep常用正则表达式：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><sup>a</sup></td>
<td>行首,搜寻以 m 开头的行；grep -n &lsquo;<sup>a&rsquo;</sup> 1.txt</td>
</tr>
<tr>
<td style="text-align: left">ke$</td>
<td>行尾,搜寻以 ke 结束的行；grep -n &lsquo;ke$&rsquo; 1.txt</td>
</tr>
<tr>
<td style="text-align: left">[Ss]igna[Ll]</td>
<td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n &lsquo;[Ss]igna[Ll]&rsquo; 1.txt</td>
</tr>
<tr>
<td style="text-align: left">.</td>
<td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n &lsquo;e.e&rsquo; 1.txt</td>
</tr>
</tbody>
</table>

<h3 id="toc_14">查找文件：find</h3>

<p>find命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</p>

<p>常用用法：</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">find ./ -name test.sh</td>
<td>查找当前目录下所有名为test.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name &lsquo;*.sh&rsquo;</td>
<td>查找当前目录下所有后缀为.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name &ldquo;[A-Z]*&rdquo;</td>
<td>查找当前目录下所有以大写字母开头的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size 2M</td>
<td>查找在/tmp 目录下等于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size +2M</td>
<td>查找在/tmp 目录下大于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size -2M</td>
<td>查找在/tmp 目录下小于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -size +4k -size -5M</td>
<td>查找当前目录下大于4k，小于5M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -perm 0777</td>
<td>查找当前目录下权限为 777 的文件或目录</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">拷贝文件：cp</h3>

<p>cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-a</td>
<td>该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>已经存在的目标文件而不提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>交互式复制，在覆盖目标文件之前将给出提示要求用户确认</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示拷贝进度</td>
</tr>
</tbody>
</table>

<p>cp vim_configure/ code/ -ivr 把文件夹 vim_configure 拷贝到 code 目录里：</p>

<p><strong>暂时缺图稍后补</strong></p>

<h3 id="toc_16">移动文件：mv</h3>

<p>用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</p>

<p>常用选项说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-f</td>
<td>禁止交互式操作，如有覆盖也不会给出提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示移动进度</td>
</tr>
</tbody>
</table>

<h3 id="toc_17">归档管理：tar</h3>

<p>计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。</p>

<p>tar使用格式 tar [参数] 打包文件名 文件</p>

<p>tar命令很特殊，其参数前面可以使用“-”，也可以不使用。</p>

<p>常用参数：</p>

<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td>
</tr>
<tr>
<td style="text-align: left">-t</td>
<td>列出档案中包含的文件</td>
</tr>
<tr>
<td style="text-align: left">-x</td>
<td>解开档案文件</td>
</tr>
</tbody>
</table>

<p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p>

<h3 id="toc_18">文件压缩解压：gzip</h3>

<p>tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。</p>

<p>gzip使用格式如下：</p>

<pre><code>gzip  [选项]  被压缩文件

</code></pre>

<p>常用选项：</p>

<p>|选项|含义| |-d|解压| |-r|压缩所有子目录|</p>

<p><strong>这里缺图</strong></p>

<p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p>

<p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 &hellip;</p>

<pre><code>-z ：指定压缩包的格式为：file.tar.gz

</code></pre>

<p>例如： tar zcvf test.tar.gz 1.c 2.c 3.c 4.c把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz<br/>
<strong>这里缺图</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 常用基本命令]]></title>
    <link href="http://www.citynight.cn/Blog/14954518367171.html"/>
    <updated>2017-05-22T19:17:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954518367171.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.命令使用方法</h2>

<p>Linux命令格式:</p>

<pre><code>    command  [-options]  [parameter1]  …
</code></pre>

<p>说明：</p>

<ul>
<li>command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，<code>[]代表可选</code> parameter1 …：传给命令的参数：可以是零个一个或多个</li>
</ul>

<p>例：</p>

<p><img src="media/14954518367171/14954519660499.jpg" alt=""/></p>

<h2 id="toc_1">2.查看帮助文档</h2>

<h3 id="toc_2"><1> &ndash;help</h3>

<p>一般是linux命令自带的帮助信息</p>

<p>如：ls &ndash;help</p>

<h3 id="toc_3"><2> man(有问题找男人，manual)</h3>

<p>man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明</p>

<p>该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>

<p>例：man ls ; man 2 printf</p>

<p>man中各个section意义如下：</p>

<ol>
<li>Standard commands（标准命令）</li>
<li>System calls（系统调用，如open,write）</li>
<li>Library functions（库函数，如printf,fopen）</li>
<li>Special devices（设备文件的说明，/dev下各种设备）</li>
<li>File formats（文件格式，如passwd）</li>
<li>Games and toys（游戏和娱乐）</li>
<li>Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</li>
<li>Administrative Commands（管理员命令，如ifconfig）</li>
</ol>

<p>man是按照手册的章节号的顺序进行搜索的。</p>

<p>man设置了如下的功能键：</p>

<table>
<thead>
<tr>
<th style="text-align: center">功能键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td style="text-align: center">Enter键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td style="text-align: center">f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td style="text-align: center">q</td>
<td>退出man命令</td>
</tr>
<tr>
<td style="text-align: center">h</td>
<td>列出所有功能键</td>
</tr>
<tr>
<td style="text-align: center">/word</td>
<td>搜索word字符串</td>
</tr>
</tbody>
</table>

<p><img src="media/14954518367171/14954525011190.jpg" alt=""/></p>

<p>注意：实际上，我们不用指定第几个章节也用查看，如，man ls</p>

<h2 id="toc_4">3.自动补全：</h2>

<p>在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>

<h2 id="toc_5">4.历史命令：</h2>

<p>当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux - 文件和目录]]></title>
    <link href="http://www.citynight.cn/Blog/14954377078014.html"/>
    <updated>2017-05-22T15:21:47+08:00</updated>
    <id>http://www.citynight.cn/Blog/14954377078014.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类Unix系统目录结构</h2>

<p>ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面</p>

<p><img src="media/14954377078014/14954378312055.jpg" alt=""/></p>

<h2 id="toc_1">Linux 目录</h2>

<ul>
<li>/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</li>
<li>/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。</li>
<li>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</li>
<li>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</li>
<li>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。</li>
<li>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</li>
<li>/opt：给主机额外安装软件所摆放的目录。</li>
<li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</li>
<li>/root：系统管理员root的家目录。</li>
<li>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li>
<li>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</li>
<li>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。</li>
<li>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。</li>
</ul>

<h2 id="toc_2">用户目录</h2>

<p>位于/home/user，称之为用户工作目录或家目录,表示方式：</p>

<pre><code>/home/user
~

</code></pre>

<h3 id="toc_3">相对路径和绝对路径</h3>

<h4 id="toc_4">绝对路径</h4>

<p>从/目录开始描述的路径为绝对路径，如：</p>

<pre><code>cd /home
ls /usr

</code></pre>

<h4 id="toc_5">相对路径</h4>

<p>从当前位置开始描述的路径为相对路径，如：</p>

<pre><code>cd ../../
ls abc/def

</code></pre>

<h4 id="toc_6">.和..</h4>

<p>每个目录下都有.和..</p>

<p>. 表示当前目录</p>

<p>.. 表示上一级目录，即父目录</p>

<p>根目录下的.和..都表示当前目录</p>

<h2 id="toc_7">文件权限</h2>

<p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p>

<p>Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>

<p>在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>

<h3 id="toc_8">访问用户</h3>

<p>通过设定权限可以从以下三种访问方式限制访问权限：</p>

<ul>
<li><p>只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。</p></li>
<li><p>允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。</p></li>
<li><p>允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类</p></li>
</ul>

<p>这有点类似于 QQ 空间的访问权限：<br/>
<img src="media/14954377078014/14954384555256.jpg" alt=""/></p>

<ul>
<li>这个 QQ 空间是属于我的，我相当于管理者（也就是“所有者”），我想怎么访问就怎么访问。</li>
<li>同时，我可以设置允许 QQ 好友访问，而这些 QQ 好友则类似于“用户组”。</li>
<li>当然，我可以允许所有人访问，这里的所有人则类似于“其他用户”。</li>
</ul>

<h3 id="toc_9">访问权限</h3>

<p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p>

<ul>
<li>读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</li>
<li>写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</li>
</ul>

<p>注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>

<h3 id="toc_10">示例说明</h3>

<p><img src="media/14954377078014/14954394260837.jpg" alt=""/><br/>
(图中  用户改为 用户组)</p>

<p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。</p>

<p>每一个用户都有它自身的读、写和执行权限。</p>

<ul>
<li>第一组权限控制访问自己的文件权限，即所有者权限。</li>
<li>第二组权限控制用户组访问其中一个用户的文件的权限。</li>
<li>第三组权限控制其他所有用户访问一个用户的文件的权限。</li>
</ul>

<p>这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目优化记录]]></title>
    <link href="http://www.citynight.cn/Blog/14919624884376.html"/>
    <updated>2017-04-12T10:01:28+08:00</updated>
    <id>http://www.citynight.cn/Blog/14919624884376.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">首页显示</h2>

<p>重点: 数据处理放在获取数据的时候,尽管这样数据不会实时更新,但是保证了数据显示的速度.<br/>
关于Cache, 目前使用数据库.关于异步访问要用 <code>safeAsync</code></p>

<pre><code>extension DispatchQueue {
    // This method will dispatch the `block` to self.
    // If `self` is the main queue, and current thread is main thread, the block
    // will be invoked immediately instead of being dispatched.
    func safeAsync(_ block: @escaping ()-&gt;()) {
        if self === DispatchQueue.main &amp;&amp; Thread.isMainThread {
            block()
        } else {
            async { block() }
        }
    }
}
</code></pre>

<h2 id="toc_1">Topbar 移除</h2>

<p>这个原有的导航对项目入侵太深,已经忍无可忍了&hellip;这周终于下决心移除它用原生的导航栏和自定义视图代替她..进展非常顺利.写了一天自定义控件,然后让大家各自把自己的控制过滤一遍.总耗时,我自己一天,其他同事不到1个小时.还是非常顺利的.用比较少的时间完成了项目中的毒瘤.</p>

<h2 id="toc_2">下拉刷新封装</h2>

<p>老版本使用的是<code>MJRefresh</code> 但是需要定制, 在老项目中我是通过继承完成的功能修改,这样做的原因是老项目是OC和Swift混编的,而且都是把第三方库源文件拖到项目中的方式进行的. 在重构的时候我把第三方库放到了公司的git上,然后更改源码.再打包成成库调用.</p>

<h2 id="toc_3">关于时间比较</h2>

<p>新项目中存在一个功能比如 <code>10:00:00</code> 到 <code>11:59:59</code> 算早市,需要判断当前时间是否是早市. 一种更方便的处理方式:</p>

<p>时间格式 <code>HH:mm:ss</code> 一共6位数字,我们可以去掉中间的<code>:</code>,这样时间就是一个整数了,然后三个整数之间进行比较比 先比小时再比分钟最后比秒数要方便很多.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 关于信号量]]></title>
    <link href="http://www.citynight.cn/Blog/14916349354566.html"/>
    <updated>2017-04-08T15:02:15+08:00</updated>
    <id>http://www.citynight.cn/Blog/14916349354566.html</id>
    <content type="html"><![CDATA[
<p>信号量的使用</p>

<p><img src="media/14916349354566/%E4%BF%A1%E5%8F%B7%E9%87%8F.gif" alt="信号量"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 读书笔记]]></title>
    <link href="http://www.citynight.cn/Blog/14907835920803.html"/>
    <updated>2017-03-29T18:33:12+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907835920803.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">单一职责原则(Single Responsibility Principe 简称SRP)</h2>

<blockquote>
<p>定义: 应该有且仅有一个原因引起类的变更.. </p>
</blockquote>

<h3 id="toc_1">对职责的定义,什么是类的职责,以及怎么划分类的职责.</h3>

<p>图书中 &lt;图1-1用户信息IUserInfo位图类图&gt; 中设计的有问题:<br/>
用户的属性和用户的行为没有分开,这是一个严重的错误.. 应该把用户的信息抽取成一个BO(Bussiness Object,业务对象),把行为抽取成一个Biz(Bussiness Logic,业务逻辑)</p>

<p>重新拆封成两个接口. IUserBO 负责用户的属性,简单的说就是收集和反馈用户的属性信息.IUserBiz负责用户的行为,完成用户信息的维护和变更.</p>

<h3 id="toc_2">好处</h3>

<ol>
<li>类的复杂性降低.实现什么职责都有清晰明确的定义了;</li>
<li>可读性提高.复杂性降低,当然可读性提高了;</li>
<li>可维护性提高.可读性提高,那当然更容易维护了;</li>
<li>变更引起的风险降低,变更时必不可少的.如果接口的单一职责做的好,一个接口的修改只对相应的实现类有影响,对其他的接口无影响,这对系统的扩展性和维护性都有非常大的帮助.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac zsh 使用命令打开sublime]]></title>
    <link href="http://www.citynight.cn/Blog/14907559721950.html"/>
    <updated>2017-03-29T10:52:52+08:00</updated>
    <id>http://www.citynight.cn/Blog/14907559721950.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1/添加</h2>

<p><code>vim .zshrc</code></p>

<p>添加 <br/>
 <code>alias subl=&quot;open -a Sublime\ Text&quot;</code>（如果你是Sublime Text ）<br/>
  或者<br/>
<code>alias subl=&quot;open -a Sublime\ Text\ 2&quot;</code> （如果你是Sublime Text 2）</p>

<h2 id="toc_1">2/生效</h2>

<p><code>source ~/.zshrc</code></p>

<h2 id="toc_2">3/测试</h2>

<p>在命令行输入：<br/>
    <code>subl</code>     就可以打开sublime</p>

<p>输入：<br/>
    <code>subl test.txt</code> 就可以打开文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 最近遇到的问题(3.8)]]></title>
    <link href="http://www.citynight.cn/Blog/14888974267202.html"/>
    <updated>2017-03-07T22:37:06+08:00</updated>
    <id>http://www.citynight.cn/Blog/14888974267202.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">把函数名当参数传递不释放</h2>

<p>控制器A 有一个函数 func  有一个视图 View ,如果控制器A 把函数 func 传递给 View 那么 控制器不释放</p>

<h2 id="toc_1">*** Assertion failure in -[UITableView dequeueReusableCellWithIdentifier:forIndexPath:]</h2>

<p>产生原因: 同一个控制器,里面有一个代码添加的tableView,然后这个控制器又添加了一个xib视图,xib视图中有tableView,并且设置tableView的数据源和代理方法为filesowner,导致崩溃.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组传递]]></title>
    <link href="http://www.citynight.cn/Blog/14878335740172.html"/>
    <updated>2017-02-23T15:06:14+08:00</updated>
    <id>http://www.citynight.cn/Blog/14878335740172.html</id>
    <content type="html"><![CDATA[
<p>把A控制器中的数组 传递给 B  ,然后 B 再把数据传递给 C <br/>
这时如果 A中数组进行了修改,那么 C 中数据也会修改</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[synchronized(object)]]></title>
    <link href="http://www.citynight.cn/Blog/14877545165696.html"/>
    <updated>2017-02-22T17:08:36+08:00</updated>
    <id>http://www.citynight.cn/Blog/14877545165696.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>synchronized关键字代表这个方法加锁,相当于不管哪一个线 程A每次运行到这个法时,都要检查有没有其它正在用这个方法的线程B（或者C D等）,有的话要等正在使用这个方法的线程B（或者C D）运行完这个方法后再运行此线程A,没有的话,直接运行 它包括两种用法：synchronized 方法和 synchronized 块。</p>
</blockquote>

<h2 id="toc_0">1. synchronized 方法：</h2>

<p>通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如： <br/>
　　<code>public synchronized void accessVal(int newVal);</code><br/>
　　synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得 该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变 量的方法均被声明为 synchronized）。 <br/>
　　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 <br/>
　　synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。 <br/>
　　</p>

<h2 id="toc_1">2. synchronized 块：</h2>

<p>通过 synchronized关键字来声明synchronized 块。语法如下： </p>

<pre><code>　　synchronized(syncObject) { 
　　//允许访问控制的代码 
　　}
</code></pre>

<p>　　<br/>
　　synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高<br/>
　　</p>

<h2 id="toc_2">对synchronized(object)的一些理解</h2>

<p>　<br/>
<strong>一、</strong>当两个并发线程访问同一个对象object中的这个synchronized(this) 同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 </p>

<p><strong>二、</strong>当一个线程访问object的一个synchronized(this)同步代码块时，其 他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>

<p><strong>三、</strong>然而，当一个线程访问object的一个synchronized(this)同步代码块 时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。 </p>

<p><strong>四、</strong>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个 synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象 所有同步代码部分的访问都被暂时阻塞。 </p>

<p><strong>五、</strong>以上规则对其它对象锁同样适用 </p>

<p>原文: <a href="http://fei263.blog.163.com/blog/static/9279372420103752814/">http://fei263.blog.163.com/blog/static/9279372420103752814/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++Primer笔记 - 初识输入输出]]></title>
    <link href="http://www.citynight.cn/Blog/14866104685305.html"/>
    <updated>2017-02-09T11:21:08+08:00</updated>
    <id>http://www.citynight.cn/Blog/14866104685305.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>使用<code>iostream</code>库.<code>iostream</code>中包含两个基础类型<code>istream</code>和<code>ostream</code>,分别表示输入流和输出流</p>

<h2 id="toc_0">标准输入输出对象</h2>

<p>标准库中定义了4个IO对象.为了处理输入,我们使用了一个名为<code>cin</code>的<code>istream</code>类型的对象.这个对象也被称为<strong>标准输入</strong>.对于输出,我们使用一个名为<code>cout</code>的<code>ostream</code>类型的对象.此对象也被称为<strong>标准输出</strong>.标准库中还定义了其他两个<code>ostream</code>对象,名为<code>cerr</code>和<code>clog</code>.我们通常用<code>cerr</code>来输出警告和错误信心,因此它也被称为<strong>标准错误</strong>,而<code>clog</code>用来输出程序运行时的一般性信息.</p>
</blockquote>

<p>系统通常将程序所运行的窗口与这些对象关联起来.因此,当我们读取cin,数据将从程序正在运行的窗口读入,当我们像cout,cerr,clog写入数据的时候,将会写到同一个窗口.</p>

<h2 id="toc_1">Demo</h2>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(int argc, char *argv[])
{
    std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;
    int v1 = 0, v2 = 0;
    std::cin &gt;&gt; v1 &gt;&gt; v2;
    std::cout &lt;&lt; &quot;The sun of &quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2 &lt;&lt; &quot;is&quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++Primer笔记 - 如何获取 `main`的返回值]]></title>
    <link href="http://www.citynight.cn/Blog/14866089688413.html"/>
    <updated>2017-02-09T10:56:08+08:00</updated>
    <id>http://www.citynight.cn/Blog/14866089688413.html</id>
    <content type="html"><![CDATA[
<p>访问<code>main</code>的返回值的方法依赖于系统.在UNIX和Windows系统中,执行完一个程序后,都可以通过echo命令获得其返回值.<br/>
在UNIX中通过<code>echo $?</code><br/>
在Windows中通过<code>echo %ERRORLEVEL%</code></p>

<p>使用方式:<br/>
在terminal中, <code>vim prog1.cc</code> ,然后在vim下输入(<code>i</code>是插入键)</p>

<pre><code> int main()
 {
     return 0;
 }
</code></pre>

<p>退出编辑器(先按<code>esc</code>,然后<code>:wq</code>)<br/>
在terminal中运行</p>

<pre><code>cc prog1.cc
./a.out
echo $?
</code></pre>

<p>最终会得到我们的返回值<code>0</code></p>

<p><strong>1.1节练习</strong><br/>
1.2: main中返回-1.返回值-1通常被当做程序错误的标识.重新编译运行我再次获取错误值为255<br/>
<img src="media/14866089688413/14866102127236.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 春节前问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14861891967085.html"/>
    <updated>2017-02-04T14:19:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14861891967085.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p><code>#selector集中起来管理</code><br/>
参考<a href="http://weibo.com/3321824014/ErQJDdL4L?type=repost#_rnd1486189248963">微博</a>中第二点<br/>
<img src="media/14861891967085/14861893764185.jpg" alt=""/></p></li>
<li><p>关于Xib的使用问题<br/>
老生常谈的问题了,看个人喜好,不过尽量让其他人看懂,遵守xib规范.<br/>
备注:<br/>
    1. <a href="http://nshipster.cn/ibinspectable-ibdesignable/">IBInspectable / IBDesignable</a><br/>
    2. <a href="http://tips.producter.io/you-ya-di-zi-ding-yi-xibview/">优雅地自定义XibView</a></p></li>
<li><p>关于什么时候提取出方法<br/>
一个函数如果行数过长不便于阅读,可以按照步骤抽取出字方法<br/>
如果一个功能有2个以上地方用到需要抽取为一个方法</p></li>
<li><p>多种样式Cell如何配置</p></li>
</ol>

<p>撕逼未完&hellip;.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - Swift Talk: Networking]]></title>
    <link href="http://www.citynight.cn/Blog/14860911508877.html"/>
    <updated>2017-02-03T11:05:50+08:00</updated>
    <id>http://www.citynight.cn/Blog/14860911508877.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Swift Talk 学习笔记,<a href="https://talk.objc.io/episodes/S01E01-networking">https://talk.objc.io/episodes/S01E01-networking</a></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
