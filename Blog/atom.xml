<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2017-02-07T09:13:34+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[如何获取 `main`的返回值]]></title>
    <link href="http://www.citynight.cn/Blog/14866089688413.html"/>
    <updated>2017-02-09T10:56:08+08:00</updated>
    <id>http://www.citynight.cn/Blog/14866089688413.html</id>
    <content type="html"><![CDATA[
<p>访问<code>main</code>的返回值的方法依赖于系统.在UNIX和Windows系统中,执行完一个程序后,都可以通过echo命令获得其返回值.<br/>
在UNIX中通过<code>echo $?</code><br/>
在Windows中通过<code>echo %ERRORLEVEL%</code></p>

<p>使用方式:<br/>
在terminal中, <code>vim prog1.cc</code> ,然后在vim下输入(<code>i</code>是插入键)<br/>
<code><br/>
 int main()<br/>
 {<br/>
     return 0;<br/>
 }<br/>
</code></p>

<p>退出编辑器(先按<code>esc</code>,然后<code>:wq</code>)<br/>
在terminal中运行<br/>
<code><br/>
cc prog1.cc<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 春节前问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14861891967085.html"/>
    <updated>2017-02-04T14:19:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14861891967085.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p><code>#selector集中起来管理</code><br/>
参考<a href="http://weibo.com/3321824014/ErQJDdL4L?type=repost#_rnd1486189248963">微博</a>中第二点<br/>
<img src="media/14861891967085/14861893764185.jpg" alt=""/></p></li>
<li><p>关于Xib的使用问题<br/>
老生常谈的问题了,看个人喜好,不过尽量让其他人看懂,遵守xib规范.<br/>
备注:<br/>
    1. <a href="http://nshipster.cn/ibinspectable-ibdesignable/">IBInspectable / IBDesignable</a><br/>
    2. <a href="http://tips.producter.io/you-ya-di-zi-ding-yi-xibview/">优雅地自定义XibView</a></p></li>
<li><p>关于什么时候提取出方法<br/>
一个函数如果行数过长不便于阅读,可以按照步骤抽取出字方法<br/>
如果一个功能有2个以上地方用到需要抽取为一个方法</p></li>
<li><p>多种样式Cell如何配置</p></li>
</ol>

<p>撕逼未完&hellip;.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - Swift Talk: Networking]]></title>
    <link href="http://www.citynight.cn/Blog/14860911508877.html"/>
    <updated>2017-02-03T11:05:50+08:00</updated>
    <id>http://www.citynight.cn/Blog/14860911508877.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Swift Talk 学习笔记,<a href="https://talk.objc.io/episodes/S01E01-networking">https://talk.objc.io/episodes/S01E01-networking</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - Swift与JavaScript交互实战[转]]]></title>
    <link href="http://www.citynight.cn/Blog/14836656405837.html"/>
    <updated>2017-01-06T09:20:40+08:00</updated>
    <id>http://www.citynight.cn/Blog/14836656405837.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原地址:<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzA4NjA5Mw==&amp;mid=214070747&amp;idx=1&amp;sn=57b45fa293d0500365d9a0a4ff74a4e1#rd">Swift与JavaScript交互实战（Swift版）</a></p>
</blockquote>

<h2 id="toc_0">前言</h2>

<p>Swift与Js交互是常见的需求，可对于新手或者所谓的高手而言，其实并不是那么简单明了。这里只介绍iOS7.0后出来的JavaScriptCore framework。</p>

<h2 id="toc_1">关于JavaScriptCore</h2>

<p>本教程中所涉及到的几种类型：</p>

<ul>
<li><strong>JSContext</strong>, JSContext是代表JS的执行环境，通过-evaluateScript:方法就可以执行一JS代码</li>
<li><strong>JSValue</strong>, JSValue封装了JS与ObjC中的对应的类型，以及调用JS的API等</li>
<li><strong>JSExport</strong>, JSExport是一个协议，遵守此协议，就可以定义我们自己的协议，在协议中声明的API都会在JS中暴露出来，才能调用</li>
</ul>

<h2 id="toc_2">Swift与JS交互方式</h2>

<p>通过JSContext，我们有两种调用JS代码的方法：</p>

<ul>
<li>1、直接调用JS代码</li>
<li>2、在Swift中通过JSContext<strong>注入模型</strong>，然后调用模型的方法</li>
</ul>

<h3 id="toc_3">直接调用JS代码</h3>

<p>我们可以不通过模型来调用方法，也可以直接调用方法</p>

<pre><code>let context = JSContext() 
context.evaluateScript(“var num = 10”)
context.evaluateScript(“function square(value) { return value * 2}”)

// 直接调用
let squareValue = context.evaluateScript(“square(num)”)
print(squareValue)

// 通过下标来获取到JS方法。
let squareFunc = context.objectForKeyedSubscript(“square”)
print(squareFunc.callWithArguments([“10”]).toString());
</code></pre>

<p>这种方式是没有注入模型到JS中的。这种方式使用起来不太合适，通常在JS中有很多全局的函数，为了防止名字重名，使用模型的方式是最好不过了。通过我们协商好的模型名称，在JS中直接通过模型来调用我们在Swift中所定义的模型所公开的API。</p>

<h2 id="toc_4">注入模型的交互</h2>

<p>首先，我们需要先定义一个协议，而且这个协议必须要遵守JSExport协议。</p>

<p>All methods that should apply in Javascript,should be in the following protocol.注意，这里必须使用@objc，因为JavaScriptCore库是ObjectiveC版本的。如果不加@objc，则调用无效果。</p>

<pre><code>@objc protocol JavaScriptSwiftDelegate: JSExport { 
 func callSystemCamera();
 func showAlert(title: String, msg: String);
 func callWithDict(dict: [String: AnyObject]);
 func jsCallObjcAndObjcCallJsWithDict(dict: [String: AnyObject]);
}
</code></pre>

<p>接下来，我们还需要定义一个模型：</p>

<pre><code>@objc classJSObjCModel: NSObject, JavaScriptSwiftDelegate { 
  weak var controller: UIViewController? 
  weak var jsContext: JSContext? 

  func callSystemCamera() {   
    print(“js call objc method: callSystemCamera”);
    let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); 
    jsFunc?.callWithArguments([]);  
  }

  func showAlert(title: String, msg: String) {     
    dispatch_async(dispatch_get_main_queue()) { () -&gt; Void in   
      let alert = UIAlertController(title: title, message: msg, preferredStyle: .Alert)   
      alert.addAction(UIAlertAction(title: “ok”, style: .Default, handler: nil))      
      self.controller?.presentViewController(alert, animated: true, completion: nil)   
    }   
  }  

  // JS调用了我们的方法   
  func callWithDict(dict: [String : AnyObject]) {   
    print(“js call objc method: callWithDict, args: %@”, dict) 
  }

  // JS调用了我们的就去  
  func jsCallObjcAndObjcCallJsWithDict(dict: [String : AnyObject]) {     
    print(“js call objc method: jsCallObjcAndObjcCallJsWithDict, args: %@”, dict) 
    let jsParamFunc = self.jsContext?.objectForKeyedSubscript(“jsParamFunc”); 
    let dict = NSDictionary(dictionary: [“age”: 18, “height”: 168, “name”: “lili”])
    jsParamFunc?.callWithArguments([dict]) 
  }
}
</code></pre>

<p>接下来，我们在controller中在webview加载完成的代理中，给JS注入模型。</p>

<pre><code>// MARK: - UIWebViewDelegate
func webViewDidFinishLoad(webView: UIWebView) {
  let context = webView.valueForKeyPath(“documentView.webView.mainFrame.javaScriptContext”) as? JSContextlet 
  model = JSObjCModel() 
  model.controller = self
  model.jsContext = context
  self.jsContext = context

  // 这一步是将OCModel这个模型注入到JS中，在JS就
  // 可以通过OCModel调用我们公暴露的方法了。
  self.jsContext?.setObject(model, forKeyedSubscript: “OCModel”)
  self.jsContext?.exceptionHandler = { (context, exception) in 
     print(“exception @”, exception) 
  }
}
</code></pre>

<p>我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。<br/>
这样就可以获取到JS的context，然后为这个context注入我们的模型对象。<br/>
我们先写两个JS方法：</p>

<pre><code>var jsFunc = function() {
  alert(‘Objective-C call js to show alert’);
}

var jsParamFunc = function(argument) {
  document.getElementById(‘jsParamFuncSpan’).innerHTML
  = argument[‘name’];
}
</code></pre>

<p>这里我们定义了两个JS方法，一个是jsFunc，不带参数。<br/>
另一个是jsParamFunc，带一个参数。<br/>
接下来，我们在html中的body中添加以下代码：</p>

<p><code>Test how to use objective-c call js</code></p>

<p>现在就可以测试代码了。</p>

<p>当我们点击第一个按钮：Call ObjC system camera时，<br/>
通过OCModel.callSystemCamera()，就可以在HTML中通过JS调用OC的方法。<br/>
在Swift代码中，我们的callSystemCamera方法体中，添加了以下两行代码，就是获取HTML中所定义的JS就去jsFunc，然后调用它。</p>

<pre><code>let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); jsFunc?.callWithArguments([]);
</code></pre>

<p>这样就可以在JS调用Siwft方法时，也让Swift反馈给JS。<br/>
注意：这里是通过objectForKeyedSubscript方法来获取变量jsFunc。<br/>
方法也是变量。看看下面传字典参数：</p>

<pre><code>(void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary )params {
    NSLog(@”jsCallObjcAndObjcCallJsWithDict was called, params is %@”, params);
    // 调用JS的方法
    JSValue jsParamFunc = self.jsContext[@”jsParamFunc”];
    [jsParamFunc callWithArguments:@[@{@”age”: @10, @”name”: @”lili”, @”height”: @158}]];
}
</code></pre>

<p>获取我们在HTML中定义的jsParamFunc方法，然后调用它并传了一个字典作为参数。<br/>
好了，就讲这么多吧，如果想要Demo源代码，请到</p>

<ul>
<li>github：<strong><a href="https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS">https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS</a></strong></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C/C++ - 回调函数中比较大小为啥0不行?]]></title>
    <link href="http://www.citynight.cn/Blog/14834570124499.html"/>
    <updated>2017-01-03T23:23:32+08:00</updated>
    <id>http://www.citynight.cn/Blog/14834570124499.html</id>
    <content type="html"><![CDATA[
<p>在C语言中我们判断真假经常使用非0为真,0为假.但是在回调函数中我设置返回非0与0代表真假的时候出现了问题:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int callBackCompare(void * pa, void * pb)
{
    return *(int *)pa &lt; *(int *)pb ? 1 : -1;
}

void selectSort(int *p, int n, int (*pf)(int a, int b))
{
    for(int i = 0; i &lt; n-1; i++)
    {
        for(int j = i+1; j&lt;n; j++)
        {
            if(pf(p[i],p[j]))
            {
                p[i] = p[i]^p[j];
                p[j] = p[i]^p[j];
                p[i] = p[i]^p[j];
            }
        }
    }
}

int main(int argc, char *argv[])
{
    int arr[10] = {1,2,3,4,5,9,8,7,6,0};

    qsort(arr,sizeof(arr)/sizeof(int),sizeof(int),callBackCompare);

    for(int i = 0; i&lt;10; i++)
    {
        printf(&quot;%d\n&quot;,arr[i]);
    }
    return 0;
}

</code></pre>

<p>callBack中这样写能够得到结果</p>

<pre><code>9
8
7
6
5
4
3
2
1
0
</code></pre>

<p>但是如果我把callback函数中的-1换成0则返回错误结果</p>

<pre><code>0
2
3
4
5
9
8
7
6
1
</code></pre>

<p>这是为什么呢?</p>

<p>&mdash;17.1.3&mdash;-<br/>
搞懂了,0不能代表升降&hellip;</p>

<blockquote>
<p>假设是对 int 排序的话，如果是升序， 那么就是如果 a 比 b 大返回一个正值，小则负值，相等返回 0; 假设是对 int 排序的话，如果是降序， 那么就是如果 a 比 b 大返回一个负值，小则正值，相等返回 0;</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 上周总结(12.30)]]></title>
    <link href="http://www.citynight.cn/Blog/14830040423390.html"/>
    <updated>2016-12-29T17:34:02+08:00</updated>
    <id>http://www.citynight.cn/Blog/14830040423390.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">规范问题</h2>

<p>关于视图该不该把控件暴露出去?<br/>
通常情况下不能,原因:为了<del>部落</del>封闭性.</p>

<p>我的理解,每个视图都是一个盒子,如果有需要我可以给外面提供一个update接口来更改数据.视图中的点击事件可以通过<code>Target-Action</code>实现,当然闭包&amp;代理同样可以.非常符合<code>Cocoa</code>提倡的<code>MVC</code>模式</p>

<p><img src="media/14830040423390/14834530948549.jpg" alt=""/></p>

<p>关于视图中空间是否暴露出去,默认都是<code>private</code>,我认为苹果<code>Cocoa Touch</code>中<code>UIKit</code>部分控件设计的不是很好,举个🌰:<br/>
<code>UIButton</code>如果设置字体的大小,需要通过<code>titleLabel?.font</code>来设置.我认为这样是不好的,通过一个方法来设置font感觉更合适.</p>

<h2 id="toc_1">更Swift</h2>

<p>毕竟大部分同学都是刚接触Swift,整个项目感觉有点像翻译,还是<code>OC</code>的味道,关于这个问题讨论了两点,一个是面向协议编程,一个是函数式编程</p>

<h3 id="toc_2">面向协议编程</h3>

<p>问题:某一个视图是其他视图所需要的一部分,现在的做法是将共有的视图抽取出来,成为一个视图,然后其他视图包含这个视图.<br/>
面向协议:公共的子视图设置为一个协议,然后给一个默认的实现.像搭积木一样做视图的拼接.</p>

<p>参考资料:<a href="https://github.com/atConf/atswift-2016-resources">atswift-2016大会</a>中<code>李洁信_Pop in Swift</code>这个section可以参考.</p>

<h3 id="toc_3">函数式编程</h3>

<p>周欣对自己代码优化的时候发现的问题:<br/>
一开始的逻辑:</p>

<pre><code>class func fetchAllDish() -&gt; [Any] {
        var mutableBigCategorys = [Any]()
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        for bigCategory in bigCategorys {
            var bigCategory = bigCategory
            var mutableSubCategorys = [Any]()
            let subCategorys = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            for subCategory in subCategorys {
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                if dishes.count &gt; 0 {
                    subCategory[&quot;dishes&quot;] = dishes
                    mutableSubCategorys.append(subCategory)
                }
            }
            if mutableSubCategorys.count &gt; 0 {
                bigCategory[&quot;subCategorys&quot;] = mutableSubCategorys
                mutableBigCategorys.append(bigCategory)
            }
        }
        return mutableBigCategorys
    }
</code></pre>

<p>优化后的:</p>

<pre><code>class func fetchAllDish() -&gt; [Any] {
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        let results = bigCategorys.map { (bigCategory) -&gt; [String: Any] in
            var bigCategory = bigCategory
            let subCategory = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            let subResults = subCategory.map({ (subCategory) -&gt; [String: Any] in
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                subCategory[&quot;dishes&quot;] = dishes
                return subCategory
            }).filter({ $0.count &gt; 0 })
            bigCategory[&quot;subCategorys&quot;] = subResults
            return bigCategory
        }.filter({ $0.count &gt; 0 })
        return results
    }
</code></pre>

<p>通过<code>map</code>与<code>filter</code>的灵活使用,使代码逻辑更清晰,同时也减少了不必要的临时变量.</p>

<h3 id="toc_4">元组</h3>

<p>这个甲冠用的比较6..代码参见<code>NeoSubDishDetailView.swift</code>简单🌰:</p>

<pre><code>    func refreshInfo(data : (UIButton,DishTypeModel)){
        dishNameLabel.text = data.1.name
        moneyLabel.text = data.1.price
        numLabel.text = String(data.1.num)
        if data.1.num &lt;= 0{
            self.cutButton.isHidden = true
            self.numLabel.isHidden = true
        }else{
            self.cutButton.isHidden = false
            self.numLabel.isHidden = false
        }
    }

</code></pre>

<p>还有好多地方使用,这个文件可以好好观摩一下,很Swift&hellip;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点菜逻辑梳理]]></title>
    <link href="http://www.citynight.cn/Blog/14829045788456.html"/>
    <updated>2016-12-28T13:56:18+08:00</updated>
    <id>http://www.citynight.cn/Blog/14829045788456.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">同步逻辑(全量上传):</h2>

<p>原定: 切台\转台 全量上传<br/>
现在: 轮询即上传(每次轮询信息都走这个接口),切台/轮询同样走这个接口</p>

<h2 id="toc_1">关于延时</h2>

<p>12.27泽祥刚跟海底捞确定逻辑和备注一致即这道菜如果半份延时了再次点这道菜不论整份半份都是延时的.</p>

<h2 id="toc_2">整份半份显示(如果新需求的话,可能还需要改变正在和泽祥确定中)</h2>

<p>需求:点菜点锅界面菜品包含整份与半份 购物车界面整份与半份是分开的.</p>

<p>目前的做法: 购物车等地方如果调用<code>-(NSArray *)getLocalDishArray</code>这个操作会把数据拆分成整份半份给调用者.但是在点菜点锅页面,我会调用<code>configLocalDishArray</code> 这个操作会把整份半份整合成一个菜给调用者</p>

<h2 id="toc_3">关于估清</h2>

<p>原有逻辑就是根据数据库中获取菜品信息进行估清操作判断的,<strong>目前</strong>的逻辑是这样的,数据库返回字段和轮询回来的估清数据中只要有一个是估清就显示估清,显示需要调用<code>-(BOOL)judgeIsSellOutWithDish:(HTDishEntity *)dish</code></p>

<h2 id="toc_4">关于已点</h2>

<p>新加菜&amp;已下单数据只要一个地方有该菜品都显示已点<code>-(BOOL)haveOrderThisDish:(NSString *)dishid</code></p>

<h2 id="toc_5">匹配菜品中整份半份数量</h2>

<p><code>-(nonnull HTDishEntity *)configNumberOfDish:(nonnull HTDishEntity *)dish</code><br/>
会计算未下单数据中所有整份半份数量</p>

<h2 id="toc_6">延时倍增拆分等操作</h2>

<p>这里需要的菜品都是通过<code>getLocalDishArray</code>来获取否则有问题,详细逻辑大伟比较清楚</p>

<h2 id="toc_7">目前问题</h2>

<p>如果某一道菜设置延时了,将来这道菜每次进行数量的加减时都要同步到服务器,这个操作会不会导致网络请求发送比较频繁<br/>
点锅后,使用最新的同步接口延时太久.吃饭前同步的数据,中午午休后发现数据回来了&hellip;点菜的数据同步很快..这个是接口用错了还是后台接口需要调整?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全屏返回手势小技巧]]></title>
    <link href="http://www.citynight.cn/Blog/14823239811290.html"/>
    <updated>2016-12-21T20:39:41+08:00</updated>
    <id>http://www.citynight.cn/Blog/14823239811290.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这片文章可以和<a href="http://www.citynight.cn/Blog/14790381443417.html">Swift - KVC 和 运行时获取属性列表</a> 一起看,当然配上<a href="http://www.citynight.cn/Blog/14793034700265.html">隐藏tabBar的小技巧</a>就更好了😀</p>
</blockquote>

<h2 id="toc_0">第一种: 通过<code>runtime</code>与<code>KVC</code>配合完成</h2>

<p>在<code>UINavigationController</code>的<code>viewDidLoad</code>方法中:</p>

<pre><code>// 获取系统的手势
let gest = self.interactivePopGestureRecognizer!
// 禁用系统的手势
interactivePopGestureRecognizer?.isEnabled = false

// 通过KVC获取target 属性是通过runtime获取的,具体方法参见`Swift - KVC 和 运行时获取属性列表`
guard let targets = gest.value(forKey: &quot;_targets&quot;) as? [AnyObject] else {
    return
}
let target = targets[0].value(forKey: &quot;_target&quot;)

// 给视图添加点击事件
let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
view.addGestureRecognizer(pan)
</code></pre>

<h2 id="toc_1">第二种: 通过原有的代理完成</h2>

<p>直接上代码:</p>

<pre><code>class BaseNavigationController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()

        // 获取系统的手势的代理
        guard let target = interactivePopGestureRecognizer?.delegate else {
            return
        }
        
        // 禁用系统的手势
        interactivePopGestureRecognizer?.isEnabled = false
        
        // 给视图添加点击事件
        let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
        pan.delegate = self
        view.addGestureRecognizer(pan)
    }
}

extension BaseNavigationController:UIGestureRecognizerDelegate {
    func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool {
        // 当是跟控制器的时候不让返回,非跟控制器可以返回
        return viewControllers.count &gt; 1
    }
}

</code></pre>

<p>第一种也应该设置代理,不设置代理的话跟控制出现手势就会有bug</p>

<p>简单比较一下,第二种更简洁.不过应用了一个小技巧,看代码:</p>

<pre><code>    let pan = UIPanGestureRecognizer(target: self, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
    pan.delegate = self
    view.addGestureRecognizer(pan)
</code></pre>

<p>可见<code>target</code>&amp;<code>delegate</code>通常都是同一个对象,当让也可以是不同的,这里应用这个小技巧让代码变得更简洁.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库复习]]></title>
    <link href="http://www.citynight.cn/Blog/14817245458052.html"/>
    <updated>2016-12-14T22:09:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14817245458052.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>项目中部分功能打算使用数据库进行数据本地存储,所以复习了下数据库语句</p>
</blockquote>

<h2 id="toc_0">DDL</h2>

<pre><code>/*
删除表,如果存在表就删除表
*/
DROP TABLE IF EXISTS &#39;t_student&#39;;

/*
创建表
*/

CREATE TABLE IF NOT EXISTS &#39;t_student&#39; (
    &#39;id&#39; INTEGER NOT NULL PRIMARY KEY  AUTOINCREMENT,
    &#39;name&#39; TEXT,
    &#39;age&#39; INTEGER
);
</code></pre>

<h2 id="toc_1">DML</h2>

<pre><code>/*
插入数据
*/
/*
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz1&#39;, 18);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz2&#39;, 19);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz3&#39;, 21);
INSERT INTO &#39;t_student&#39; (name, age) VALUES (&#39;lxz4&#39;, 22);
*/

/*更新*/
-- UPDATE t_student SET age = 20 WHERE name = &#39;lxz1&#39;
UPDATE t_student SET name = &#39;xxx&#39; WHERE age &gt; 20


/*删除*/
DELETE FROM t_student WHERE name = &#39;xxx&#39;
</code></pre>

<h2 id="toc_2">DQL</h2>

<pre><code>/*查询语句*/
-- SELECT * FROM t_student;

/*查询特殊的字段*/
-- SELECT name,age FROM t_student;

/*通过条件来查询语句*/
-- SELECT name, age FROM t_student WHERE age &lt; 20;

/*模糊查询*/
-- SELECT name,age FROM t_student WHERE name LIKE &#39;%l%&#39;

/*多个条件的查询
AND 并且
OR 或者
*/
-- SELECT name, age FROM t_student WHERE name LIKE &#39;%l%&#39; AND age &lt; 20;

/*计算个数*/
-- SELECT count(*) FROM t_student WHERE age &lt; 20

/*排序
升序 ASC
降序 DESC
*/
-- SELECT * FROM t_student ORDER BY age DESC

-- SELECT * FROM t_student ORDER BY age ASC, name DESC;

/*起别名*/
-- 给表起别名
SELECT s.name, s.age FROM t_student AS s;
-- 给字段起别名
SELECT name AS myName, age AS myAge FROM t_student;


/*分页查询 limt
数字1的意思是前面跳过多少条数据
数字2的意思是本次查询多少条数据
SELECT * FROM t_student LIMIT 数字1,数字2

跳过0条数据查询5条数据
SELECT * FROM t_student LIMIT 5
*/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取崩溃信息]]></title>
    <link href="http://www.citynight.cn/Blog/14816416025061.html"/>
    <updated>2016-12-13T23:06:42+08:00</updated>
    <id>http://www.citynight.cn/Blog/14816416025061.html</id>
    <content type="html"><![CDATA[
<p>日志详细信息:</p>

<pre><code>static void exceptionHandler( NSException * exception )
{
    NSString *date = [NSString stringWithFormat:@&quot;崩溃日志-%@&quot;, [[NSDate date] description]];

    NSLog(DEBUG_CRASH, @&quot;%@ app crashed %@&quot;,date,exception.description);
     abort();
}
</code></pre>

<p>Appdelegate中调用:</p>

<pre><code>NSSetUncaughtExceptionHandler( &amp;exceptionHandler );
</code></pre>

<p>当然也可以在日志信息中记录堆栈信息:</p>

<pre><code>[exception callStackSymbols]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 上周问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14815534553600.html"/>
    <updated>2016-12-12T22:37:35+08:00</updated>
    <id>http://www.citynight.cn/Blog/14815534553600.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">懒加载的正确姿势</h2>

<blockquote>
<p>使用Swift的时候用懒加载,但是我发现我使用的时候不能再懒加载中调用本文件中声明的属性,原因是我在写懒加载的时候没有注明类型,正确的姿势应该是:</p>
</blockquote>

<pre><code>    lazy var &lt;#property name#&gt;: &lt;#type name#&gt; = {
        &lt;#statements#&gt;
        return &lt;#value#&gt;
    }()
</code></pre>

<p>快捷键<br/>
<img src="media/14815534553600/14815536582812.jpg" alt=""/><br/>
采用这种方式声明的懒加载能够在内部使用self</p>

<h2 id="toc_1">OC中用KVC赋值,使NSString类型指向了NSNumber,导致Swift中调用崩溃</h2>

<blockquote>
<p>崩溃信息:<code>reason: &#39;-[__NSCFNumber length]: unrecognized selector sent to instance 0x00000XXXX</code></p>
</blockquote>

<p>原因分析:NSString指向的数据类型为NSNumber的数据,取值时崩溃.第一种方案找到赋值有误的地方修改,第二不修改原有的代码,提出一种解决方案,重写NSString数据的<code>set</code>方法,赋值前判断数据类型,如果是NSNumber类型就转换成NSString类型.ß®</p>

<h2 id="toc_2">视图层级深,内部视图如何通知控制器数据更新?</h2>

<p>我想到的一种方法是把函数当做参数来传递,这样能够在一定程度上减少层级结构.甲冠提出设置一个属性,然后在属性的<code>didSet</code>中调用方法.目前还没有做实践,目测层级结构没有任何减少,但是代码量会少些.需要实验验证下.</p>

<p><strong>注:</strong>讨论中间有讨论MVC框架,这里附上苹果多MVC的介绍:<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1">https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1</a></p>

<p>传统:<br/>
<img src="media/14815534553600/14815566784560.gif" alt=""/></p>

<p>Cocoa:<br/>
<img src="media/14815534553600/14815567675257.gif" alt=""/></p>

<h2 id="toc_3">Xcode升级后部分第三方库报错</h2>

<p><img src="media/14815534553600/Snip20161215_3.png" alt="Snip20161215_3"/><br/>
让第三方库不跟随Xcode的swift版本®</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8之后设置PopoverController]]></title>
    <link href="http://www.citynight.cn/Blog/14813828036514.html"/>
    <updated>2016-12-10T23:13:23+08:00</updated>
    <id>http://www.citynight.cn/Blog/14813828036514.html</id>
    <content type="html"><![CDATA[
<p>直接上代码:</p>

<pre><code>    @IBOutlet weak var popoverButton: UIButton!
    @IBAction func popoverClick(_ sender: Any) {
        
        // 需要被展示的控制器
        let popover = PopoverViewController()
        // 设置呈现样式
        popover.modalPresentationStyle = .popover
        // 对应原来PopoverController中的rect
        popover.popoverPresentationController?.sourceRect = self.popoverButton.bounds
        // 对应原来PopoverController中的inView
        popover.popoverPresentationController?.sourceView = self.popoverButton
        // 展示
        self.present(popover, animated: true, completion: nil)
    }
</code></pre>

<p>在被呈现的控制器中设置显示的大小:</p>

<pre><code>class PopoverViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        /// 设置呈现大小
        self.preferredContentSize = CGSize(width: 400, height: 400)
    }
}
</code></pre>

<p>以上设置,如果是iPhone的话,模态弹出视图,popover属性就会被忽略.iPad则会Popover弹出</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scroll UICollectionView to section header view]]></title>
    <link href="http://www.citynight.cn/Blog/14810139766101.html"/>
    <updated>2016-12-06T16:46:16+08:00</updated>
    <id>http://www.citynight.cn/Blog/14810139766101.html</id>
    <content type="html"><![CDATA[
<p>新界面左右联动的时候遇到了一个问题,怎么在左侧tableView点击某一cell的时候右侧collectionView跳转到对应的section</p>

<p>如果没有section header View 的时候直接跳转到这个section的第一个Item就ok了,但是如果有section header View 的时候就需要注意了,不能这样进行跳转了,下面👇是经过测试的方法能够完美跳转到相应的section:</p>

<pre><code>let attributes = self.collectionView.collectionViewLayout.layoutAttributesForSupplementaryViewOfKind(UICollectionElementKindSectionHeader, atIndexPath: NSIndexPath(forItem: 0, inSection: index))

self.collectionView.setContentOffset(CGPointMake(0, attributes!.frame.origin.y - self.collectionView.contentInset.top), animated: true)
</code></pre>

<p>参见:<a href="http://stackoverflow.com/questions/22100227/scroll-uicollectionview-to-section-header-view">Scroll UICollectionView to section header view</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[左右联动效果再实现]]></title>
    <link href="http://www.citynight.cn/Blog/14807724917867.html"/>
    <updated>2016-12-03T21:41:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14807724917867.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>在微指的时候,商户详情界面中就存在左右联动,具体实现可见<a href="https://github.com/Mekor/MKShowDetail">MKShowDetail</a> .当然这次和微指的时候有所不同,层级结构更深,所属视图跨控制器.下面是正文👇</p>
</blockquote>

<h2 id="toc_0">数据结构</h2>

<p>在海底捞Pad版本项目中,点菜和点锅是两种完全不同的东西,但是又都属于点菜类中,所以数据结构比较复杂:</p>

<pre><code>点锅: 大分类 --&gt; 具体的锅底
点菜: 大分类 --&gt; 小分类 --&gt; 具体菜品
</code></pre>

<p><strong>需求:</strong> <em>大分类下如果有小分类并且小分类个数大于1个的时候显示小分类,如果小于一个则不显示.</em></p>

<p>这样两种数据结构完全不同的数据需要整合成相同的显示样式,跟同事讨论后决定粗暴的也是最简单的方法修改点锅数据,给大分类后面强行包裹一层小分类.</p>

<h2 id="toc_1">视图设计</h2>

<p>数据层搞定了,又到了显示问题了:<br/>
分类显示马上想到了<code>tableView</code>,但是<code>点锅</code>和<code>点菜</code>互不干扰,我想到的就是分成两个<code>section</code>,这时又有一个问题,需求又要求大分类和小分类的样式是不一样的,不一样的,不一样的&hellip;怎么办? 使用<code>tableViewSectionHeader</code>.按大类进行划分,<code>点锅</code>和<code>点菜</code>之间的区分用数据.小分类则用cell表示.</p>

<h3 id="toc_2">tableViewSectionHeader 设计</h3>

<p>既然已经决定了用<code>headerView</code>那么怎么设计呢?</p>

<ol>
<li>点击事件</li>
<li>确定具体点击的是哪个</li>
</ol>

<p>所以我在设计<code>headerView</code>的时候让它在显示数据的时候也要传入当前的<code>index</code>:</p>

<pre><code>    func setName(_ name: String, index: Int) {
        nameLabel.text = name
        self.index = index
    }
</code></pre>

<p>(ps: 不要吐槽,刚开始用Swift写项目😂)</p>

<p>这样我自己记录下传入的<code>index</code>当点击事件的时候再告诉外界具体点击的是哪一个:</p>

<pre><code>    @objc private func labelClick() {
        delegate?.didSelectedHeader(section : self.index)
    }
</code></pre>

<p>很明显的知道我是使用代理进行数据传递的..说下为啥不使用属性记录<code>index</code>?? 任性😁</p>

<p>到这里<code>headerView</code>基本完成了,控制器实现代理方法就好了,然后根据<code>index</code>让右侧具体的菜品滚动到相应的位置就好了&hellip;</p>

<h3 id="toc_3">点锅点菜区分&amp;跳转</h3>

<p>接上,左侧显示的大分类与小分类都是统一的了,但是右侧的点菜与点锅是分开的<strong>锅是锅,菜是菜</strong>.怎样区分呢?使用两套数据源,然后随时切换&gt;?? 不行🚫&hellip;要求要像淘宝或者京东详情页那样,可以滚动到下一页还可以滚回到上一页&hellip;怎么办? 使用两个collection控制器,一个显示点锅数据,一个显示点菜数据.这样做能够尽量减少某一个单独的控制器中存在过多的逻辑代码.那么谁来承载这两个控制器呢?再创建一个控制器然后把这两个放进去? 这样也能实现,就是控制器太多了&hellip;我想用的是一个<code>scrollow</code>来包裹这两个控制器,好处是能够控制显示那个控制器,逻辑也比较简单..比如说滚到第一个视图:</p>

<pre><code>        UIView.animate(withDuration: 0.25, delay: 0, options: .layoutSubviews, animations: ({
            self.contentView.contentOffset = CGPoint(x: 0, y: 0)
        }), completion: nil)
</code></pre>

<p>直接设置<code>scrollow</code>的<code>contentOffset</code>就可以了</p>

<p><strong>怎么做到电商网站中详情页与图文详情页滚动呢?</strong> 以当前项目为例(点锅在首屏),最简单的一种实现方式:</p>

<p>使用下拉刷新&amp;上拉加载更多实现</p>

<ol>
<li>点锅页面上拉加载更多跳转到点菜页面(通过上面代码设置<code>scrollow</code>的<code>contentOffset</code>实现)</li>
<li>点菜页面下拉刷新跳转到点锅页面,实现方式同上..</li>
</ol>

<p>这样很容易实现两个页面之间的跳转.</p>

<h3 id="toc_4">右侧具体菜品数据处理</h3>

<p>终于到数据处理了&hellip;这里的主要矛盾点在与collectionView是一个二级结构数据即可分成<code>section</code>与具体的<code>Item</code>,<code>点锅</code>数据还好,可以强制抹除大分类和具体内容之间强加的子分类封装,那么点菜数据怎么处理呢?毕竟右侧数据滚动后还要通知左侧视图跳转到相应的分类&hellip;<br/>
我想到的一种处理方式,可能不是最好的,但是这是我在短时间内想到比较行之有效的方法:</p>

<p>把点菜数据也通过一层操作转成两层数据:  <code>三层数据 --&gt; 遍历 --&gt; 数组 + 字典</code><br/>
具体点就是遍历三层数据,然后使用IndexPath当做 key ,具体的<code>Item</code>数组当做 value 这样就转换成立一个二级结构数据.具体<code>IndexPath</code>中<code>section</code>存放原有的大分类信息,<code>row</code>存放子分类数据信息..这样我们就可以通过 key 找到原有的数据结构信息,然后通过 key 把原有的信息传递到tableView,实现联动.</p>

<h3 id="toc_5">具体联动效果实现</h3>

<p>左侧点击后使用 <code>collectionView?.scrollToItem(at: IndexPath(item: 0, section: section), at: .top, animated: true)</code> 让右侧数据滚动到相应位置,关键是右侧滚动怎么判断左侧滚动到相应位置</p>

<p>在<code>scrollViewDidScroll</code>方法中获得当前显示的<code>Item</code>,具体计算方法如下:</p>

<pre><code>    private func minCurrentSection(collectionView:UICollectionView) -&gt; Int {
        // 根据屏幕的某一坐标,获取当前的index
        // 将collectionView在控制器屏幕的点转化成collectionView上的坐标
        let topPoint = CGPoint(x: UIScreen.main.bounds.size.width*0.5, y: 64)
        let pInView = view.convert(topPoint, to: collectionView)
        
        // 获取这一点的indexPath
        let  indexPathNow = collectionView.indexPathForItem(at: pInView)

        // 赋值给记录当前坐标的变量
        return indexPathNow?.section ?? 0
    }

</code></pre>

<p>这样就能够得到当前<code>Item</code>的<code>section</code>,<code>点锅</code>数据就可以直接让row等于0 然后直接回调就OK了,点菜数据还有些差别:<br/>
点菜需要返回具体的<code>indexPathNow</code>而不是只返回所在<code>section</code>,因为我们需要返回来的<code>index</code>寻找所在的<code>Item</code></p>

<pre><code>guard let cell = collectionView?.cellForItem(at: index) as? OrderDishOrPotCollectionCell else {
            return
        }
        delegate?.orderDishCurrent(position: IndexPath(row:cell.index.row , section: cell.index.section))
</code></pre>

<p>如上,我在<code>cell</code>中存放一个使用元组的属性</p>

<pre><code>    // 记录对应的大分类与小分类
    var index:(section:Int,row:Int) = (section: 0,row: 0)
</code></pre>

<p>处理菜品数据的时候所说的,<code>点菜</code>比较特殊我用<code>IndexPath</code>来记录原先所在的大分类与小分类,那么这里的属性就是记录<code>Key</code>中<code>IndexPath</code>所对应的值.我们既然能够找到这个<code>Item</code>那么问题就都解决了,就像上面代码中的回调.</p>

<h3 id="toc_6">注意</h3>

<p>因为这次需求是右侧数据滚动的过程中让左侧数据及时响应,而不是滚动结束的时候响应,所以需要判断是触摸滚动还是左侧数据点击后右侧数据滚动,毕竟两侧联动吗不做处理的话点击右侧数据左侧滚动,在左侧数据滚动的过程中又会及时回调让左侧数据滚动..</p>

<h3 id="toc_7">思考🤔</h3>

<p>第一种:<br/>
<img src="media/14807724917867/14809480143802.jpg" alt=""/><br/>
第二种:(目前采用)<br/>
<img src="media/14807724917867/14809473897512.jpg" alt=""/></p>

<p>第一种是所要展现的内容控制器是底层控制器的自控制器<br/>
第二种是所要展现内容的控制器在collectionView中,collectionView将不仅仅是一个视图而是变成了一个中间层<br/>
这两种方式那种更好?</p>

<p>&mdash; 12.7 &mdash;-<br/>
需求有变动,不过改动起来看,还是第二种修改方便些😂,所有的逻辑跳转代码没有混合在最外层VC.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xib报错]]></title>
    <link href="http://www.citynight.cn/Blog/14802973825600.html"/>
    <updated>2016-11-28T09:43:02+08:00</updated>
    <id>http://www.citynight.cn/Blog/14802973825600.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>错误信息: Unknown class XXXX in Interface Builder file. (lldb)</p>
</blockquote>

<p>原因,Xib是在其他项目中创建的,拖进来的时候没有注意,只要修改<br/>
<img src="media/14802973825600/14802974822042.jpg" alt=""/></p>

<p>修改module为项目的就好了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 面向协议编程]]></title>
    <link href="http://www.citynight.cn/Blog/14799970254990.html"/>
    <updated>2016-11-24T22:17:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14799970254990.html</id>
    <content type="html"><![CDATA[
<p>跟全部写在base中比较:</p>

<ol>
<li>代码没有增多,却更复用</li>
<li>面向协议(接口),而不是实现,充分解耦</li>
<li>静态类型检查版主在编译时发现问题</li>
<li>写代码像搭积木,先设计接口,再逐一实现</li>
<li>依赖少,更容易调试</li>
</ol>

<pre><code>protocol Hello {
    func sayHello()
}

extension Hello {
    func sayHello() {
        print(&quot;Hello!&quot;)
    }
}

struct Person: Hello {
    
}

let p = Person()
p.sayHello()
</code></pre>

<p>创建一个协议,并且做一个默认实现.使用的时候可以直接调用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 函数式编程]]></title>
    <link href="http://www.citynight.cn/Blog/14799126696997.html"/>
    <updated>2016-11-23T22:51:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/14799126696997.html</id>
    <content type="html"><![CDATA[
<p>一般情况:</p>

<pre><code>struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

usr.login(password: passwd)
</code></pre>

<p>函数式编程</p>

<pre><code>struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

User.login(usr)(password: passwd)
</code></pre>

<p>由此可见: <code>usr.login(password: passwd)</code> == <code>User.login(usr)(password: passwd)</code></p>

<p>如果忽略外部参数</p>

<pre><code>struct User {
    func login(_ password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()
usr.login(passwd)
User.login(usr)(passwd)
</code></pre>

<p>这样就更简洁了</p>

<hr/>

<p>&mdash; 11.24更 &ndash;</p>

<h2 id="toc_0">柯里化(Currying)</h2>

<pre><code>// 柯里化(Currying)

func addOne(num:Int) -&gt;Int {
    return num + 1
}

print(addOne(num: 10))

func addTo(_ adder:Int) -&gt;(_ num:Int) -&gt; Int {
    return {
        num in
        return num + adder
    }
}

let addTwo = addTo(2)

print(addTwo(6))

// 更简单的调用方式
print(addTo(9)(1))

</code></pre>

<p>&mdash;-12.8&mdash;-<br/>
说到函数式编程,我突然想起了今天实现一个功能所用到的技术,这里只做简单记录.</p>

<p>项目中遇到一个问题:根据参数创建相应个数的视图,视图中按钮的点击事件还要回调..我一开始想用代理来做,发现如果层级结构比较深的话代理不是很好用.既然否定了代理那么怎样还能实现该效果呢?我尝试用函数(闭包).</p>

<p>需要传递的数据<br/>
<code><br/>
let dict = [<br/>
    [&quot;title&quot;:GLOBAL_LANGUAGE(&quot;历史锅底&quot;) ,<br/>
     &quot;subtitle&quot;:GLOBAL_LANGUAGE(&quot;上次的定制锅底,再来一单&quot;),<br/>
     &quot;imagename&quot;:&quot;OrderDishOrPot1&quot;,<br/>
     &quot;callback&quot;:historyPotsList!]  // callback 中存放的就是函数名或者闭包名<br/>
]<br/>
</code></p>

<pre><code>let showTitle =  data[i][&quot;title&quot;] as! String
let showSubTitle = data[i][&quot;subtitle&quot;] as! String
let imageName = data[i][&quot;imagename&quot;] as! String
let callBack = data[i][&quot;callback&quot;] as! (()-&gt;()) // 这里就是我需要的闭包

//=======

callBack() // 闭包调用

</code></pre>

<p>只需要这样我就能实现需求了&hellip;函数的传递虽然不像👆所说的那样函数式编程,但是还是有必要记录下,swift跟OC比还是灵活了很多.</p>

<p>&mdash;-未完待续&mdash;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 使用代理和闭包传值]]></title>
    <link href="http://www.citynight.cn/Blog/14796301513904.html"/>
    <updated>2016-11-20T16:22:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/14796301513904.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">代理传值</h2>

<p>声明协议:</p>

<pre><code>protocol FunctionButtonViewDelegate {
    func gotoViewController(vcString:String)
}
</code></pre>

<pre><code>var delegate :FunctionButtonViewDelegate?
</code></pre>

<p>这里<code>?</code>就具有<code>weak</code>的作用</p>

<p>传值:</p>

<pre><code>delegate?.gotoViewController(vcString: button.currentTitle!)
</code></pre>

<p>实现代理方法</p>

<pre><code>extension PersonalCenterViewController:FunctionButtonViewDelegate {
    //MARK: - 跳转到对应的功能模块
    func gotoViewController(vcString: String) {
        print(vcString)
    }
}
</code></pre>

<h2 id="toc_1">闭包传值</h2>

<p>声明:</p>

<pre><code>var callback : ((Int?) -&gt; Void)?
</code></pre>

<p>传值</p>

<pre><code>if let cb = callback {
    cb(200)
}
</code></pre>

<p>实现:</p>

<pre><code>bottomView.callback = { (num)-&gt;Void in
    print(num ?? 0)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift - 在swift中如何使用 hexcolor 值表示颜色]]></title>
    <link href="http://www.citynight.cn/Blog/14796201135474.html"/>
    <updated>2016-11-20T13:35:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/14796201135474.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>结果来自<a href="http://stackoverflow.com/questions/24263007/how-to-use-hex-colour-values-in-swift-ios">How to use hex colour values in Swift, iOS</a></p>
</blockquote>

<pre><code>extension UIColor {
    convenience init(hexString: String) {
        let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int = UInt32()
        Scanner(string: hex).scanHexInt32(&amp;int)
        let a, r, g, b: UInt32
        switch hex.characters.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int &gt;&gt; 8) * 17, (int &gt;&gt; 4 &amp; 0xF) * 17, (int &amp; 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int &gt;&gt; 16, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int &gt;&gt; 24, int &gt;&gt; 16 &amp; 0xFF, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)
    }
}
</code></pre>

<p>使用方法:</p>

<pre><code>let darkGrey = UIColor(hexString: &quot;#757575&quot;)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习]]></title>
    <link href="http://www.citynight.cn/Blog/14793607171148.html"/>
    <updated>2016-11-17T13:31:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/14793607171148.html</id>
    <content type="html"><![CDATA[
<p>工作中必须使用git,但是原先一直使用svn,所以有点坑&hellip;这里简单总结下简单用法</p>

<h2 id="toc_0">svn与git的不同</h2>

<p>一个是集中式版本管理控制,一个是分布式</p>

<p><strong>集中式版本控制:</strong><br/>
<img src="media/14793607171148/14795544773647.jpg" alt=""/></p>

<p><strong>分布式版本控制:</strong><br/>
<img src="media/14793607171148/14795545177377.jpg" alt=""/></p>

<h2 id="toc_1">git简单实用</h2>

<h3 id="toc_2">git help</h3>

<pre><code>$ git help
</code></pre>

<p>查看git所有命令的帮助</p>

<pre><code>$ git help 子命令
</code></pre>

<p>要退出帮助信息，按<code>&quot;q&quot;</code><br/>
翻看下页，按<code>&quot;空格&quot;</code><br/>
翻看上页，按<code>&quot;CTRL+B&quot;</code><br/>
要搜索相关文字，按<code>&quot;/&quot;</code>然后输入<code>&quot;相关文字&quot;</code></p>

<h3 id="toc_3">配置</h3>

<p>1&gt;  创建代码仓库</p>

<pre><code>$ git init
</code></pre>

<p>2&gt;  配置用户名和邮箱</p>

<pre><code>$ git config user.name manager
$ git config user.email manager@gmail.com
</code></pre>

<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中</li>
</ul>

<p>3&gt;  如果要一次性配置完成可以使用一下命令</p>

<pre><code>$ git config --global user.name manager
$ git config --global user.email manager@gmail.com
</code></pre>

<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 <code>.gitconfig</code> 文件中</li>
</ul>

<p>4&gt;  查看当前所有配置</p>

<pre><code>$ git config -l
</code></pre>

<h3 id="toc_4">开发中常用</h3>

<p>1&gt;  创建代码，开始开发</p>

<pre><code>$ touch main.c
$ open main.c
</code></pre>

<p>2&gt;  将代码添加到代码库</p>

<ol>
<li> 查看当前代码库状态
<code>
$ git status
</code></li>
<li> 将文件添加到代码库
<code>
$ git add main.c
</code></li>
<li><p>将修改提交到代码库<br/>
<code><br/>
$ git commit -m &quot;添加了main.c&quot;<br/>
</code><br/>
提示：</p>

<ul>
<li>   在此一定要使用 -m 参数指定修改的备注信息</li>
<li>   否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情</li>
</ul></li>
<li><p>将当前文件夹下的所有新建或修改的文件一次性添加到代码库<br/>
<code>$ git add .</code></p></li>
</ol>

<p>3&gt;  添加多个文件</p>

<pre><code>$ touch Person.h Person.m
$ git add .
$ git commit -m &quot;添加了Person类&quot;
$ open Person.h
$ git add .
$ git commit -m &quot;增加Person类属性&quot;
</code></pre>

<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的</li>
</ul>

<h2 id="toc_5">git 的重要概念及工作原理</h2>

<p>工作区<br/>
暂存区(staged)<br/>
分支(HEAD)</p>

<h2 id="toc_6">别名 &amp; 日志</h2>

<pre><code>$ git config alias.st status
$ git config alias.ci &quot;commit -m&quot;
</code></pre>

<p>除非特殊原因，最好不要设置别名，否则换一台机器就不会用了</p>

<p>查看所有版本库日志</p>

<pre><code>$ git log
</code></pre>

<p>查看指定文件的版本库日志</p>

<pre><code>$ git log 文件名
</code></pre>

<p>配置带颜色的log别名</p>

<pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;
</code></pre>

<p>提示：在git中，版本号是一个由SHA1生成的哈希值</p>

<h2 id="toc_7">版本号，让我们在任意版本之间穿梭</h2>

<pre><code># 回到当前版本，放弃所有没有提交的修改
$ git reset --hard HEAD
# 回到上一个版本
$ git reset --hard HEAD^
# 回到之前第3个修订版本
$ git reset --hard HEAD~3
# 回到指定版本号的版本
$ git reset --hard e695b67

# 查看分支引用记录
$ git reflog

</code></pre>

<h2 id="toc_8">分支管理 - Tag</h2>

<pre><code># 查看当前标签
$ git tag
# 在本地代码库给项目打上一个标签
$ git tag -a v1.0 -m &#39;Version 1.0&#39;
# 将标签添推送到远程代码库中
$ git push origin v1.0

# 使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本
# 签出v1.0标签
$ git checkout v1.0
# 从签出状态创建v1.0bugfix分支
$ git checkout -b bugfix1.0

# 查看远程分支
$ git branch -r
# 删除远程分支
$ git branch -r -d origin/bugfix1.0
</code></pre>

<p>删除修改返回到上次提交状态</p>

<pre><code>git checkout -f
</code></pre>

]]></content>
  </entry>
  
</feed>
