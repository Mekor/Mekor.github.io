<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2019-08-09T17:13:37+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[# 深入理解 iOS 事件机制]]></title>
    <link href="http://www.citynight.cn/Blog/15654059537017.html"/>
    <updated>2019-08-10T10:59:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/15654059537017.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原文来自<a href="https://juejin.im/post/5d396ef7518825453b605afa">掘金</a></p>
</blockquote>

<h2 id="toc_0">前言</h2>

<p>这篇文章始于一个需求：我们在 SDK 提供的某个 View 的 Subview 中实现了单击双击等多个 Gesture Recognizer，而客户希望自己在这个 View 上的单击手势不会冲突，同时没有延迟。</p>

<p>借此机会，我们来重温下 iOS 的事件机制和手势冲突，重点介绍下 UIGestureRecognizer 之间以及与原生触摸事件的相互关系。</p>

<h2 id="toc_1">事件的生命周期</h2>

<p>当指尖触碰屏幕时，一个触摸事件就在系统中生成了。经过 IPC 进程间通信，事件最终被传递到了合适的应用。在应用内历经峰回路转的奇幻之旅后，最终被释放。大致经过如下图：</p>

<p><img src="media/15654059537017/15654060901311.jpg" alt=""/></p>

<h3 id="toc_2">系统响应阶段</h3>

<ol>
<li><p>手指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</p></li>
<li><p>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoard 进程。</p></li>
</ol>

<blockquote>
<p>mach port 进程端口，各进程之间通过它进行通信。</p>

<p>SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。</p>
</blockquote>

<ol>
<li>SpringBoard 进程因接收到触摸事件，触发了主线程 runloop 的 source1 事件源的回调。此时 SpringBoard 会根据当前桌面的状态，判断应该由谁处理此次触摸事件。因为事件发生时，你可能正在桌面上翻页，也可能正在刷微博。若是前者（即前台无 APP 运行），则触发 SpringBoard 本身主线程 runloop 的 source0 事件源的回调，将事件交由桌面系统去消耗；若是后者（即有 APP 正在前台运行），则将触摸事件通过 IPC 传递给前台 APP 进程，接下来的事情便是 APP 内部对于触摸事件的响应了。</li>
</ol>

<h3 id="toc_3">APP响应阶段</h3>

<ol>
<li><p>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</p></li>
<li><p>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</p></li>
<li><p>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 Hit-Testing，细节将在下一节阐述。另外，此处开始便是与我们平时开发相关的工作了。</p></li>
<li><p>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。事实上，事件除了被响应者消耗，还能被手势识别器或是 Target-Action 模式捕捉并消耗掉。其中涉及对触摸事件的响应优先级。</p></li>
<li><p>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么至死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</p></li>
</ol>

<h2 id="toc_4">探测链与响应链</h2>

<h3 id="toc_5">Hit-Testing</h3>

<p>从逻辑上来说，探测链是最先发生的机制，当触摸事件发生后，iOS 系统根据 Hit-Testing 来确定触摸事件发生在哪个视图对象上。其中主要用到了两个 UIView 中的方法：</p>

<pre><code class="language-text">// recursively calls -pointInside:withEvent:. point is in the receiver&#39;s coordinate system
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

// default returns YES if point is in bounds
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
复制代码
</code></pre>

<p>前者会通过递归调用后者来返回一个适合响应触摸事件的视图，下面这张图描述了这个过程：</p>

<p><img src="media/15654059537017/15654061281073.jpg" alt=""/></p>

<h3 id="toc_6">Responder Chain</h3>

<p>Hit-Testing 找到的视图拥有最先对触摸事件进行处理的机会，如果该视图无法处理这个事件，那么事件对象就会沿着响应器的视图链向上传递，直到找到可以处理该事件的对象为止。下面这张图描述了这个过程：</p>

<p><img src="media/15654059537017/15654061526891.jpg" alt=""/></p>

<h3 id="toc_7">Demo 验证</h3>

<p>接下来我们通过官方文档的 Demo 以代码的方式来进行验证：</p>

<p><img src="media/15654059537017/15654061728509.jpg" alt=""/></p>

<p>对于每个 View，我们重载父类的方法：</p>

<pre><code class="language-text">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    NSLog(@&quot;进入A_View---hitTest withEvent ---&quot;);
    UIView * view = [super hitTest:point withEvent:event];
    NSLog(@&quot;离开A_View--- hitTest withEvent ---hitTestView:%@&quot;,view);
    return view;
}

- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_view--- pointInside withEvent ---&quot;);
    BOOL isInside = [super pointInside:point withEvent:event];
    NSLog(@&quot;A_view--- pointInside withEvent --- isInside:%d&quot;,isInside);
    return isInside;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesBegan&quot;);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesMoved&quot;);
    [super touchesMoved:touches withEvent:event];
}

- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesEnded&quot;);
    [super touchesEnded:touches withEvent:event];
}

-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesCancelled&quot;);
    [super touchesCancelled:touches withEvent:event];
}
复制代码
</code></pre>

<p>点击 View D，log 显示如下，这与探测链与响应链的机制的描述相同。</p>

<pre><code class="language-text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_touchesEnded
C_touchesEnded
A_touchesEnded
复制代码
</code></pre>

<p>（这里其实 Hit-Testing 进行了两次，关于这个问题，苹果官方有相应的回复）</p>

<blockquote>
<p>Yes, it’s normal. The system may tweak the point being hit tested between the calls. Since hitTest should be a pure function with no side-effects, this should be fine.</p>
</blockquote>

<h3 id="toc_8">小结</h3>

<p><strong>1. 系统通过 <code>hitTest:withEvent:</code> 方法沿视图层级树从底向上（从根视图开始）从后向前（从逻辑上更靠近屏幕的视图开始）进行遍历，最终返回一个适合响应触摸事件的 View。</strong></p>

<p><strong>2. 原生触摸事件从 Hit-Testing 返回的 View 开始，沿着响应链从上向下进行传递。</strong></p>

<p>探测链与响应链的机制总体比较清晰，不再赘述，但熟悉这两个机制并不能帮我们解决任何问题，接下来我们继续深入探究下手势识别器。</p>

<h2 id="toc_9">手势识别器</h2>

<p>我们首先思考一个问题，对于官方文档里的 Demo，我们在每个 View 上添加一个 UITapGestureRecognizer，当点击 View D 时，UITapGestureRecognizer 之间的响应顺序是什么样的，哪个 View 上的 UITapGestureRecognizer 又会最终响应这个事件？</p>

<h3 id="toc_10">官方文档</h3>

<p>我们先来看看官方文档是怎么说的：</p>

<blockquote>
<p>When a view has multiple gesture recognizers attached to it, you may want to alter how the competing gesture recognizers receive and analyze touch events. By default, there is no set order for which gesture recognizers receive a touch first, and for this reason touches can be passed to gesture recognizers in a different order each time. You can override this default behavior to:</p>

<ul>
<li><p>Specify that one gesture recognizer should analyze a touch before another gesture recognizer.</p></li>
<li><p>Allow two gesture recognizers to operate simultaneously.</p></li>
<li><p>Prevent a gesture recognizer from analyzing a touch.</p></li>
</ul>

<p>Use the UIGestureRecognizer class methods, delegate methods, and methods overridden by subclasses to effect these behaviors.</p>
</blockquote>

<p>根据文档的说法，当触摸事件发生时，哪个 UIGestureRecognizer 先收到这个事件并没有固定的顺序，并且文档建议我们使用 UIGestureRecognizer 提供的方法来控制它们之间的顺序和相互关系。</p>

<h3 id="toc_11">UIGestureRecognizer Methods</h3>

<p>所以我们依次看下系统的 UIGestureRecognizer 都提供了哪些与它们之间相互关系有关的方法：</p>

<pre><code class="language-text">// create a relationship with another gesture recognizer that will prevent this gesture&#39;s actions from being called until otherGestureRecognizer transitions to UIGestureRecognizerStateFailed
// if otherGestureRecognizer transitions to UIGestureRecognizerStateRecognized or UIGestureRecognizerStateBegan then this recognizer will instead transition to UIGestureRecognizerStateFailed
// example usage: a single tap may require a double tap to fail
- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&#39;s counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
复制代码
</code></pre>

<p>这三个方法比较常用，它们可以指定 UIGestureRecognizer 之间的依赖关系，区别在于第一个一般适用于在同一个 View 中创建的多个 UIGestureRecognizer 的场景，当 View 层级比较复杂或者 UIGestureRecognizer 处于 Framework 内部时可以用后两个方法动态指定。</p>

<pre><code class="language-text">// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&#39;s delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;
复制代码
</code></pre>

<p>这个方法可以控制两个 UIGestureRecognizer 之间是否可以同时异步进行，需要注意的是，假设存在两个可能会互相 block 的 UIGestureRecognizer，系统会分别对它们的 delegate 调用这个方法，只要有一个返回 YES，那么这两个 UIGestureRecognizer 就可以同时进行识别，这与 <code>shouldRequireFailureOfGestureRecognizer</code> 是类似的。</p>

<pre><code class="language-text">// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
复制代码
</code></pre>

<p>这两个方法都是用来禁止 UIGestureRecognizer 响应触摸事件的，区别在于，当触摸事件发生时，使用第一个方法可以立即控制 UIGestureRecognizer 是否对其处理，且不会修改 UIGestureRecognizer 的状态机（因为在调用自身的 <code>touchesBegan:withEvent:</code> 之前，详见下），而第二个方法会等待一段时间，在 UIGestureRecognizer 识别手势转换状态时调用，返回 NO 会改变其状态机，使其 state 变为 <code>UIGestureRecognizerStateFailed</code>。</p>

<p>我们看下官方文档对这两个方法的说明：</p>

<blockquote>
<p>When a touch begins, if you can immediately determine whether or not your gesture recognizer should consider that touch, use thegestureRecognizer:shouldReceiveTouch: method. This method is called every time there is a new touch. Returning NO prevents the gesture recognizer from being notified that a touch occurred. The default value is YES. This method does not alter the state of the gesture recognizer.</p>

<p>If you need to wait as long as possible before deciding whether or not a gesture recognizer should analyze a touch, use thegestureRecognizerShouldBegin: delegate method. Generally, you use this method if you have a UIView or UIControl subclass with custom touch-event handling that competes with a gesture recognizer. Returning NO causes the gesture recognizer to immediately fail, which allows the other touch handling to proceed. This method is called when a gesture recognizer attempts to transition out of the Possible state, if the gesture recognition would prevent a view or control from receiving a touch.</p>

<p>You can use the gestureRecognizerShouldBegin:UIView method if your view or view controller cannot be the gesture recognizer’s delegate. The method signature and implementation is the same.</p>
</blockquote>

<p>第二段介绍了通常情况下，当我们的子类 UIView 或 UIControl 有和 UIGestureRecognizer 冲突的自定义触摸事件时，可以使用 <code>gestureRecognizerShouldBegin:</code> 方法让 UIGestureRecognizer 失效来使自定义的触摸事件进行响应。第三段说明了当我们的 View 不是 UIGestureRecognizer 的 delegate 时，可以使用 UIView 中的 <code>gestureRecognizerShouldBegin:</code> 方法。关于这两段的意思我们会在后两节去详细解释。</p>

<pre><code class="language-text">// mirror of the touch-delivery methods on UIResponder
// UIGestureRecognizers aren&#39;t in the responder chain, but observe touches hit-tested to their view and their view&#39;s subviews
// UIGestureRecognizers receive touches before the view to which the touch was hit-tested
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
复制代码
</code></pre>

<p>与 UIResponder 中的触摸事件相关的方法相同，UIGestureRecognizer 有一套自己的触摸事件的方法，区别在于，UIGestureRecognizer 并不在响应链中，这些方法一般是写用来对特定的手势进行判断和识别的逻辑，例如我们可以在子类中重写这些方法来创建自己的 UIGestureRecognizer。使用 <code>gestureRecognizer:shouldReceiveTouch:</code> 可以让这些方法不被调用。</p>

<p>至此，UIGestureRecognizer 已经为我们提供了足够多的方法来控制它们之间的相互关系了，我们接下来在 Demo 中试试看。</p>

<h3 id="toc_12">Demo 验证</h3>

<p>对于官方文档中的 Demo 的每个 View，我们增加一个继承自 UITapGestureRecognizer 的 ZTTapGestureRecognizer 并实现相应的回调：</p>

<pre><code class="language-text">- (void)singleTapGesture
{
    NSLog(@&quot;A_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizerShouldBegin: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
{
    NSLog(@&quot;A_view--- gestureRecognizer shouldReceiveTouch: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizer: %@ otherGestureRecognizer: %@ ---&quot;, gestureRecognizer.name, otherGestureRecognizer.name);
    return YES;
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;A_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}
复制代码
</code></pre>

<p>在我们子类 ZTTapGestureRecognizer 中重写父类关于触摸事件的方法：</p>

<pre><code class="language-text">@implementation ZTTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesBegan&quot;, self.name);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesMoved&quot;, self.name);
    [super touchesMoved:touches withEvent:event];
}

// NSLog 要写在 super 后面来读取 state
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesEnded:touches withEvent:event];
    NSLog(@&quot;%@_touchesEndedWithState: %d&quot;, self.name, (int)self.state);
}

// NSLog 要写在 super 后面来读取 state
-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesCancelled:touches withEvent:event];
    NSLog(@&quot;%@_touchesCancelledWithState: %d&quot;, self.name, (int)self.state);
}

@end
复制代码
</code></pre>

<p>点击 View D，log 显示如下：</p>

<pre><code class="language-text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<p>信息量有点大，我们一点一点来分析（<strong>先忽略 View 响应链里 UIResponder 相关的触摸事件方法，这些会在下一节进行探讨</strong>），首先系统通过 Hit-Testing 机制找到了适合响应的 View D，接下来调用了方法：</p>

<pre><code class="language-text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
复制代码
</code></pre>

<p>上文已经对 <code>gestureRecognizer:shouldReceiveTouch:</code> 解释过，先调用它是没有问题的，但是在多次实验中，一直都是 D C A 的顺序，而 UIGestureRecognizer 其他的 Delegate Method 却有可能是不同的顺序，这是为什么呢？</p>

<p>我们来看下 View D 这个方法的调用栈：</p>

<p><img src="media/15654059537017/15654062505074.jpg" alt=""/></p>

<p>可以看到，UITouchesEvent 遍历了一个 View 数组，系统通过 Hit-Testing 过程得到了适合响应触摸事件的 View D，随后会根据这个 View 的层级关系得到一个响应链 View 数组 [D_view, C_view, A_view, ..., ZTWindow] 然后遍历这个数组去依次判断每个 View 上的 UIGestureRecognizer 是否要接收触摸事件，没有绑定到这个响应链 View 数组上的 UIGestureRecognizer 不再有机会去处理触摸事件，关于原因后面会解释。</p>

<p>接下来调用了方法：</p>

<pre><code class="language-text">D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan

D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
复制代码
</code></pre>

<p>View A 中 <code>gestureRecognizerShouldBegin:</code> 方法的调用栈：</p>

<p><img src="media/15654059537017/15654062776619.jpg" alt=""/></p>

<p>由于我们的 <code>gestureRecognizer:shouldReceiveTouch:</code> 都返回了 YES，3个 View 上的 UIGestureRecognizer 分别收到了 <code>touchesBegan</code> 和 <code>touchesEnd</code> 等触摸事件相关的 方法并开始对触摸手势进行识别。从调用栈中可以看出，在 <code>touchesEnd</code> 方法中手势识别完成之后即将进行状态转换之前调用了 <code>gestureRecognizerShouldBegin:</code> 方法判断是否应该进行手势识别成功的状态转换，由于我们的方法都返回了 YES，可以看到在 <code>touchesEnd</code> 方法完成之后3个 UIGestureRecognizer 都成功识别了手势并且自身的 state 都变成了 <code>UIGestureRecognizerStateEnded</code>，这些与我们上一小节的描述是相符的。</p>

<p>需要注意的是，对于 A_view_tapGestureRecognizer 和 C_view_tapGestureRecognizer 来说，除了它们各自的 delegate，最上层的 View D 也收到了他们的 <code>gestureRecognizerShouldBegin:</code> 回调，这是为什么呢？回顾上一小节关于这个方法官方文档的解释，UIView 自身也有一个 <code>gestureRecognizerShouldBegin:</code> 方法，当 View 不是 UIGestureRecognizer 的 delegate 时，我们可以使用这个方法来使 UIGestureRecognizer 失效。对于所有绑定到父 View 上的 UIGestureRecognizer，除了它们本身的 delegate 之外，Hit-Testing 返回的 View 也会收到这个方法的调用，关于原因我们会在下一节进行解释。</p>

<p>接下来的 log 是 UIGestureRecognizer 是否可以同时处理触摸事件的回调方法，其中的 null 是系统的手势 UIScreenEdgePanGestureRecognizer，由于 Demo 使用了 UINavigationController 系统会首先判断这个手势法是否能同时响应。可以看到，由于这3个 View 上一共存在3个 UIGestureRecognizer，系统一共调用了6次回调方法才可以确定它们之间的关系，这和我们上文对该方法的描述相符。</p>

<p>需要注意的是，UIGestureRecognizer 触摸事件相关的方法 <code>touchesBegan</code> 等和 <code>gestureRecognizerShouldBegin:</code> 对于 View A C D 来说每次运行顺序是不一样的（<code>gestureRecognizer:shouldReceiveTouch:</code> 每次都是 D C A），但最终 UIGestureRecognizer 的 Action Method 的顺序却一定是 A C D：</p>

<pre><code class="language-text">A_singleTapGesture
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<p>同时，当 <code>shouldRecognizeSimultaneouslyWithGestureRecognizer</code> 都返回 NO 时，View D 上的 UIGestureRecognizer 可以响应成功。这又是什么原因呢？</p>

<p>我们在上一步 UITouchesEvent 遍历响应链 View 数组的过程中得到了一个 UIGestureRecognizer 数组 [D_view_tapGestureRecognizer, C_view_tapGestureRecognizer, A_view_tapGestureRecognizer] 随后系统遍历了这个数组来进行处理，这里猜测它们的 <code>touchesBegan</code> 等方法的顺序应该与具体的实现有关（个人猜测可能与 UIGestureEnvironment 里保存的 UIGestureRecognizer 的数据结构实际上不是数组而是图有关系），而 Action Method 的顺序以及最后确保 View D 上的 UIGestureRecognizer 能够响应成功应该也是目前官方未说明的某种机制。</p>

<p>还有一点需要注意的是，<code>gestureRecognizer:shouldReceiveTouch:</code> 与其他的方法不属于相同的调用栈，我们来看下其他方法的调用栈：</p>

<p><img src="media/15654059537017/15654062975213.jpg" alt=""/></p>

<p><img src="media/15654059537017/15654063204292.jpg" alt=""/></p>

<p>可以看到，最先由 UIApplication 通过 <code>sendEvent:</code> 发送了 UIEvent 事件，然后被 UIWindow 转发给了 UIGestureEnvironment，而 UIGestureEnvironment 通过遍历一个 UIGestureRecognizer 数组来调起相关的 UIGestureRecognizer 方法。</p>

<p>到此为止，整个过程仍然有很多疑点，我们重新进行下梳理。</p>

<h3 id="toc_13">UIEvent 与 UIGestureEnvironment</h3>

<p>实际上，系统最先通过 Hit-Testing 机制来对 UIEvent 进行了包装，我们先看下 UIEvent 这个类：</p>

<pre><code class="language-text">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIEvent : NSObject

@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);

@property(nonatomic,readonly) NSTimeInterval  timestamp;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
#else
- (nullable NSSet &lt;UITouch *&gt; *)allTouches;
#endif
- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);

@end
复制代码
</code></pre>

<p>可以看到 UIEvent 所有的属性都是只读以防止被修改，在 View A 的 <code>hitTest:withEvent:</code> 方法中，实际传递的是它的子类 UITouchesEvent：</p>

<p><img src="media/15654059537017/15654063416976.jpg" alt=""/></p>

<p>在 Hit-Testing 阶段，UIEvent 只包含了一个时间戳信息，我们在 View A 的 <code>hitTest:withEvent:</code>方法中打断点来查看下 UITouchesEvent 的内容：</p>

<p><img src="media/15654059537017/15654063597676.jpg" alt=""/></p>

<p>接下来，我们继承 UIWindow 来截获 <code>sendEvent:</code> 事件，并打断点来查看此时 UIEvent 的信息，此时 UIEvent 中多了 UITouch：</p>

<p><img src="media/15654059537017/15654063714528.jpg" alt=""/></p>

<pre><code class="language-text">Printing description of event:
&lt;UITouchesEvent: 0x2819a8120&gt; timestamp: 875742 touches: {(
    &lt;UITouch: 0x11bd35960&gt; phase: Began tap count: 1 force: 0.000 window: &lt;UIWindow: 0x11bd1c610; frame = (0 0; 414 736); gestureRecognizers = &lt;NSArray: 0x2825c94d0&gt;; layer = &lt;UIWindowLayer: 0x282bb5900&gt;&gt; view: &lt;DView: 0x11be2faa0; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x2825f2a60&gt;; layer = &lt;CALayer: 0x282b894a0&gt;&gt; location in window: {234.66665649414062, 482.66665649414062} previous location in window: {234.66665649414062, 482.66665649414062} location in view: {147.66665649414062, 35.666656494140625} previous location in view: {147.66665649414062, 35.666656494140625}
)}
复制代码
</code></pre>

<p>根据 UIEvent 和 UITouchesEvent 的 API 和以上信息，我们可以推断，系统通过 Hit-Testing 记录了适合响应触摸事件的 View 与 Window 等信息，在 Hit-Testing 完成之后，创建了 UITouch 并将其保存在 UIEvent 中进行发送。UIApplication 能够通过 <code>sendEvent:</code> 方法发送事件给正确的 UIWindow 正是由于在 Hit-Testing 过程中系统记录了能够响应触摸事件的 Window。</p>

<p>而 UITouch 中的 UIGestureRecognizer 数组正是通过前面提到的 <code>gestureRecognizer:shouldReceiveTouch:</code> 来生成的，我们来看下在 Hit-Testing 完成之后，<code>sendEvent:</code> 调用之前，View D 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中的 UITouch：</p>

<p><img src="media/15654059537017/15654063890469.jpg" alt=""/></p>

<p>此时，Window 和 DView 已经通过 Hit-Testing 找到，但是 <code>_gestureRecognizers</code> 仍然为空，而在该方法返回 YES 之后，我们在 View C 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中可以看到：</p>

<p><img src="media/15654059537017/15654064024881.jpg" alt=""/></p>

<p>此时 D_view_tapGestureRecognizer 已经被添加到了数组中，同样的，在 View A 的方法中，C_view_tapGestureRecognizer 被添加到了数组中，在最终的 UIEvent 中的 UITouch 里，3个 UIGestureRecognizer 都被保存了起来，所以 UIApplication 才知道如何向正确的 UIGestureRecognizer 发送触摸事件。</p>

<p>接下来说下 UIGestureEnvironment，我们可以认为它是管理所有手势的上下文环境，当调用 <code>addGestureRecognizer:</code> 方法时会将 UIGestureRecognizer 加入到其中。下面是 UIGestureEnvironment 的结构：</p>

<pre><code class="language-text">@interface UIApplication : UIResponder  {
    UIGestureEnvironment * __gestureEnvironment;
    }
@end

@interface UIGestureRecognizer : NSObject {
    UIGestureEnvironment * _gestureEnvironment;
    }
@end

@interface UIGestureEnvironment : NSObject {

    CFRunLoopObserverRef _gestureEnvironmentUpdateObserver;
    NSMutableSet* _gestureRecognizersNeedingUpdate;
    NSMutableSet* _gestureRecognizersNeedingReset;
    NSMutableSet* _gestureRecognizersNeedingRemoval;
    NSMutableArray* _dirtyGestureRecognizers;
    NSMutableArray* _delayedTouches;
    NSMutableArray* _delayedTouchesToSend;
    NSMutableArray* _delayedPresses;
    NSMutableArray* _delayedPressesToSend;
    NSMutableArray* _preUpdateActions;
    bool _dirtyGestureRecognizersUnsorted;
    bool _updateExclusivity;
    UIGestureGraph* _dependencyGraph;
    NSMapTable* _nodesByGestureRecognizer;

}

-(void)addGestureRecognizer:(id)arg1 ;
-(void)removeGestureRecognizer:(id)arg1 ;
-(void)_cancelGestureRecognizers:(id)arg1 ;
-(void)_updateGesturesForEvent:(id)arg1 window:(id)arg2 ;
（省略了很多 API）
-(void)_cancelTouches:(id)arg1 event:(id)arg2 ;
-(void)_cancelPresses:(id)arg1 event:(id)arg2 ;
@end
复制代码
</code></pre>

<p>UIApplication 和 UIGestureRecognizer 中保存了同一个 UIGestureEnvironment 对象，根据上面 UIGestureRecognizer 的 Action Method 的调用栈，我们可以看到，UIWindow 通过 <code>sendEvent:</code>发送事件之后，UIGestureEnvironment 接收了这个事件并且最终通过方法：</p>

<pre><code class="language-text">-[UIGestureEnvironment _updateForEvent:window:] ()
-[UIGestureEnvironment _deliverEvent:toGestureRecognizers:usingBlock:] ()
复制代码
</code></pre>

<p>来对 UIGestureRecognizer 相关方法进行调用：</p>

<ol>
<li>对能够处理事件的 UIGestureRecognizer 发送 <code>touchesBegan:withEvent:</code> 等触摸事件的方法</li>
<li>通过 <code>gestureRecognizerShouldBegin</code> 方法判断是否应该进行状态转换</li>
<li>询问 UIGestureRecognizer 的 delegate 是否应该失效或者是否能够同时处理事件<code>gestureRecognizer:shouldRequireFailureOfGestureRecognizer:</code><code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code></li>
<li>UIGestureRecognizer 识别事件之后最终调用了 Action Method</li>
</ol>

<h3 id="toc_14">小结</h3>

<p><strong>1. 系统在探测阶段结束后创建了 UITouch，并封装了 UIEvent 将其传递。</strong></p>

<p><strong>2. 手势上下文 UIGestureEnvironment 最先收到 UIEvent，并负责通知给相关的 UIGestureRecognizer。</strong></p>

<p><strong>3. UIGestureEnvironment 根据 UIGestureRecognizer 的 delegate 方法来判断其是否能够对触摸事件进行响应。</strong></p>

<p>至此，UIGestureRecognizer 对事件的处理以及它们之间的相互关系告一段落。需要注意的是，建议最好使用官方文档推荐的方法对 UIGestureRecognizer 进行控制，而不要依赖上文中没有存在于文档中的具体实现细节和结论，苹果没有对外暴露这些，有可能会在接下来的版本中修改具体实现。</p>

<h2 id="toc_15">手势识别器与原生触摸事件</h2>

<p>接下来我们终于可以对上一节中 UIResponder 相关的系统原生触摸事件方法进行探讨了，我们去掉 Hit-Testing 与 UIGestureRecognizer 的 delegate 等相关方法，重新运行 Demo，点击 View D，log 显示如下：</p>

<pre><code class="language-text">A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<h3 id="toc_16">官方文档</h3>

<p>按照惯例，我们先来看下官方文档是怎么说的：</p>

<blockquote>
<p>There may be times when you want a view to receive a touch before a gesture recognizer. But, before you can alter the delivery path of touches to views, you need to understand the default behavior. In the simple case, when a touch occurs, the touch object is passed from the UIApplication object to the UIWindow object. Then, the window first sends touches to any gesture recognizers attached the view where the touches occurred (or to that view’s superviews), before it passes the touch to the view object itself.</p>

<p>Gesture Recognizers Get the First Opportunity to Recognize a Touch</p>

<p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p>
</blockquote>

<p><img src="media/15654059537017/15654064332119.jpg" alt=""/></p>

<p>文档实际上说的比较清楚：UIWindow 会先将触摸事件发送给 Hit-Testing 返回的 View 和它的父 View 上的 UIGestureRecognizer，然后才会发送给这个 View 本身，如果 UIGestureRecognizer 成功识别了这个手势，之后 UIWindow 不会再向 View 发送触摸事件，并且会取消之前发送的触摸事件。</p>

<p>下面让我们回到 Demo 来进行验证。</p>

<h3 id="toc_17">Demo 验证</h3>

<p>从 log 上看，现象与官方文档的说法吻合，我们用几个调用栈来对其进行进一步证明：</p>

<p>ZTTapGestureRecognizer 的 <code>touchesBegan:withEvent:</code> 的调用栈:</p>

<p><img src="media/15654059537017/15654064509943.jpg" alt=""/></p>

<p>View D 的 <code>touchesBegan:withEvent:</code> 的调用栈：</p>

<p><img src="media/15654059537017/15654064661803.jpg" alt=""/></p>

<p>View D 的 <code>touchesCancelled:withEvent:</code> 的调用栈：</p>

<p><img src="media/15654059537017/15654064771703.jpg" alt=""/></p>

<p>可以看到，UIWindow 首先通过 <code>sendEvent:</code> 方法经过 UIGestureEnvironment 发送触摸事件给了 ZTTapGestureRecognizer，随后通过 <code>sendTouchesForEvent:</code> 方法发送触摸事件给 View D 并沿着响应链传递，而当 A_view_tapGestureRecognizer 第一个成功识别手势之后，UIGestureEnvironment 发起响应链的 cancel 并经过 UIApplication 发送给 View D 并沿着响应链取消。</p>

<h3 id="toc_18">UIGestureRecognizer Properties</h3>

<p>UIGestureRecognizer 有一些与响应链触摸事件相关的属性，这里简单说明一下：</p>

<pre><code class="language-text">// default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL cancelsTouchesInView;
复制代码
</code></pre>

<p>这个属性可以控制当 UIGestureRecognizer 成功识别手势之后是否要取消响应链对触摸事件的响应，默认为 YES，设置为 NO 之后，即使 UIGestureRecognizer 识别了手势，UIGestureEnvironment 也不会发起对响应链的 cancel。</p>

<pre><code class="language-text">// default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesBegan;
复制代码
</code></pre>

<p>设置为 YES 时，这个属性可以控制在 UIGestureRecognizer 识别手势期间截断事件，识别失败后响应链才能收到触摸事件。</p>

<pre><code class="language-text">// default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
@property(nonatomic) BOOL delaysTouchesEnded;
复制代码
</code></pre>

<p>默认为 YES，当手势识别失败时，若此时触摸事件已经结束，会延迟一小段时间（0.15s）再调用响应者的 <code>touchesEnded:withEvent:</code>，若设置成NO，则在手势识别失败时会立即通知 UIApplication 发送状态为 end 的 触摸事件给 Hit-Testing 返回的 View 以调用 <code>touchesEnded:withEvent:</code> 结束事件响应。</p>

<h3 id="toc_19">小结</h3>

<p><strong>1. UIGestureRecognizer 首先收到触摸事件，Hit-Testing 返回的 View 延迟收到，两者的调起方法不同。</strong></p>

<p><strong>2. 第一个 UIGestureRecognizer 识别成功后，UIGestureEnvironment 会发起响应链的 cancel。</strong></p>

<p><strong>3. 可以通过设置 UIGestureRecognizer 的 Properties 来控制对响应链的影响。</strong></p>

<h2 id="toc_20">UIControl 特例</h2>

<p>我们现在给 Demo 中的 View D 上加一个 UIButton：</p>

<p><img src="media/15654059537017/15654064977862.jpg" alt=""/></p>

<pre><code class="language-text">- (void)buttonTapped
{
    NSLog(@&quot;D_buttonTapped&quot;);
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;D_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];

        FButton *button = [[FButton alloc] initWithFrame:CGRectMake(80, 10, 100, 40)];
        button.backgroundColor = [UIColor blueColor];
        [button addTarget:self action:@selector(buttonTapped) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];
    }

    return self;
}
复制代码
</code></pre>

<p>点击 Button，log 显示如下：</p>

<pre><code class="language-text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesEndedWithState: 5
A_view_tapGestureRecognizer_touchesEndedWithState: 5
D_view_tapGestureRecognizer_touchesEndedWithState: 5
D_buttonTapped
复制代码
</code></pre>

<p>这与我们想象的完全不同：</p>

<ol>
<li>UIGestureRecognizer 没有响应触摸事件且除了 <code>shouldReceiveTouch</code> 之外的回调没有被调用。</li>
<li>触摸事件没有沿着响应链进行传递。</li>
<li>UIButton 成功的响应了触摸事件。</li>
</ol>

<p>这又是什么原因导致的呢？</p>

<h3 id="toc_21">官方文档</h3>

<p>惯例，先看官方文档：</p>

<blockquote>
<p>Interacting with Other User Interface Controls</p>

<p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p>

<ul>
<li><p>A single finger single tap on a UIButton, UISwitch, UIStepper, UISegmentedControl, and UIPageControl.</p></li>
<li><p>A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.</p></li>
<li><p>A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></li>
</ul>

<p>If you have a custom subclass of one of these controls and you want to change the default action, attach a gesture recognizer directly to the control instead of to the parent view. Then, the gesture recognizer receives the touch event first. As always, be sure to read the iOS Human Interface Guidelines to ensure that your app offers an intuitive user experience, especially when overriding the default behavior of a standard control.</p>
</blockquote>

<p>这次文档解释清楚了所有的原因：对于 <strong>部分 UIControl</strong> 来说（自己实现的不行），为了防止 UIControl 默认的手势与其父 View 上的 UIGestureRecognizer 的冲突，UIControl 最后会响应触摸事件，如果想要 UIGestureRecognizer 处理触摸事件，则需要将其直接与 UIControl 进行绑定。</p>

<p>原因清楚了，但是我们还是回到 Demo 之中来看看系统具体是怎么做的。</p>

<h3 id="toc_22">Demo 验证</h3>

<p>我们去掉 View A C D 中的 log，实现一个 UIButton 的子类 FButton，对 FButton 添加一个 ZTTapGestureRecognizer，并且实现方法 <code>gestureRecognizerShouldBegin：</code>：</p>

<pre><code class="language-text">@implementation FButton

- (void)singleTapGesture
{
    NSLog(@&quot;F_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    if ([super gestureRecognizerShouldBegin:gestureRecognizer])
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ YES ---&quot;, gestureRecognizer.name);
    }
    else
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ NO ---&quot;, gestureRecognizer.name);
    }

    return [super gestureRecognizerShouldBegin:gestureRecognizer];
}

- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;F_Button_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}

@end
复制代码
</code></pre>

<p>运行 Demo，点击 Button，log 如下所示：</p>

<pre><code class="language-text">D_view_tapGestureRecognizer_touchesBegan
F_Button_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan

F_Button--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer NO ---
D_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: F_Button_tapGestureRecognizer YES ---
F_Button_tapGestureRecognizer_touchesEndedWithState: 3
F_Button--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer NO ---
C_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer NO ---
A_view_tapGestureRecognizer_touchesEndedWithState: 5

F_singleTapGesture
复制代码
</code></pre>

<p>可以看到 View A C D 和 Button F 上的 ZTTapGestureRecognizer 都收到了 <code>touchesBegan</code> 方法，但是最后只有 F_Button_tapGestureRecognizer 最终成功进行了状态转换，其原因就在于方法 <code>gestureRecognizerShouldBegin:</code>。</p>

<p>还记得前两节我们对于 <code>gestureRecognizerShouldBegin:</code> 的探讨吗，我们终于能够进一步对其进行解释了，这个机会还是留给官方文档：</p>

<blockquote>
<p>Subclasses may override this method and use it to prevent the recognition of particular gestures. For example, the UISlider class uses this method to prevent swipes parallel to the slider’s travel direction and that start in the thumb.</p>

<p>At the time this method is called, the gesture recognizer is in the UIGestureRecognizerStatePossible state and thinks it has the events needed to move to the UIGestureRecognizerStateBegan state.</p>

<p>The default implementation of this method returns YES.</p>
</blockquote>

<p>所以，上文提到的部分 UIControl 重写了该方法，虽然 UIGestureRecognizer 会首先受到触摸事件，但是在状态转换之前，调用了 Hit-Testing 返回的 View 也就是 UIControl 的 <code>gestureRecognizerShouldBegin:</code> 方法，UIControl 会使父 View 上的 UIGestureRecognizer 失效，而自己的 UIGestureRecognizer 却不会失效，这就是系统实现这个机制的方法。</p>

<p>还有一个问题，为什么触摸没有沿着响应链进行传递呢？惯例，先看文档：</p>

<blockquote>
<p>Controls communicate directly with their associated target object using action messages. When the user interacts with a control, the control sends an action message to its target object. Action messages are not events, but they may still take advantage of the responder chain. When the target object of a control is nil, UIKit starts from the target object and traverses the responder chain until it finds an object that implements the appropriate action method. For example, the UIKit editing menu uses this behavior to search for responder objects that implement methods with names like cut:, copy:, or paste:.</p>
</blockquote>

<p>然后我们看下 FButton 的响应方法的调用栈（去掉 FButton 上的 UIGestureRecognizer）：</p>

<p><img src="media/15654059537017/15654065324630.jpg" alt=""/></p>

<p>这里文档没有说全，实际上，FButton 重写了 <code>touchesBegan:withEvent:</code> 方法，在收到触摸事件后将其截断不再沿响应链进行传递；在响应触摸事件时，FButton 使用 Target-Action 机制通过 <code>sendAction:to:forEvent:</code> 方法通知 UIApplication，UIApplication 在通过 <code>sendAction:to:from:forEvent:</code> 方法向 target 发送 action，而当 target 为 nil 时就会沿着响应链进行寻找，知道找到了实现了相应方法的对象。</p>

<h3 id="toc_23">小结</h3>

<p><strong>1. UIGestureRecognizer 仍然会先于 UIControl 接收到触摸事件。</strong></p>

<p><strong>2. UIButton 等部分 UIControl 会拦截其父 View 上的 UIGestureRecognizer，但不会拦截自己和子 View 上的 UIGestureRecognizer。</strong></p>

<p><strong>3. UIButton 会截断响应链的事件传递，也可以利用响应链来寻找 Action Method。</strong></p>

<h2 id="toc_24">UITableView 与 UIScrollView</h2>

<p>当场景中存在 UITableView 和 UIScrollView 时，又会有不一样的情况，感兴趣的读者可以试着自己研究一下。</p>

<h2 id="toc_25">问题解决</h2>

<p>现在，我们回过头看看最初的问题，解决起来应该就比较简单了。</p>

<p>首先在我们对外的 View 上添加一个 UITapGestureRecognizer，通过回调使其能与内部的 UIGestureRecognizer 同时处理触摸事件，并且与内部双击手势不会冲突：</p>

<pre><code class="language-text">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer)
    {
        return YES;
    }

    return NO;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer &amp;&amp; [otherGestureRecognizer isKindOfClass:[UITapGestureRecognizer class]] &amp;&amp; ((UITapGestureRecognizer *)otherGestureRecognizer).numberOfTapsRequired == 2)
    {
        return YES;
    }

    return NO;
}
复制代码
</code></pre>

<p>由于单击手势要在双击手势判断失败后才能触发，所以会有一定的延迟，这里最好的办法是在内部自定义一个 UIGestureRecognizer 来实现双击手势以缩短等待时间：</p>

<pre><code class="language-text">#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;

#define UISHORT_TAP_MAX_DELAY 0.2
@interface UIShortTapGestureRecognizer : UITapGestureRecognizer

@end

@implementation UIShortTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [super touchesBegan:touches withEvent:event];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(UISHORT_TAP_MAX_DELAY * NSEC_PER_SEC)), dispatch_get_main_queue(), ^
    {
        // Enough time has passed and the gesture was not recognized -&gt; It has failed.
        if  (self.state != UIGestureRecognizerStateRecognized)
        {
            self.state = UIGestureRecognizerStateFailed;
        }
    });
}
@end
复制代码
</code></pre>

<p>我们可以通过修改 <code>UISHORT_TAP_MAX_DELAY</code> 参数来控制等待的时间。</p>

<h2 id="toc_26">总结</h2>

<p><strong>1. 触摸事件发生后，IOKit 会通过 mach port 传递给 SpringBoad 进程，并最终传递给了 UIApplication。</strong></p>

<p><strong>2. UIApplication 通过 Hit-Testing 寻找到了最佳响应者，遍历得到所有的 UIGestureRecognizer，然后根据最佳响应者、UIGestureRecognizer、Window 创建 UITouch 并将其保存在 UIEvent 中。</strong></p>

<p><strong>3. UIApplication 将 UIEvent 发送给 UIWindow，UIWindow 首先发送事件给 UIGestureRecognizer，然后发送给最佳响应者，事件沿响应链传递。</strong></p>

<p><strong>4. UIGestureRecognizer 根据 Delegate 以及最佳响应者来判断是否能够成功进行状态转换并取消响应链的触摸事件。</strong></p>

<p><strong>5. 系统实现的部分 UIControl 会截断响应链，并使父 View 上的 UIGestureRecognizer 失效。</strong></p>

<h2 id="toc_27">参考资料</h2>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FBladeTail%2FEvent-Handling-Guide-for-iOS%2Fblob%2Fmaster%2FEvent%2520Handling%2520Guide%2520for%2520iOS.pdf">Event Handling Guide for iOS</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd8512dff2b3e">iOS 事件响应链中 Hit-Test View 的应用</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc294d1bd963d">iOS 触摸事件全家桶</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F53e03e558cbd">iOS 点击事件和手势冲突</a></p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fzhoon.github.io%2Fios%2F2015%2F04%2F12%2Fios-event.html">深入浅出iOS事件机制</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像显示原理]]></title>
    <link href="http://www.citynight.cn/Blog/15653483390225.html"/>
    <updated>2019-08-09T18:58:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/15653483390225.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15653483390225/WX20190809-201518@2x.png" alt="WX20190809-201518@2x"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件传递]]></title>
    <link href="http://www.citynight.cn/Blog/15653376209289.html"/>
    <updated>2019-08-09T16:00:20+08:00</updated>
    <id>http://www.citynight.cn/Blog/15653376209289.html</id>
    <content type="html"><![CDATA[
<p>整体的事件传递流程<br/>
<img src="media/15653376209289/15653376299374.jpg" alt="" style="width:687px;"/></p>

<p>详细的<code>hitTset:withEvent:</code>系统实现<br/>
<img src="media/15653376209289/15653413218867.jpg" alt=""/></p>

<p>注：先判断视图是否隐藏可交互，不满足条件返回nil, 如果不在点击范围内就返回nil,在点击范围内就遍历子视图。遍历子视图的时候如果都没有子视图响应事件，那么就把视图本身<code>v</code>返回，如果有子视图响应就返回当前子视图。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[海底捞点餐Pad 优化]]></title>
    <link href="http://www.citynight.cn/Blog/15653325472073.html"/>
    <updated>2019-08-09T14:35:47+08:00</updated>
    <id>http://www.citynight.cn/Blog/15653325472073.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. cell 显示优化</h2>

<p>海底捞的每个菜品都有很多标签，比如清真，推荐，麻辣等等<br/>
这些标签是有规律的，最多显示6个。没有优化前采用的是存在就创建，这样在iPad Air上面滑动感觉不出卡顿但是在一些老pad 比如 iPad mini 上就会出现卡顿现象。<br/>
解决方案：<br/>
提前创建好6个标签，然后根据数据设置显示内容并控制显隐</p>

<p>这样做能有效的提高老pad的显示效果。</p>

<h2 id="toc_1">2. 数据处理优化</h2>

<p>数据源同步问题，问题描述： pad可以更新数据，定时器拉取数据，推送过来的数据</p>

<p><img src="media/15653325472073/15653335091232.jpg" alt="" style="width:500px;"/></p>

<p>解决方案一： 并发访问数据拷贝<br/>
主线程和子线程都操作数据源的时候，可以把数据源给子线程拷贝一份让子线程操作，当子线程操作完返回给主线程的时候把主线程操作的过程在数据源中再次执行一次然后更新数据显示。<br/>
主要的技术点是记录主线程操作步骤</p>

<p>解决方案二： 串行访问<br/>
操作访问的都是同一数据源，能够保证操作数据不出错。但是有一个问题就是如果子线程正在操作数据这个时候主线程有一个修改操作会导致主线程等待，用户会有卡的感觉。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Texture  中ASButtonNode设置图片崩溃]]></title>
    <link href="http://www.citynight.cn/Blog/15585883897383.html"/>
    <updated>2019-05-23T13:13:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/15585883897383.html</id>
    <content type="html"><![CDATA[
<p>解决方案：<img src="media/15585883897383/WX20190523-110605@2x.png" alt="WX20190523-110605@2x"/></p>

<p>Assets中的图片Slicing 设置<code>Center</code>为<code>Stretches</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态方法和实例方法不同点]]></title>
    <link href="http://www.citynight.cn/Blog/15465912048942.html"/>
    <updated>2019-01-04T16:40:04+08:00</updated>
    <id>http://www.citynight.cn/Blog/15465912048942.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.</p></li>
</ol>

<blockquote>
<p>注意: 在Swift中，静态方法不能通过 <code>对象名.方法名</code> 的方式调用。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何判等equals]]></title>
    <link href="http://www.citynight.cn/Blog/15465714658370.html"/>
    <updated>2019-01-04T11:11:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/15465714658370.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://stackoverflow.com/questions/9506303/public-boolean-equalsobject-other">Stackoverflow</a> 中有其他人提的写法，我感觉公司项目中的写法不错记录下</p>
</blockquote>

<pre><code class="language-text">    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CreateOrderDTO)) return false;
        CreateOrderDTO that = (CreateOrderDTO) o;
        return Objects.equal(getBusiId(), that.getBusiId()) &amp;&amp;
                Objects.equal(getBusiType(), that.getBusiType()) &amp;&amp;
                Objects.equal(getOrderAmount(), that.getOrderAmount());
    }
</code></pre>

<p>重写<a href="https://kapeli.com/dash_share?docset_file=Java&amp;docset_name=Java%20SE10&amp;path=java/lang/Object.html%23equals(java.lang.Object)&amp;platform=java&amp;repo=Main&amp;version=SE10">equals</a>需要满足 自反性，对称性，传递性，一致性，非空</p>

<p><img src="media/15465714658370/15465935663846.jpg" alt="" style="width:588px;"/></p>

<h2 id="toc_0">== 与 equals</h2>

<p><strong><em>==</em></strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>

<p><strong><em>equals()</em></strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>

<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。<br/>
情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据刷新崩溃]]></title>
    <link href="http://www.citynight.cn/Blog/15460677821989.html"/>
    <updated>2018-12-29T15:16:22+08:00</updated>
    <id>http://www.citynight.cn/Blog/15460677821989.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15460677821989/15460678427638.jpg" alt="" style="width:531px;"/><br/>
<img src="media/15460677821989/15460678670280.jpg" alt="" style="width:1054px;"/></p>

<p>发生崩溃的原因是<code>tableView</code> <code>reloadData</code> 的时候直接设置<code>tableView</code> 的 <code>scrollRectToVisible</code> 解决方案</p>

<pre><code class="language-text">        UIView.animate(withDuration: 0, animations: {
            self.tableView.reloadData()
        }) { (finish) in
            let rect = self.tableView.rect(forSection: section)
            self.tableView.scrollRectToVisible(rect, animated: true)
        }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Swift获取应用程序的CPU使用率和内存使用量]]></title>
    <link href="http://www.citynight.cn/Blog/15398626891772.html"/>
    <updated>2018-10-18T19:38:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/15398626891772.html</id>
    <content type="html"><![CDATA[
<p>原文<a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5">SwiftでアプリのCPU使用率とメモリ使用量を取得する</a></p>

<h2 id="toc_0">介绍</h2>

<p>在一个获取系统信息的方法中，一个描述CPU和内存状态的库存在于一个获取系统信息的方法中，其中Debug附带了来自XCode的CustomFlag等。</p>

<p>当然，还有一些方法可以获取不限于Debug版本的系统信息，但大多数都是在Objective-C中编写的。也在AppleDeveloper官方论坛上</p>

<blockquote>
<p>尽管使用Swift是不可能的，但对于那些使用Objective-C 的人来说可能很难</p>
</blockquote>

<p>还有答案说。<br/>
但是，没有任何优点，你可以或根本不能使用Swift。我个人认为低层实现也有以下优点。</p>

<ul>
<li>受益于可选</li>
<li>提高可读性</li>
<li>更容易共享代码（易于维护维护）</li>
</ul>

<p>所以我这次写了如何在Swift中获得CPU利用率和内存使用量。（还有关于磁盘使用情况的奖励）</p>

<h2 id="toc_1">动作确认环境</h2>

<p>XCode8.3.3 <br/>
Swift3.1</p>

<h2 id="toc_2">CPU使用率</h2>

<pre><code class="language-text">// 必須
import Foundation

// CPU使用率を0%~100%で取得
private func getCPUUsage() -&gt; Float {
    // カーネル処理の結果
    var result: Int32
    var threadList = UnsafeMutablePointer&lt;UInt32&gt;.allocate(capacity: 1)
    var threadCount = UInt32(MemoryLayout&lt;mach_task_basic_info_data_t&gt;.size / MemoryLayout&lt;natural_t&gt;.size)
    var threadInfo = thread_basic_info()

    // スレッド情報を取得
    result = withUnsafeMutablePointer(to: &amp;threadList) {
        $0.withMemoryRebound(to: thread_act_array_t?.self, capacity: 1) {
            task_threads(mach_task_self_, $0, &amp;threadCount)
        }
    }

    if result != KERN_SUCCESS { return 0 }

    // 各スレッドからCPU使用率を算出し合計を全体のCPU使用率とする
    return (0 ..&lt; Int(threadCount))
        // スレッドのCPU使用率を取得
        .flatMap { index -&gt; Float? in
            var threadInfoCount = UInt32(THREAD_INFO_MAX)
            result = withUnsafeMutablePointer(to: &amp;threadInfo) {
                $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                    thread_info(threadList[index], UInt32(THREAD_BASIC_INFO), $0, &amp;threadInfoCount)
                }
            }
            // スレッド情報が取れない = 該当スレッドのCPU使用率を0とみなす(基本nilが返ることはない)
            if result != KERN_SUCCESS { return nil }
            let isIdle = threadInfo.flags == TH_FLAGS_IDLE
            // CPU使用率がスケール調整済みのため`TH_USAGE_SCALE`で除算し戻す
            return !isIdle ? (Float(threadInfo.cpu_usage) / Float(TH_USAGE_SCALE)) * 100 : nil
        }
        // 合計算出
        .reduce(0, +)
}
</code></pre>

<p><code>Float(threadInfo.cpu_usage) / Float(TH_USAGE_SCALE)</code>已经完成了划分以确保值的精确性，因此有必要进行划分。<br/>
这<code>CPU使用率 / スケール</code>是因为如果你把这个表达式放入，初步完成了下面的处理。</p>

<p><code>CPU使用率 = 0.216</code>如果存在 - &gt; 21.6％的值，则缩放因子获得10的幂，使得CPU使用率是整数。因此，在这种情况下，比例因子是1000。（<code>0.216 * 1000 = 216</code>）<br/>
因此，由于这些系数系数根据值的精度而不同，因此它们必须用于每个线程的除法。</p>

<h2 id="toc_3">内存使用情况</h2>

<pre><code class="language-text">// 必須
import Foundation

// 使用者が単位を把握できるようにするため
typealias MegaByte = UInt64

// 引数にenumで任意の単位を指定できるのが好ましい e.g. unit = .auto (デフォルト引数)
func getMemoryUsed() -&gt; MegaByte? {
    // タスク情報を取得
    var info = mach_task_basic_info()
    // `info`の値からその型に必要なメモリを取得
    var count = UInt32(MemoryLayout.size(ofValue: info) / MemoryLayout&lt;integer_t&gt;.size)
    let result = withUnsafeMutablePointer(to: &amp;info) {
        task_info(mach_task_self_,
                  task_flavor_t(MACH_TASK_BASIC_INFO),
                  // `task_info`の引数にするためにInt32のメモリ配置と解釈させる必要がある
                  $0.withMemoryRebound(to: Int32.self, capacity: 1) { pointer in
                    UnsafeMutablePointer&lt;Int32&gt;(pointer)
                  }, &amp;count)
    }
    // MB表記に変換して返却
    return result == KERN_SUCCESS ? info.resident_size / 1024 / 1024 : nil
}
</code></pre>

<p>在上面的例子中，它是MB单位，但在这种情况下<code>ByteCountFormatter</code>最好使用下面的。<br/>
<code>return</code>，<code>resident_size</code>获取在该点使用的实际内存使用量。*也可以在XCode中确认内存使用情况，但实际内存使用量通常会大于该值。我不知道它消耗了什么，但由于初始值只是不同，似乎通过相对观察没有问题<img src="media/15398626891772/1f646.png" alt="：ok_woman：" title="：ok_woman："/></p>

<h2 id="toc_4"><a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E4%BD%BF%E7%94%A8%E9%87%8F"></a>磁盘使用情况</h2>

<pre><code class="language-text">// 必須(ByteCountFormatterとFileAttributeKeyで使用)
import UIKit

// ディスクスペース種別
enum DiskSpaceType {
    case total
    case free
    case used
}

func getDiskSpace(_ type: DiskSpaceType) -&gt; String {
    // GB,MB,KB表記の文字列に変換
    let byteUnitStringConverted: (Int64) -&gt; String = { size in
        ByteCountFormatter.string(fromByteCount: size,countStyle: ByteCountFormatter.CountStyle.binary)
    }
    switch type {
    case .total:
        // ディスク合計容量
        return byteUnitStringConverted(totalSpace)
    case .free:
        // ディスク空き容量
        return byteUnitStringConverted(freeSpace)
    case .used:
        // ディスク使用量
        return byteUnitStringConverted(usedSpace)
    }
}

var totalSpace: Int64 {
    guard let attributes = systemAttributes,
        let size = (attributes[FileAttributeKey.systemSize] as? NSNumber)?.int64Value
        else { return 0 }
    return size
}

var freeSpace: Int64 {
    guard let attributes = systemAttributes,
        let size = (attributes[FileAttributeKey.systemFreeSize] as? NSNumber)?.int64Value
        else { return 0 }
    return size
}

var usedSpace: Int64 {
    return totalSpace - freeSpace
}

private var systemAttributes: [FileAttributeKey: Any]? {
    return try? FileManager.default.attributesOfFileSystem(forPath: NSHomeDirectory())
}
</code></pre>

<p>关于磁盘使用情况，<code>FileAttributeKey</code>您可以从链接的信息中获取。<code>computed property</code>我认为设置它是安全的，以便总磁盘容量也会波动。</p>

<h2 id="toc_5">摘要</h2>

<ul>
<li>Swift还具有高指针兼容性，因此您可以实现与Objective-C相当的层代码（有时您不能<img src="media/15398626891772/1f914.png" alt="：思维：" title="：思维："/>）</li>
<li>毕竟我们用Swift写了它，过程前景更好 <img src="media/15398626891772/1f60e.png" alt="：墨镜：" title="：墨镜："/></li>
<li>写它像Swift一样很难。 <img src="media/15398626891772/2639.png" alt="：frowning2：" title="：frowning2："/></li>
</ul>

<h2 id="toc_6"><a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5#%E5%8F%82%E8%80%83"></a>参考</h2>

<p><a href="https://www.gnu.org/software/hurd/gnumach-doc/Thread-Information.html">https://www.gnu.org/software/hurd/gnumach-doc/Thread-Information.html</a></p>

<p><a href="https://forums.developer.apple.com/thread/64665">https://forums.developer.apple.com/thread/64665</a></p>

<p><a href="https://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application">https://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application</a></p>

<p><a href="https://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone">https://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于更换主题]]></title>
    <link href="http://www.citynight.cn/Blog/15393255857280.html"/>
    <updated>2018-10-12T14:26:25+08:00</updated>
    <id>http://www.citynight.cn/Blog/15393255857280.html</id>
    <content type="html"><![CDATA[
<p>今天刷Github，看到一个开源App <a href="https://github.com/weiran/Hackers">Hackers</a>源码里面关于更换主题写的挺好的。</p>

<p>原先我的想法就是切换语言和更新主题发送个通知就好了，然后每个页面都监听下这个通知。<br/>
但是这个项目里面采用的是每个控制器都注册下，然后当更换主题时把所有注册的控制器都更新下主题<br/>
可以看下<a href="https://github.com/weiran/Hackers/tree/master/Client/Themes">这部分代码</a><br/>
在<code>Theming.swift</code>文件中定义了<code>ThemeProvider</code> 和 <code>Themed</code>协议</p>

<pre><code class="language-text">/// Describes a type that holds a current `Theme` and allows
/// an object to be notified when the theme is changed.
protocol ThemeProvider {
    /// Placeholder for the theme type that the app will use
    associatedtype Theme
    
    /// The current theme that is active
    var currentTheme: Theme { get }
    
    /// Subscribe to be notified when the theme changes. Handler will be
    /// remove from subscription when `object` is deallocated.
    func subscribeToChanges(_ object: AnyObject, handler: @escaping (Theme) -&gt; Void)
}

/// Describes a type that can have a theme applied to it
protocol Themed {
    /// A Themed type needs to know about what concrete type the
    /// ThemeProvider is. So we don&#39;t clash with the protocol,
    /// let&#39;s call this associated type _ThemeProvider
    associatedtype _ThemeProvider: ThemeProvider
    
    /// Return the current app-wide theme provider
    var themeProvider: _ThemeProvider { get }
    
    /// This will be called whenever the current theme changes
    func applyTheme(_ theme: _ThemeProvider.Theme)
}

extension Themed where Self: AnyObject {
    /// This is to be called once when Self wants to start listening for
    /// theme changes. This immediately triggers `applyTheme()` with the
    /// current theme.
    func setupTheming() {
        applyTheme(themeProvider.currentTheme)
        themeProvider.subscribeToChanges(self) { [weak self] newTheme in
            self?.applyTheme(newTheme)
        }
    }
}
</code></pre>

<p>根据协议可以如下操作：</p>

<pre><code class="language-text">final class AppThemeProvider: ThemeProvider {
    static let shared: AppThemeProvider = .init()
    
    private var theme: SubscribableValue&lt;AppTheme&gt;
    private var availableThemes: [AppTheme] = [.light, .dark]
    
    var currentTheme: AppTheme {
        get {
            return theme.value
        }
        set {
            setNewTheme(newValue)
        }
    }
    
    init() {
        theme = SubscribableValue&lt;AppTheme&gt;(value: .light)
    }
    
    private func setNewTheme(_ newTheme: AppTheme) {
        let window = UIApplication.shared.delegate!.window!!
        UIView.transition(
            with: window,
            duration: 0.3,
            options: [UIView.AnimationOptions.transitionCrossDissolve],
            animations: {
                self.theme.value = newTheme
        },
            completion: nil
        )
    }
    
    func subscribeToChanges(_ object: AnyObject, handler: @escaping (AppTheme) -&gt; Void) {
        theme.subscribe(object, using: handler)
    }
    
    func nextTheme() {
        guard let nextTheme = availableThemes.rotate() else {
            return
        }
        currentTheme = nextTheme
    }
}

extension Themed where Self: AnyObject {
    var themeProvider: AppThemeProvider {
        return AppThemeProvider.shared
    }
}
</code></pre>

<p>具体主题的颜色见<code>Theme.swift</code></p>

<p>由上面的实例我们知道所有页面都是被暂存的，暂存操作为</p>

<pre><code class="language-text">private var theme: SubscribableValue&lt;AppTheme&gt;
</code></pre>

<p>SubscribableValue的具体实现见<code>SubscribableValue.swift</code>，这个结构是一个结构体,如下：</p>

<pre><code class="language-text">/// Stores a value of type T, and allows objects to subscribe to
/// be notified with this value is changed.
struct SubscribableValue&lt;T&gt; {
    private typealias Subscription = (object: Weak&lt;AnyObject&gt;, handler: (T) -&gt; Void)

    private var subscriptions: [Subscription] = []

    var value: T {
        didSet {
            for (object, handler) in subscriptions where object.value != nil {
                handler(value)
            }
        }
    }

    init(value: T) {
        self.value = value
    }

    mutating func subscribe(_ object: AnyObject, using handler: @escaping (T) -&gt; Void) {
        subscriptions.append((Weak(value: object), handler))
        cleanupSubscriptions()
    }

    /// Removes any subscriptions where the object has been deallocated
    /// and no longer exists
    private mutating func cleanupSubscriptions() {
        subscriptions = subscriptions.filter({ entry in
            return entry.object.value != nil
        })
    }
}
</code></pre>

<p>上面的weak的实现为</p>

<pre><code class="language-text">/// A box that allows us to weakly hold on to an object
struct Weak&lt;Object: AnyObject&gt; {
    weak var value: Object?
}
</code></pre>

<p>每个需要更换主题的控制器或者视图都会注册一下，<br/>
<img src="media/15393255857280/15394143263288.jpg" alt="" style="width:1680px;"/></p>

<p><img src="media/15393255857280/15394143483076.jpg" alt="" style="width:1680px;"/></p>

<p><img src="media/15393255857280/15394143927777.jpg" alt="" style="width:1680px;"/></p>

<p>这个就是协议的默认实现，然后会把当前对象注册一下。<br/>
每次赋值的时候都会更新一下所有注册的视图。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[公司规范]]></title>
    <link href="http://www.citynight.cn/Blog/15380500153174.html"/>
    <updated>2018-09-27T20:06:55+08:00</updated>
    <id>http://www.citynight.cn/Blog/15380500153174.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Git分支建议</h2>

<blockquote>
<p>开发必读<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>

<p>多提交，少推送。</p>

<h5 id="toc_1">严格遵守：</h5>

<p>填写本次修改内容</p>

<p>代码合并必须命令行合并，并且加上--no-ff参数。（文章中有详细介绍）</p>

<p>将 <strong>feature/develop_wangchao_打印bug</strong> 分支合并到当前分支命令如下：</p>

<p>git merge --no-ff feature/develop_wangchao_打印bug</p>
</blockquote>

<h5 id="toc_2">与文章中的差异：</h5>

<blockquote>
<p>所有问题由组长来定属于紧急问题，还是特性问题。</p>

<blockquote>
<p>紧急问题上线流程：预发布分支--&gt;生产分支。</p>

<p>特性问题上线流程：开发分支--&gt;预发布分支--&gt;生产分支。（<strong>预发布分支</strong> 从 <strong>生产分支</strong> 拉取）</p>
</blockquote>

<p><strong>预发布分支</strong> 的的问题按照bug分支处理。</p>

<blockquote>
<p>步骤：从 <strong>预发布分支</strong> 拉取bug分支，修改完成后合并到 <strong>预发布分支</strong> ，测试通过后 <strong>预发布分支</strong> 合并到 <strong>生产分支</strong> ，在生产分支打上和 <strong>预发布分支</strong> 名称一样的标签， <strong>预发布分支</strong> 删除，<strong>bug分支</strong> 删除。</p>
</blockquote>

<p>生产环境紧急问题和bug，按照bug分支处理，步骤参考 <strong>预发布分支</strong> bug处理方式。</p>

<p>推荐git图形界面mac用sourcetree，windows用git tortoise，可以清晰看到提交记录图和提交人。</p>

<p>注意：生产分支、预发布分支分别2人有修改权限，负责代码合并，预发布分支合并到生产分支时，需要看git提交记录图，所有修改人员必须签字，说明修改部分关联的项目，分支权限定期抽查。</p>
</blockquote>

<h5 id="toc_3">建议分支命名：</h5>

<blockquote>
<p>云端：</p>

<blockquote>
<pre><code class="language-text">|----master                                         生产分支
|----release                                        预发布分支文件夹
        |----master20180915                         预发布分支
|----develop                                        开发分支
|----feature                                        个人分支文件夹
        |----develop_wangchao_会员结账               具体个人分支
        |----develop_shaochuanjun_微信结账           具体个人分支
|----fixbug                                         bug分支文件夹
        |----master20180915_wangchao_扫码点餐bug     具体个人bug分支
        |----master20180915_shaochuanjun_点菜bug     具体个人bug分支
</code></pre>

<p>能够直观看到个人分支的源分支（从哪个分支拉取的）。</p>

<p>feature、fixbug下的分支不允许跨源合并、跨源拉取（develop_开头的分支只能合并到develop，只能拉取develop分支），release下的分支除外。</p>

<p>实际上bug分支可以往预发布、开发分支合并，简单起见我们禁止跨源合并</p>

<p>release下的分支每次合并到master时要并行合并到develop分支。</p>
</blockquote>

<p>门店：（由于shop、shop-print和海底捞一套代码比较特殊，建议和云端命名方式一样，加上前缀文件夹huoguo或haidilao）</p>

<blockquote>
<p>hht-manage属于新火锅特有项目，建议按照云端命名基础上增加版本号。</p>

<pre><code class="language-text">|----master_v1                                         生产分支
|----master_v2                                         生产分支
|----release                                        预发布分支文件夹
        |----master_v1_20180915                         预发布分支
        |----master_v2_20180915                         预发布分支
|----develop                                        开发分支
|----feature                                        个人分支文件夹
        |----develop_wangchao_会员结账               具体个人分支
        |----develop_shaochuanjun_微信结账           具体个人分支
|----fixbug                                         bug分支文件夹
        |----master20180915_wangchao_扫码点餐bug     具体个人bug分支
        |----master20180915_shaochuanjun_点菜bug     具体个人bug分支
</code></pre>
</blockquote>

<p><strong>举例：</strong></p>

<blockquote>
<p>小A要做一个新功能的步骤：</p>

<p>1、找组长确认属于什么类型问题 ----&gt; 2、属于特性问题 ----&gt; 3、从 <strong>develop</strong> 拉取分支 <strong>feature/develop_A_打印功能</strong> ----&gt; 4、修改完成后--no-ff合并到 <strong>develop</strong> 分支测试 ----&gt; 5、测试通过后找组长从生产分支拉取预发布分支 <strong>release/master20180919</strong> ，把生产环境的数据库备份到预发布环境 ----&gt; 6、组长把 <strong>feature/develop</strong> 合并到 <strong>release/master20180919</strong> ----&gt; 7、开发整理所有预发布环境没有的脚本交给组长 ----&gt; 8、组长存档 <strong>master20180919.sql</strong> 后交给运维执行 ----&gt; 9、测试通过后组长把 <strong>master20180919.sql</strong> 文件上传到 <strong>release/master20180919</strong> 分支，并合并到生产、测试环境，正式环境打上标签 <strong>master20180919</strong> ，删除 <strong>release/master20180919</strong> 分支 ----&gt; 10、运维正式环境执行目录下的 <strong>master20180919.sql</strong> 、打版。</p>

<p>注意：脚本分预制脚本（insert）、建库脚本（create、alter）</p>
</blockquote>
</blockquote>

<h2 id="toc_4">DB建议</h2>

<blockquote>
<p>测试环境开放读写权限，公司白名单。</p>

<p>生产环境云端、门店数据库，白名单访问。</p>

<p>预发布环境只开放读权限，脚本需交给组长备份，组长交给运维执行。建议备份文件名和 <strong>预发布分支</strong> 名保持一致，<strong>预发布分支</strong> 合并到 <strong>生产分支</strong> 时添加到 <strong>预发布分支</strong> 的SQL文件夹下，并执行相同名称的sql文件。</p>

<p>缺：平台出工具根据时间段抽取云端指定商户、门店的数据，并做脱敏处理。</p>
</blockquote>

<h2 id="toc_5">Config建议</h2>

<blockquote>
<p>项目只留address.conf，local.conf两个配置文件，local.conf引用address.conf。所有存在环境差异的配置，都放到address.conf里，不要单独创建redis.conf。</p>

<p>1、address.conf中包含所有项目的ip、端口。</p>

<p>2、打版后线上通过固定目录的address.conf来覆盖打版项目的address.conf，所有项目共用一个。</p>

<p>3、address.conf的修改只能通过运维</p>

<p><strong>例如:</strong></p>

<p>address.conf配置如下：</p>

<p>Markup</p>

<pre><code class="language-text">#在文件中使用方式为：other.var1 = &quot;https://&quot;${address.db1.host}&quot;:&quot;${address.db1.port}&quot;/app/somefunction&quot;
address {
  #数据连接 地址/端口/数据库/用户名/密码
  db {
    host = &quot;10.170.195.16&quot;
    port = &quot;3306&quot;
    db_name = &quot;canyin_saas&quot;
    db_user = &quot;huoguo&quot;
    db_password = &quot;12312300&quot;
  }
  #本地登录及权限服务部署地址
  loginServer{
    host=&quot;http://test-canyinsaas.honghuotai.com&quot;
    port=&quot;8001&quot;
    path=&quot;/login&quot;
  }
  #微信appid
  wechat{
      appid=&quot;aaaaaaaaaaaa&quot;
      #微信appsecret
      appsecret=&quot;bbbbbbbbbbbbbbb&quot;
  }
  # Redis相关配置
  redis{
      ip = 127.0.0.1
      port = 6379
      passwd = 345555
      number = 0
      defaultDBNum = 0
      maxDBNum = 16
      maxActive = 1024
      maxIdle = 200
      maxWait = 1000
      testOnBorrow = false
      testOnReturn = true
  }
}
</code></pre>

<p>dev.conf配置如下</p>

<p>Markup</p>

<pre><code class="language-text">    include &quot;../application.conf&quot;
    include &quot;./address.conf&quot;
    db {
      default.driver = com.mysql.jdbc.Driver
      default.url = &quot;jdbc:mysql://&quot;${address.db.host}&quot;:&quot;${address.db.port}&quot;/&quot;${address.db.db_name}&quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&quot;
      default.username = ${address.db.db_user}
      default.password = ${address.db.db_password}
      default.logSql = true
    }
    # 云端shop服务
    cloudServerSocketService=${address.cloudServerSocket.host}&quot;:&quot;${address.cloudServerSocket.port}${address.loginServer.path}
    #获取所有支付方式
    user.payway.getall=${loginService}&quot;/position/businesspower/getEmpPowerList&quot;
</code></pre>
</blockquote>

<h2 id="toc_6">后端插件建议</h2>

<blockquote>
<p>插件名：Alibaba Java Coding Guidelines</p>

<p>github地址：<a href="https://github.com/alibaba/p3c/">https://github.com/alibaba/p3c/</a></p>

<blockquote>
<p>安装步骤如下：</p>

<p>打开idea--&gt;Preference--&gt;Plugins--&gt;Browse Repositories。</p>

<p>搜Alibaba Java Coding Guidelines，点击安装，重启。</p>

<p>有问题的代码会以红色/黑色波浪线标记出来，需要按照提示修改代码。</p>
</blockquote>
</blockquote>

<h2 id="toc_7">代码建议</h2>

<blockquote>
<p>1、 接口入参避免使用类型强转</p>

<p>2、小数禁止直接参与运算，用BigDecimal</p>

<p>3、禁止直接往缓存中存放数据（前端同样适用）</p>
</blockquote>

<p>Java</p>

<pre><code class="language-text">//问题代码，无法追踪到userInfo的数据在哪里被修改。
public void doProblem(JSONObject userInfo){
    //do something
    if(RedisUtil.get(&quot;userInfo&quot;)!=null){
        //do something
        RedisUtil.del(&quot;userInfo&quot;);
    }else{
        //do something
        RedisUtil.set(&quot;userInfo&quot;,userInfo);
    }
}
//改进代码，可以在addUserInfo、deleteUserInfo方法中监控到userInfo添加、销毁。
public void doRight(JSONObject userInfo){
    //do something
    if(RedisUtil.getUserInfo()!=null){
        //do something
        RedisUtil.deleteUserInfo(&quot;userInfo&quot;);
    }else{
        //do something
        RedisUtil.addUserInfo(&quot;userInfo&quot;,userInfo);
    }
}
</code></pre>

<blockquote>
<p>4、数据库设计，下列字段必须有，model继承com.hht.common.base.model.BaseModel。</p>

<p>涉及到存操作员id的字段，全部存人员id，禁止存用户id（employId(人员id)来自pro_employee表，userId（用户id）来自hht_member表）</p>
</blockquote>

<p>Java</p>

<pre><code class="language-text">    //主键
    private String id;
    //删除状态Y,N
    private String dr;
    //时间戳，每次update操作都要更新
    private Long ts;
    //创建时间，只在insert时更新
    private Long createTime;
    //创建人id
    private String creatorId;
    //修改时间，update时更新此字段
    private Long modifyTime;
    //修改人，update时修改
    private String modifierId;
    //商户id，非报表查询必须加此条件
    private String companyId;
    //门店id，门店查询必须加此条件
    private String shopId;
    //是否可用，预留，N,Y
    private String enable;
</code></pre>

<blockquote>
<p>5、更多建议参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a>里面的《阿里巴巴Java开发手册（详尽版）.pdf》</p>
</blockquote>

<h2 id="toc_8">接口建议</h2>

<blockquote>
<p>rap上的参数必须和实际接口中的参数一致，前后端并行开发时，先约定好mock数据。</p>

<p>严格按照restful规范，外部接口走token，服务之间能走token走token，走不了token走签名，不允许免认证（特殊接口除外）。</p>
</blockquote>

<h2 id="toc_9">打版建议</h2>

<blockquote>
<p>预发布、正式环境打版需填申请单</p>

<blockquote>
<p>1、组长合并代码，根据提交记录图找到所有提交人。</p>

<p>2、所有提交人签字，写上自己修改部分的关联项目，测试环境测试人员签字。（抽查）</p>

<p>3、预发布环境测试完成，期间所有脚本经过组长备份后交给运维执行。</p>

<p>4、预发布分支合并到生产环境分支，运行和预发布分支名称一样的数据库脚本文件，测试人员签字。</p>

<p>5、实施验证问题，填写或邮件确认验证情况。</p>

<p>6、申请单完成，交给产品存档。</p>
</blockquote>

<h2 id="toc_10">日志建议</h2>

<p>先按照各组需求输出，规范待整理</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各种队列的执行效果]]></title>
    <link href="http://www.citynight.cn/Blog/15375346728525.html"/>
    <updated>2018-09-21T20:57:52+08:00</updated>
    <id>http://www.citynight.cn/Blog/15375346728525.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">并发队列</th>
<th style="text-align: left">手动创建的串行队列</th>
<th style="text-align: left">主队列</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">同步（sync）</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
</tr>
<tr>
<td style="text-align: left">异步（async）</td>
<td style="text-align: left">*有开启新线程 *并发执行任务</td>
<td style="text-align: left">*有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocaPods 添加头文件的报错  的解决办法]]></title>
    <link href="http://www.citynight.cn/Blog/15374224515215.html"/>
    <updated>2018-09-20T13:47:31+08:00</updated>
    <id>http://www.citynight.cn/Blog/15374224515215.html</id>
    <content type="html"><![CDATA[
<p>在buildsetting中的以下两个路径中添加对应的设置，重现编译即可解决，stackoverflow地址：<a href="https://stackoverflow.com/questions/45779591/failed-to-emit-precompiled-header-for-bridging-header?answertab=votes#tab-top">Failed to emit precompiled header for bridging header</a></p>

<pre><code class="language-text">Solution:
1 I added $(inherited) non-recursive to Search Path -&gt; Header Search Paths
2 Then added ${PODS_ROOT} recursive to Search Path -&gt; User Header Search Paths
Both the above in my projects&#39; target build settings.
</code></pre>

<p><img src="media/15374224515215/15374225919741.jpg" alt="" style="width:794px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[<禅与摩托车维修艺术>]]></title>
    <link href="http://www.citynight.cn/Blog/15366461063408.html"/>
    <updated>2018-09-11T14:08:26+08:00</updated>
    <id>http://www.citynight.cn/Blog/15366461063408.html</id>
    <content type="html"><![CDATA[
<p>生活处处都透露着哲学，作者从骑摩托车旅行的途中对事物进行了深入的思考。</p>

<h2 id="toc_0">关于·忙·</h2>

<p>书中这样写道：</p>

<blockquote>
<p>我们常常太忙而没有时间好好聊聊，结果日复一日地过着无聊的生活，单调乏味的日子让人几年后想起来不禁怀疑，究竟自己是怎么过的，而时间已悄悄溜走了。现在我们的确空下来了，我想谈一些我自己觉得颇为重要的事。</p>
</blockquote>

<h2 id="toc_1">关于·过程·</h2>

<blockquote>
<p>如果搭飞机抵达洛基山，你只会觉得景致很美，但是如果你是经过几天辛苦的旅程，通过这一片大草原，才抵达洛基山，那么你会从另一个角度来看它，那里仿佛是你的目标，是你的应许之地。</p>
</blockquote>

<p>我们的目标不应该仅仅是到达终点，旅途中的风景会让这个过程变得充实。我在记笔记的时候写的是“有过程的经历是印象深刻的”</p>

<h2 id="toc_2">关于·识人·</h2>

<blockquote>
<p>又钻进死胡同了。如果有人不懂心存感激，而你当面告诉他，那么你就等于是在骂他，这样你什么事都解决不了。<br/>
每个人的性格都是不一样的，需要针对不同的性格做出不同的处理方式。错误的处理方式只会加深矛盾</p>
</blockquote>

<h2 id="toc_3">关于·认知·</h2>

<blockquote>
<p>一名没有受过训练的旁观者只看到修理人员所付出的劳力，就以为他最主要的工作在于劳力。事实上，这正是他最轻松也是工作上最小的一部分，他最重要的工作就在于仔细观察和精确思考，这就是为什么技术人员往往显得沉默寡言，甚至在做实验的时候有些畏缩。他们不喜欢在做实验的时候讲话，那样就无法专心地思考问题了。他们借着实验推论出问题的结构，然后与心里正常的运作结构相比较，所以他们看到的是基本形式。</p>
</blockquote>

<p>隔行如隔山，拿程序员举例，其他人看到程序员噼里啪啦敲代码感觉这个人很厉害这其实是不对的。在敲代码之前的思考才是最重要的，敲代码只不过是把他思考的东西进行验证。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[framework脚本]]></title>
    <link href="http://www.citynight.cn/Blog/15345002536089.html"/>
    <updated>2018-08-17T18:04:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/15345002536089.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">if [ &quot;${ACTION}&quot; = &quot;build&quot; ]

then

INSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework

DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework

SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework

SIMULATOR_SWIFT_MODULE_DIR=&quot;${SIMULATOR_DIR}/Modules/${PROJECT_NAME}.swiftmodule/*&quot;

INSTALL_SWIFT_MODULE_DIR=${INSTALL_DIR}/Modules/${PROJECT_NAME}.swiftmodule/

if [ -d &quot;${INSTALL_DIR}&quot; ]

then

rm -rf &quot;${INSTALL_DIR}&quot;

fi

mkdir -p &quot;${INSTALL_DIR}&quot;

cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

#ditto &quot;${DEVICE_DIR}/Headers&quot; &quot;${INSTALL_DIR}/Headers&quot;

lipo -create &quot;${DEVICE_DIR}/${PROJECT_NAME}&quot; &quot;${SIMULATOR_DIR}/${PROJECT_NAME}&quot; -output &quot;${INSTALL_DIR}/${PROJECT_NAME}&quot;

cp ${SIMULATOR_SWIFT_MODULE_DIR} &quot;${INSTALL_SWIFT_MODULE_DIR}&quot;

#open &quot;${DEVICE_DIR}&quot;

open &quot;${SRCROOT}/Products&quot;

fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 第0的sectionHeaderView 不显示]]></title>
    <link href="http://www.citynight.cn/Blog/15336071866624.html"/>
    <updated>2018-08-07T09:59:46+08:00</updated>
    <id>http://www.citynight.cn/Blog/15336071866624.html</id>
    <content type="html"><![CDATA[
<p>只有当UITableView是Grouped样式，并且section的高度是通过sectionHeaderHeight设置的时候，第0个section的headerView才会丢失，通过代理设置不会丢失。如果UITableView是Plain样式就不会有任何问题。</p>

<p>下面是不显示第0个sectionHeaderView的情况<br/>
<img src="media/15336071866624/15336074512241.jpg" alt="" style="width:1406px;"/></p>

<p>正常显示<br/>
<img src="media/15336071866624/15336075291692.jpg" alt="" style="width:1394px;"/><br/>
在正常显示的时候明显感觉到第0个section上面有间距，真机没有测试。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[控制器透明，WebView透明]]></title>
    <link href="http://www.citynight.cn/Blog/15323970557540.html"/>
    <updated>2018-07-24T09:50:55+08:00</updated>
    <id>http://www.citynight.cn/Blog/15323970557540.html</id>
    <content type="html"><![CDATA[
<p>设置控制器透明</p>

<pre><code class="language-text">let vc = AfterOrderPotADViewController()
self.definesPresentationContext = true
vc.modalPresentationStyle = .overCurrentContext
vc.view.backgroundColor = UIColor(red: 0, green: 0, blue: 0, alpha: 0.3)
self.present(vc, animated: false, completion: nil)
</code></pre>

<p>webView 设置透明</p>

<pre><code class="language-text">webView.backgroundColor = UIColor.clear
webView.isOpaque = false
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法总结]]></title>
    <link href="http://www.citynight.cn/Blog/15323249439841.html"/>
    <updated>2018-07-23T13:49:03+08:00</updated>
    <id>http://www.citynight.cn/Blog/15323249439841.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Fibonacci （斐波那契数列实现）</h2>

<pre><code class="language-text">///Fibonacci （斐波那契数列实现）
func fibonacci(_ n: Int) -&gt; Int{
    let result = [0,1]
    if n &lt; 2 {
        return result[n]
    }
    
    var fibNMinusOne = 1
    var fibNMinusTwo = 0
    var fibN = 0
    
    for _ in 2...n {
        fibN = fibNMinusOne + fibNMinusTwo
        fibNMinusTwo = fibNMinusOne
        fibNMinusOne = fibN
    }
    return fibN
}
</code></pre>

<h2 id="toc_1">BinarySearch (二分查找)</h2>

<h3 id="toc_2">非递归</h3>

<pre><code class="language-text">func binarySearch&lt;T: Comparable&gt;(_ a:[T], key: T) -&gt; Int {
    print(key)
    var lowerBound = 0
    var upperBound = a.count
    while lowerBound &lt; upperBound {

        let midIndex = lowerBound + (upperBound - lowerBound)/2

        if a[midIndex] == key {
            return midIndex
        }else if a[midIndex] &lt; key {
            lowerBound = midIndex + 1
        }else {
            upperBound = midIndex
        }
    }
    return -1
}
</code></pre>

<h3 id="toc_3">递归</h3>

<pre><code class="language-text">func binarySearch&lt;T : Comparable&gt;(startIndex: Int, endIndex: Int , arr:[T], key: T) -&gt; Int{
    let mind = startIndex + (endIndex - startIndex) / 2
    let mindValue = arr[mind]
    if mindValue == key {
        return mind
    }
    if mindValue &lt; key {
        return binarySearch(startIndex: mind + 1, endIndex: endIndex, arr: arr, key: key)
    } else if mindValue &gt; key {
        return binarySearch(startIndex: 0, endIndex: mind, arr: arr, key: key)
    }
    return -1
}
</code></pre>

<h2 id="toc_4">快速排序</h2>

<pre><code class="language-text">func quicksort&lt;T: Comparable&gt;(_ unsort:[T]) -&gt; [T] {
    guard unsort.count &gt; 1 else {
        return unsort
    }
    
    let pivot = unsort[unsort.count / 2]
    let less = unsort.filter { $0 &lt; pivot }
    let equal = unsort.filter { $0 == pivot }
    let greater = unsort.filter { $0 &gt; pivot }
    
    return quicksort(less) + equal + quicksort(greater)
}
</code></pre>

<p>测试结果</p>

<pre><code class="language-text">let list = [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]

print(list)
print(quicksort(list))
--------------------
[10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26]
[-1, 0, 1, 2, 3, 5, 8, 8, 9, 10, 14, 26, 27]

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决UILabel 末尾的空格被忽略]]></title>
    <link href="http://www.citynight.cn/Blog/15319018166027.html"/>
    <updated>2018-07-18T16:16:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/15319018166027.html</id>
    <content type="html"><![CDATA[
<p>看到这篇文章<a href="https://www.lidaren.com/archives/1333">UILabel取消自动Trim空格和换行等空白字符</a></p>

<pre><code class="language-text">UILabel会自动清除的空白字符（UNICODE）
\u0009 CHARACTER TABULATION
\u000A LINE FEED
\u000D CARRIAGE RETURN
\u0020 SPACE
\u0085 NEXT LINE
\u00A0 NBSP
\u1680 OGHAM SPACE MARK
\u180E MONGOLIAN VOWEL SEPARATOR
\u2000 EN QUAD
\u200A HAIR SPACE
\u200B ZERO WIDTH SPACE
\u2028 LINE SEPARATOR
\u2029 PARAGRAPH SEPARATOR
\u202F NARROW NO-BREAK SPACE
\u205F MEDIUM MATHEMATICAL SPACE
\u3000 IDEOGRAPHIC SPACE
</code></pre>

<p>解决方案</p>

<pre><code class="language-text">    let paragraphStyle = NSMutableParagraphStyle()
    paragraphStyle.alignment = .right
    paragraphStyle.tailIndent = -10
    let myMutableString = NSMutableAttributedString(
        string: text,
        attributes: [
            NSAttributedStringKey.font: UIFont.systemFont(ofSize: 16),
            NSAttributedStringKey.paragraphStyle: paragraphStyle
        ]
    )
    label.attributedText = myMutableString
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片加载方式]]></title>
    <link href="http://www.citynight.cn/Blog/15299939008214.html"/>
    <updated>2018-06-26T14:18:20+08:00</updated>
    <id>http://www.citynight.cn/Blog/15299939008214.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15299939008214/15299939112098.jpg" alt=""/><br/>
<img src="media/15299939008214/15299939172785.jpg" alt=""/></p>

<p>图像的降采样</p>

<p>不要使用昂贵的UIImage：UIImage会解压原始的图片占用大量的内存<br/>
内部的坐标变换也非常昂贵</p>

<p>使用ImageIO的CGImageSourceCreateThumbnailAtIndex API: 无视原始图片尺寸，resize的内存开销只是目标尺寸（请看Session中后半部分的Demo）</p>

]]></content>
  </entry>
  
</feed>
