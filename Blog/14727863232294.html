<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	runtime(内部分享草稿) - 
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://raw.githubusercontent.com/Mekor/mekor.github.io/master/Blog/asset/icon.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html"></a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">runtime(内部分享草稿)</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2 id="toc_0">理解self,super,class,superclass</h2>

<p>创建一个Person里面有一个类方法:</p>

<pre><code class="language-objc">#import &quot;Person.h&quot;

@implementation Person
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<p>Student继承自Person,重写父类方法</p>

<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<p>这两个输出的都是什么?<br/>
<img src="media/14727863232294/14729913552743.jpg" alt=""/></p>

<p>这时,我们在Student中用这样写:</p>

<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
//    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
    
    [super study];
}
@end
</code></pre>

<p>打断点我们可以看到:<br/>
<img src="media/14727863232294/14729934417192.jpg" alt=""/></p>

<p>可以看出:</p>

<pre><code class="language-objc">super：是编译器指示符，仅仅是一个标志,并不是指针，仅仅是标志的当前对象去调用父类的方法，本质还是当前对象调用
super:并不是让父类对象调用方法，调用者还是本身
class：获取方法调用者的类
superclass:获取方法调用者的父类
</code></pre>

<h2 id="toc_1">self是从哪里来的?</h2>

<blockquote>
<p>官方解释:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">Objective-C Runtime Programming Guide</a><img src="media/14727863232294/14729941396965.jpg" alt=""/></p>
</blockquote>

<p>简单说每个方法都存在并且隐藏的两个参数(self,_cmd),随便写个方法看下:<br/>
Student中写个text方法,然后打印下这两个隐藏参数.<br/>
<img src="media/14727863232294/14729960900273.jpg" alt=""/><br/>
<img src="media/14727863232294/14729961142923.jpg" alt=""/></p>

<h2 id="toc_2">动态添加方法</h2>

<p>上面说了一些貌似和runtime没有什么关系,那么根据上面所说的方法说下动态添加方法.</p>

<blockquote>
<p>思考一下,咱们new项目中将采用路由模式进行页面跳转,从网页跳转进入app调用一个方法,一般情况下都是移动端和后台协议好的内容,这样跳转不会出现问题.但是如果后台写错了或者传输中出现问题导致url中包含的方法名不是规定的方法名.这时怎么办?</p>
</blockquote>

<pre><code class="language-objc">    Student *s = [Student new];
    
    // 1. 比如我们要调用 Student中的eat方法, 默认这样写[s eat]; 但是不行,因为我们没有定义.
//    [s eat];
    // 2. 也可以这样调用[s performSelector:@selector(eat)];这样没有问题,@selector中参数是字符串,这个参考swift
//    [s performSelector:@selector(eat)];
    // 3. 使用string创建SEL
    
#pragma clang diagnostic push
#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;
    [s performSelector:NSSelectorFromString(@&quot;eat&quot;)];
#pragma clang diagnostic pop
    
    // 上面这样调用会报错,我们在对象调用未实现方法的时候动态的创建一个方法,避免抛出异常.
</code></pre>

<p>怎么忽略编译器警告已经分享过,可以参考:<a href="http://www.citynight.cn/Blog/14676105703423.html">http://www.citynight.cn/Blog/14676105703423.html</a></p>

<p>怎么动态添加方法呢?<br/>
<img src="media/14727863232294/14729983827897.jpg" alt=""/><br/>
上面是动态添加对象方法的例子,动态添加类方法也是一样的<code>+(BOOL)resolveClassMethod:(SEL)sel</code><br/>
<strong>注意</strong>上面函数类型,有人可能好奇这块为什么写成&quot;v@:&quot;  ?先看文档:<br/>
<img src="media/14727863232294/14730056768742.jpg" alt=""/><br/>
查看<code>Objective-C type encodings</code> <img src="media/14727863232294/14730058881001.jpg" alt=""/><br/>
所以上面void eat(...)应该表述成 <code>&quot;v@:&quot;</code></p>

<h2 id="toc_3">方法交换(Method Swizzling:传说中的黑魔法)</h2>

<p>一般使用方法交换都是想给系统提供的方法添加一些其他的功能的时候使用.new中使用方法交换的例子:</p>

<pre><code class="language-objc">#import &quot;UIActionSheet+Front.h&quot;

#import &lt;objc/runtime.h&gt;

@implementation UIActionSheet (Front)
- (void)customShowInView:(UIView *)view{
    for(UIWindow * tmpWin in [[UIApplication sharedApplication] windows]){
        [tmpWin endEditing:NO];
    }
    [self customShowInView:view];
}
+ (void)load{
    swizzleAllActionSheet();
}
@end

void swizzleAllActionSheet(){
    Class c = [UIActionSheet class];
    SEL origSEL = @selector(showInView:);
    SEL newSEL = @selector(customShowInView:);
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = class_getInstanceMethod(c, newSEL);
    method_exchangeImplementations(origMethod, newMethod);
}
</code></pre>

<p>关于方法交换,在new项目中已经封装好了,代码如下:</p>

<pre><code class="language-objc">// ObjcRuntime.h文件
void Swizzle(Class c, SEL origSEL, SEL newSEL);

//ObjcRuntime.m文件
//静态就交换静态，实例方法就交换实例方法
void Swizzle(Class c, SEL origSEL, SEL newSEL)
{
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = nil;
    if (!origMethod) {
        origMethod = class_getClassMethod(c, origSEL);
        if (!origMethod) {
            return;
        }
        newMethod = class_getClassMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }else{
        newMethod = class_getInstanceMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }
    
    //自身已经有了就添加不成功，直接交换即可
    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))){
        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
    }else{
        method_exchangeImplementations(origMethod, newMethod);
    }
}
</code></pre>

<p>用法(还是以Student为例):<br/>
Student中添加两个对象方法,一个run,一个sleep.我们的目的是交换两个方法的实现</p>

<pre><code class="language-objc">-(void)run {
    NSLog(@&quot;跑🏃&quot;);
}
-(void)sleep {
    NSLog(@&quot;睡觉😴&quot;);
}
+(void)load {
    Swizzle(self, @selector(run), @selector(sleep));
}
</code></pre>

<p>控制器调用的结果:<br/>
<img src="media/14727863232294/14730042652865.jpg" alt=""/></p>

<h2 id="toc_4">添加属性</h2>

<p>动态添加属性用的最多的地方应该是给分类添加属性.我在项目中添加过一个分类<code>UIView+Tap</code>这个也可以在这里查看<a href="https://github.com/Mekor/UIView-Tap">UIView-Tap</a></p>

<pre><code class="language-objc">#import &quot;UIView+Tap.h&quot;
#import &lt;objc/runtime.h&gt;

static const void* tagValue = &amp;tagValue;

@interface UIView ()
@property (nonatomic, copy) void(^tapAction)(id);
@end

@implementation UIView (Tap)
- (void)tap{
    if (self.tapAction) {
        self.tapAction(self);
    }
}
- (void)addTapBlock:(void(^)(id obj))tapAction{
    self.tapAction = tapAction;
    if (![self gestureRecognizers]) {
        self.userInteractionEnabled = YES;
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

-(void)setTapAction:(void (^)(id))tapAction {
    objc_setAssociatedObject(self, tagValue, tapAction, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(void (^)(id))tapAction {
    return objc_getAssociatedObject(self, tagValue);
}
@end
</code></pre>

<p>主要是set&amp;get方法,这点注意了也就没啥了..</p>

<p>系统中常见的使用到runtime的地方:<a href="http://www.citynight.cn/Blog/14726525723684.html">KVO内部实现原理</a><br/>
日常开发中使用到runtime的地方:</p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>